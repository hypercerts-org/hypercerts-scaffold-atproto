{"id":"hypercerts-0yp","title":"Epic: PDS Deployment \u0026 End-to-End Integration","description":"## Goal\nDeploy the PDS sidecar auth service alongside the Certified PDS at `pds-eu-west4.test.certified.app`, configure the PDS to work with the sidecar, and verify the complete email-first passwordless login flow end-to-end from the scaffold app through the sidecar to the PDS and back.\n\n## Context\nWe are the Certified team and control the PDS deployment. The PDS currently runs stock `@atproto/pds` in standalone mode (it is its own authorization server). We need to:\n1. Co-deploy the sidecar auth service with the PDS\n2. Configure the PDS so the sidecar can override its OAuth authorization server metadata\n3. Set up Docker Compose with Caddy for TLS (sidecar on auth subdomain, PDS on main domain)\n4. Configure SMTP for OTP email delivery\n5. Test the complete flow: scaffold → PDS (PAR) → sidecar (email + OTP) → PDS (auth code) → scaffold (callback)\n6. Handle existing users who have password-based accounts\n\n## Architecture\n```\nInternet\n  │\n  ▼\nCaddy (TLS termination, routing)\n  ├── pds.certs.network      → PDS Core (port 3000)\n  ├── auth.pds.certs.network → Sidecar Auth Service (port 3001)\n  └── *.pds.certs.network    → PDS Core (handle resolution)\n```\n\nBoth PDS and sidecar run in the same Docker Compose stack, sharing:\n- A Docker network (sidecar can reach PDS internally)\n- A shared HMAC secret for signed callbacks\n- The sidecar has access to the PDS's `OAuthProvider` instance (same process or via internal API)\n\n## Key Concerns\n- **Existing users:** Users who created accounts with passwords can still log in — the sidecar should check if an email exists in the PDS and authenticate accordingly. Password reset flow (`com.atproto.server.resetPassword`) must remain available as a recovery path.\n- **DNS:** Need wildcard DNS for handle resolution (`*.pds.certs.network`) plus the auth subdomain\n- **TLS:** Caddy handles automatic TLS via Let's Encrypt. Need DNS challenge for wildcard certs.\n- **Email deliverability:** SPF/DKIM/DMARC records on the sending domain. Use a reputable SMTP provider.\n- **Monitoring:** Health checks, structured logging (pino), basic metrics endpoint\n\n## Success Criteria\n- Docker Compose stack starts cleanly with PDS + sidecar + Caddy\n- OAuth metadata at `/.well-known/oauth-authorization-server` shows sidecar's `authorization_endpoint`\n- Complete login flow works from scaffold app to PDS and back\n- OTP emails are delivered reliably\n- Existing password-based users can still authenticate\n- TLS works on all endpoints\n- Health checks pass for all services","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:12:26.180448+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.582864+08:00","closed_at":"2026-02-18T15:50:27.582867+08:00","labels":["scope:medium"]}
{"id":"hypercerts-0yp.1","title":"Create Docker Compose stack with Caddy, PDS, and sidecar","description":"## Files\n- docker-compose.yml (create)\n- Dockerfile.pds (create)\n- Dockerfile.auth (create)\n- Caddyfile (create)\n- .env.example (create)\n\n## What to do\nCreate the Docker Compose deployment configuration for the complete PDS + sidecar stack.\n\n### `docker-compose.yml`\nThree services:\n\n#### `caddy`\n- Image: `caddy:2-alpine`\n- Ports: 80, 443\n- Volumes: `./Caddyfile:/etc/caddy/Caddyfile`, `caddy_data:/data`, `caddy_config:/config`\n- Depends on: pds, auth\n\n#### `pds`\n- Build: `Dockerfile.pds`\n- Port: 3000 (internal only, not exposed to host)\n- Volumes: `pds_data:/data` (for SQLite + blobs)\n- Environment: all PDS env vars from .env\n- Health check: `curl -f http://localhost:3000/xrpc/_health`\n\n#### `auth`\n- Build: `Dockerfile.auth`\n- Port: 3001 (internal only)\n- Volumes: `auth_data:/data` (for sidecar SQLite)\n- Environment: auth service env vars from .env\n- Health check: `curl -f http://localhost:3001/health`\n- Depends on: pds\n\n### `Caddyfile`\n```\npds.certs.network {\n    reverse_proxy pds:3000\n}\n\nauth.pds.certs.network {\n    reverse_proxy auth:3001\n}\n\n*.pds.certs.network {\n    reverse_proxy pds:3000\n}\n```\nUse on-demand TLS or DNS challenge for wildcard certs (configure via env var for the DNS provider).\n\n### Dockerfiles\nBoth should be multi-stage builds:\n1. Stage 1: `node:20-alpine` — install deps, build TypeScript\n2. Stage 2: `node:20-alpine` — copy built files, run with `node dist/index.js`\n\n### `.env.example`\nDocument all required environment variables with comments:\n- PDS config (hostname, admin password, PLC URL, etc.)\n- Auth service config (SMTP host/port/user/pass, from address)\n- Shared config (CALLBACK_SECRET)\n- Caddy config (DNS provider API key for wildcard certs)\n\n## Don't\n- Don't include actual secrets in any committed file\n- Don't expose PDS or auth ports directly to the host (only through Caddy)\n- Don't use `latest` tags for base images — pin versions","acceptance_criteria":"1. `docker compose build` succeeds\n2. `docker compose up` starts all three services\n3. Health checks pass for PDS and auth service\n4. Caddy serves HTTPS on the configured domains\n5. `.env.example` documents all required variables\n6. No secrets are committed to the repository","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-17T18:16:43.769223+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:50:24.136962+08:00","closed_at":"2026-02-17T18:50:24.136962+08:00","close_reason":"3471b74 Add Docker Compose stack with Caddy, PDS, and sidecar","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-0yp.1","depends_on_id":"hypercerts-0yp","type":"parent-child","created_at":"2026-02-17T18:16:43.77054+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-0yp.1","depends_on_id":"hypercerts-qc3.6","type":"blocks","created_at":"2026-02-17T18:16:43.77197+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-0yp.1","depends_on_id":"hypercerts-qc3.7","type":"blocks","created_at":"2026-02-17T18:16:43.772825+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-1t8","title":"Epic: Integration Testing \u0026 Production Docs","description":"## Goal\nVerify the complete email→OTP→session flow works end-to-end and create the documentation needed for production deployment and partner app integration.\n\n## Context\nOnce the sidecar (Epic: Sidecar Auth Service) and scaffold UI (Epic: Scaffold Email-First Login UI) are built, we need to:\n1. Test the full flow locally: scaffold → PDS → sidecar → OTP → PDS → scaffold\n2. Document how to deploy to production (certified.app)\n3. Document how partner apps (GainForest, Silvi) integrate\n\n## What Has to Be Built\n1. Playwright E2E test suite against local dev stack\n2. Manual test checklist for security edge cases\n3. Production deployment guide (DNS, TLS, SMTP, secrets)\n4. Partner app integration guide (BFF pattern)\n\n## Local Dev Stack\n- Scaffold: http://127.0.0.1:3000\n- PDS: http://localhost:2583\n- Auth service (sidecar): http://localhost:2584\n- MailHog: SMTP on :1025, web UI on http://localhost:8025","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T15:49:41.127646+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.914415+08:00","closed_at":"2026-02-18T15:54:58.914417+08:00","labels":["scope:medium"]}
{"id":"hypercerts-1t8.1","title":"Create Playwright E2E tests for email-first auth flow","description":"## Files\n- e2e/auth-flow.spec.ts (create)\n- e2e/helpers/mailhog.ts (create)\n- e2e/playwright.config.ts (create)\n- package.json (modify — add @playwright/test devDependency)\n\n## What to do\nCreate Playwright E2E tests that exercise the full email→OTP→session flow against the local dev stack (must be running).\n\n### MailHog helper (e2e/helpers/mailhog.ts)\n- getLatestOTP(email): polls MailHog API at http://localhost:8025/api/v2/search, extracts 8-digit code from email body. Retries 10x with 1s delay.\n- clearMailbox(): DELETE http://localhost:8025/api/v1/messages\n\n### Test cases (e2e/auth-flow.spec.ts)\n1. **New user sign-up**: navigate to /login → enter unique email → click Continue → wait for redirect to sidecar → get OTP from MailHog → enter code → wait for redirect back → verify logged in\n2. **Existing user sign-in**: use email from test 1 → same flow → verify logged in\n3. **Invalid OTP retry**: enter wrong code → see error → enter correct code → success\n4. **Handle-based login**: enter handle in secondary section → verify redirect to PDS\n\n### Playwright config\n- baseURL: http://127.0.0.1:3000\n- timeout: 30000\n- retries: 0\n- reporter: html\n\n## Don't\n- Start the dev stack from tests (assume running)\n- Use real email addresses\n- Hard-code OTP codes\n- Skip MailHog cleanup between tests","acceptance_criteria":"1. Playwright config exists. 2. MailHog helper extracts OTP codes. 3. At least 3 test scenarios implemented. 4. Tests pass against running local dev stack. 5. @playwright/test in devDependencies.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T15:49:56.315579+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.844507+08:00","closed_at":"2026-02-18T15:54:58.844509+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-1t8.1","depends_on_id":"hypercerts-1t8","type":"parent-child","created_at":"2026-02-18T15:49:56.316946+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-1t8.1","depends_on_id":"hypercerts-mws.5","type":"blocks","created_at":"2026-02-18T15:49:56.3187+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-1t8.1","depends_on_id":"hypercerts-y9g.1","type":"blocks","created_at":"2026-02-18T15:49:56.319788+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-1t8.2","title":"Create production deployment guide and partner integration docs","description":"## Files\n- docs/production-deployment.md (create)\n- docs/certified-oauth-integration.md (create)\n- docs/manual-test-checklist.md (create)\n\n## What to do\n\n### production-deployment.md\nStep-by-step guide to deploy the full stack at certified.app:\n1. Prerequisites (Docker, domain, SMTP provider)\n2. DNS setup (A records for certified.app, auth.certified.app, *.certified.app)\n3. Email deliverability (SPF/DKIM/DMARC record examples)\n4. Secrets generation (openssl commands for every secret)\n5. Docker Compose deployment (reference docker-compose.yml)\n6. Health checks (curl commands to verify each service)\n7. Backup strategy (SQLite backup for PDS + sidecar data)\n8. Monitoring (what to alert on)\n\n### certified-oauth-integration.md\nGuide for GainForest/Silvi to add 'Sign in with Certified':\n1. Overview of the flow\n2. Prerequisites (Node.js, Redis, SDK)\n3. Environment setup (NEXT_PUBLIC_PDS_URL=https://certified.app, JWK generation)\n4. OAuth client metadata routes (copy from scaffold)\n5. Email-login API route (copy from scaffold)\n6. Frontend email input form\n7. Session management\n8. Troubleshooting\n\nAll code examples copied from actual scaffold source files with file path references.\n\n### manual-test-checklist.md\n18+ test cases with ID, steps, expected result, pass/fail checkbox:\n- Rate limiting (3 cases)\n- OTP security (4 cases: wrong code, expiry, replay, invalidation)\n- Session management (4 cases: persist, logout, multi-browser, cookie clear)\n- Error handling (3 cases: invalid email, PDS down, sidecar down)\n- OAuth (3 cases: deny consent, multi-app, token revocation)\n- Handle fallback (1 case)\n\n## Don't\n- Include actual secrets or API keys\n- Invent code examples (copy from scaffold)\n- Skip SPF/DKIM/DMARC (critical for email delivery)\n- Assume reader knows ATProto internals","acceptance_criteria":"1. All 3 docs exist. 2. production-deployment.md has all 8 sections with DNS/DKIM examples. 3. certified-oauth-integration.md has real code examples from scaffold. 4. manual-test-checklist.md has 18+ test cases with checkboxes. 5. No actual secrets in any file.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T15:50:14.860548+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.76936+08:00","closed_at":"2026-02-18T15:54:58.769365+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-1t8.2","depends_on_id":"hypercerts-1t8","type":"parent-child","created_at":"2026-02-18T15:50:14.861731+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-1t8.2","depends_on_id":"hypercerts-mws.5","type":"blocks","created_at":"2026-02-18T15:50:14.863154+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-1t8.2","depends_on_id":"hypercerts-y9g.1","type":"blocks","created_at":"2026-02-18T15:50:14.864255+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-25h","title":"Fix: /auth/resend-code endpoint referenced in template but not implemented (from hypercerts-qc3.6)","description":"Review of hypercerts-qc3.6 found: templates.ts renderOTPPage() includes a 'Resend code' link that POSTs to /auth/resend-code, but no route handler for POST /auth/resend-code exists in the auth-service routes (only send-code.ts, verify-code.ts, authorize.ts). Clicking 'Resend code' will return a 404. Evidence: packages/auth-service/src/templates.ts line 109 fetches '/auth/resend-code'; no route file handles this path. Fix: either implement POST /auth/resend-code (which re-sends the OTP for the current session email) or remove the resend link from the template.","status":"closed","priority":1,"issue_type":"bug","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:53:02.649149+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.752727+08:00","closed_at":"2026-02-17T18:56:11.752733+08:00","dependencies":[{"issue_id":"hypercerts-25h","depends_on_id":"hypercerts-qc3.6","type":"discovered-from","created_at":"2026-02-17T18:53:02.765007+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-2bf","title":"Epic: Scaffold Email-First Auth UI","description":"## Goal\nBuild a new email-first login page at `/login` in the hypercerts-scaffold Next.js app. This page replaces the handle-based login flow with an email input that initiates ATProto OAuth with the user's email passed as `login_hint`. The old handle-based login (`LoginDialog` component, `SignedInProvider` gate) remains untouched — both flows coexist so we can test the new flow independently.\n\n## Context\nThe scaffold app currently requires users to enter their ATProto handle (e.g., `alice.certified.app`) to log in. This is confusing for non-technical users. We're building email-first passwordless login where users enter their email, receive a 6-digit OTP code, and are authenticated — no handles, no passwords.\n\nThe scaffold's role is the **client side** of this flow. A separate PDS sidecar service (different repo) handles the server-side OTP generation/verification. The scaffold just needs to:\n1. Collect the user's email\n2. Pass it as `login_hint` in the ATProto OAuth authorization URL\n3. Handle the standard OAuth callback (unchanged)\n\nThe PDS sidecar intercepts the OAuth authorization endpoint and uses the `login_hint` to send an OTP email immediately, so the user sees an OTP input (not a password form) at the PDS.\n\n## Technical Background\n- **Framework:** Next.js 16 with App Router\n- **Current auth flow:** User enters handle → POST `/api/auth/login` → `sdk.authorize(handle)` → redirect to PDS → password form → callback → session cookie\n- **New auth flow:** User enters email → POST `/api/auth/login` with email + `login_hint` → `sdk.authorize(pdsUrl, { login_hint: email })` → redirect to PDS sidecar → OTP form → callback → session cookie\n- **Key files:** `components/login-dialog.tsx`, `app/api/auth/login/route.ts`, `lib/config.ts`, `lib/hypercerts-sdk.ts`, `providers/SignedInProvider.tsx`\n- **UI components available:** shadcn/ui (Button, Input, Card, InputGroup, Spinner, etc.), Tailwind CSS, fonts: Syne (headings), Outfit (body)\n- **SDK:** `@hypercerts-org/sdk-core` wraps `@atproto/oauth-client-node`. The `sdk.authorize()` method accepts a handle, DID, or PDS URL.\n\n## Success Criteria\n- New `/login` page exists with email input and unified sign-in/sign-up flow\n- Email is passed as `login_hint` through the OAuth flow\n- Old handle-based login still works at the root (SignedInProvider + LoginDialog unchanged)\n- OAuth callback handles both flows identically\n- No new environment variables required (uses existing `NEXT_PUBLIC_PDS_URL`)","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:11:29.861164+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.406478+08:00","closed_at":"2026-02-18T15:50:27.406482+08:00","labels":["scope:medium"]}
{"id":"hypercerts-2bf.1","title":"Create /login page with email input form","description":"## Files\n- app/login/page.tsx (create)\n- components/email-login-form.tsx (create)\n\n## What to do\nCreate a new Next.js App Router page at `/login` with an email-first login form. This page exists alongside the old handle-based login (which remains at the root via `SignedInProvider`).\n\n### Page: `app/login/page.tsx`\n- Server component that checks for an existing session (same pattern as `SignedInProvider`)\n- If already authenticated, redirect to `/` using `redirect()` from `next/navigation`\n- If not authenticated, render the `EmailLoginForm` component centered on screen\n- Include the `Navbar` with `isSignedIn={false}` (same pattern as SignedInProvider's unauthenticated state)\n\n### Component: `components/email-login-form.tsx`\n- Client component (`'use client'`)\n- Single form with one email input field and a submit button\n- Heading: 'Sign In' (font: Syne, bold)\n- Subheading: 'Enter your email to continue' (font: Outfit, muted)\n- Email input: standard `\u003cInput\u003e` from `components/ui/input.tsx`, type='email', placeholder='you@example.com', required\n- Submit button: 'Continue' text, full width, uses `bg-create-accent` styling (same as existing LoginDialog)\n- Loading state: show `\u003cSpinner\u003e` in button when submitting, disable button\n- On submit: call `useEmailLoginMutation` (created in a separate task) which POSTs to `/api/auth/email-login`\n- Error state: show error message below the form if mutation fails (use `text-destructive` class)\n- Match the visual style of the existing `LoginDialog` component (same fonts, colors, spacing, `animate-fade-in-up` animations)\n\n### Layout\n- The form should be centered vertically and horizontally, max-width `sm` (same as LoginDialog)\n- Wrap in a `\u003cdiv className='flex grow flex-col items-center justify-center'\u003e` (same pattern as SignedInProvider)\n\n## Don't\n- Don't modify `SignedInProvider`, `LoginDialog`, or any existing auth components\n- Don't add any new environment variables\n- Don't implement the API route or mutation hook (those are separate tasks)\n- Don't add OTP verification UI (that's handled by the PDS sidecar, not the scaffold)\n- Don't add a layout.tsx for /login — use the root layout","acceptance_criteria":"1. Visiting /login when not authenticated shows a centered form with email input and 'Continue' button\n2. Visiting /login when authenticated redirects to /\n3. The form validates email format (HTML5 type=email)\n4. The form shows a loading spinner when submitting\n5. The existing LoginDialog at the root route still works unchanged\n6. No TypeScript errors (npx tsc --noEmit passes)\n7. The page renders without errors in the browser","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-17T18:12:49.415659+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:39:42.193719+08:00","closed_at":"2026-02-17T18:39:42.193719+08:00","close_reason":"062b00d Create /login page with email input form","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-2bf.1","depends_on_id":"hypercerts-2bf","type":"parent-child","created_at":"2026-02-17T18:12:49.416938+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-2bf.1","depends_on_id":"hypercerts-2bf.2","type":"blocks","created_at":"2026-02-17T18:13:31.992691+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-2bf.2","title":"Create useEmailLoginMutation hook and API client function","description":"## Files\n- queries/auth/use-email-login-mutation.ts (create)\n- queries/auth/index.ts (modify)\n- lib/api/auth.ts (modify)\n- lib/api/types.ts (modify)\n\n## What to do\nCreate the client-side mutation hook and API function for the email-first login flow. This follows the exact same pattern as the existing `useLoginMutation` / `login()` but accepts an email instead of a handle.\n\n### `lib/api/types.ts` — Add types\nAdd alongside existing types:\n```typescript\nexport interface EmailLoginRequest {\n  email: string;\n}\n\nexport interface EmailLoginResponse {\n  authUrl: string;\n}\n```\n\n### `lib/api/auth.ts` — Add API function\nAdd a new function alongside the existing `login()`:\n```typescript\nexport async function emailLogin(email: string): Promise\u003cEmailLoginResponse\u003e {\n  return apiClient.post\u003cEmailLoginResponse\u003e('/api/auth/email-login', { email });\n}\n```\nThe existing `login()` and `logout()` functions must remain unchanged.\n\n### `queries/auth/use-email-login-mutation.ts` — Create mutation hook\nFollow the exact pattern of `use-login-mutation.ts`:\n- Import `emailLogin` from `@/lib/api/auth`\n- Use `useMutation` from `@tanstack/react-query`\n- `mutationFn`: calls `emailLogin(email)`\n- `onSuccess`: calls `router.push(data.authUrl)` to redirect to the PDS/sidecar authorization page (same as useLoginMutation)\n- `onError`: log error to console (same as useLoginMutation)\n- Export as `useEmailLoginMutation`\n\n### `queries/auth/index.ts` — Re-export\nAdd `export { useEmailLoginMutation } from './use-email-login-mutation'` alongside existing exports.\n\n## Don't\n- Don't modify the existing `useLoginMutation` or `login()` function\n- Don't implement the server-side API route (that's a separate task)\n- Don't add error handling beyond what the existing hooks do","acceptance_criteria":"1. `useEmailLoginMutation` is exported from `queries/auth/index.ts`\n2. Calling `mutation.mutate('user@example.com')` POSTs to `/api/auth/email-login` with `{ email: 'user@example.com' }`\n3. On success, the browser navigates to the returned `authUrl`\n4. The existing `useLoginMutation` and `useLogoutMutation` still work unchanged\n5. No TypeScript errors (npx tsc --noEmit passes)","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":20,"created_at":"2026-02-17T18:13:03.438072+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:35:38.217518+08:00","closed_at":"2026-02-17T18:35:38.217518+08:00","close_reason":"0ce88fd Add useEmailLoginMutation hook and emailLogin API function","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-2bf.2","depends_on_id":"hypercerts-2bf","type":"parent-child","created_at":"2026-02-17T18:13:03.43898+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-2bf.3","title":"Create /api/auth/email-login API route with login_hint passthrough","description":"## Files\n- app/api/auth/email-login/route.ts (create)\n\n## What to do\nCreate a new Next.js API route that accepts an email address and initiates the ATProto OAuth flow with the email passed as `login_hint`. This is the server-side counterpart to the `useEmailLoginMutation` hook.\n\n### Route: `POST /api/auth/email-login`\n\n**Request body:**\n```json\n{ \"email\": \"user@example.com\" }\n```\n\n**Logic:**\n1. Parse the request body and extract `email`\n2. Validate that `email` is present and is a valid email format (basic regex or just check for `@`)\n3. Call `sdk.authorize()` to initiate the OAuth flow. The key difference from the existing `/api/auth/login` route is:\n   - Pass the **PDS URL** (from `config.pdsUrl`, i.e., `process.env.NEXT_PUBLIC_PDS_URL`) as the first argument — NOT the email. The PDS URL tells the SDK which authorization server to use.\n   - Pass the email as `login_hint` in the authorization URL. The `@atproto/oauth-client-node` SDK's `authorize()` method may not directly support `login_hint` as a parameter. If it doesn't, you need to:\n     a. First try: check if `sdk.authorize(pdsUrl, { login_hint: email })` works (check the SDK types)\n     b. If not: get the authorization URL from `sdk.authorize(pdsUrl)` and append `\u0026login_hint=${encodeURIComponent(email)}` to the URL before returning it\n4. Return `{ authUrl: \u003cthe authorization URL\u003e }` as JSON\n\n**Response (success):**\n```json\n{ \"authUrl\": \"https://pds.certs.network/oauth/authorize?...\u0026login_hint=user%40example.com\" }\n```\n\n**Response (error):**\n```json\n{ \"error\": \"Email is required\" }  // 400\n{ \"error\": \"Failed to initiate login process\" }  // 500\n```\n\n### Important: Understanding `sdk.authorize()`\nThe existing login route calls `sdk.authorize(handle)` where `handle` is a user's ATProto handle (e.g., `alice.bsky.social`). The SDK resolves the handle to find the user's PDS/authorization server.\n\nFor email login, we don't have a handle — we have an email. We know the PDS URL (`NEXT_PUBLIC_PDS_URL`), so we pass that directly. The SDK will use it to find the authorization server. The `login_hint` parameter is an OAuth standard parameter that the authorization server (our sidecar) will use to pre-fill the email and send the OTP immediately.\n\n### Reference: Existing login route\n```typescript\n// app/api/auth/login/route.ts (DO NOT MODIFY)\nimport sdk from '@/lib/hypercerts-sdk';\nexport async function POST(request: Request) {\n  const body = await request.json();\n  const handle = body.handle;\n  try {\n    const authUrl = await sdk.authorize(handle);\n    return NextResponse.json({ authUrl });\n  } catch (e) {\n    console.error('Failed to initiate login process', e);\n    return Response.json({ error: 'Failed to initiate login process' }, { status: 500 });\n  }\n}\n```\n\n## Don't\n- Don't modify the existing `/api/auth/login` route\n- Don't modify the existing `/api/auth/callback` route (the callback is the same for both flows)\n- Don't add new environment variables\n- Don't try to resolve email→handle or email→DID on the scaffold side (that's the sidecar's job)","acceptance_criteria":"1. POST /api/auth/email-login with `{ email: 'user@example.com' }` returns `{ authUrl: '...' }` with status 200\n2. The returned authUrl contains `login_hint=user%40example.com` (or equivalent encoding)\n3. POST /api/auth/email-login with empty body returns 400 with error message\n4. POST /api/auth/email-login with `{ email: '' }` returns 400 with error message\n5. The existing /api/auth/login route still works unchanged\n6. The existing /api/auth/callback route handles callbacks from both flows (no changes needed)\n7. No TypeScript errors (npx tsc --noEmit passes)","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-17T18:13:26.675271+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:35:41.084402+08:00","closed_at":"2026-02-17T18:35:41.084402+08:00","close_reason":"c42b281 Create /api/auth/email-login route with login_hint passthrough","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-2bf.3","depends_on_id":"hypercerts-2bf","type":"parent-child","created_at":"2026-02-17T18:13:26.675986+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-67k","title":"Epic: End-to-End Integration Testing","description":"## Goal\nVerify the complete email-first passwordless auth flow works end-to-end, from the scaffold app through the sidecar to the PDS and back. Cover both new user sign-up and existing user sign-in paths.\n\n## Context\nWe have three components that need to work together:\n1. **Scaffold app** (Next.js) — /login page with email input, /api/auth/email-login route, /api/auth/callback route\n2. **Sidecar auth service** (Express) — /oauth/authorize, /auth/send-code, /auth/verify-code\n3. **PDS** (stock @atproto/pds) — OAuth PAR, magic-callback, token exchange, account creation\n\nThe local dev setup exists (Epic: Local Test PDS — hypercerts-mhp) with:\n- PDS at http://localhost:2583\n- Sidecar at http://localhost:2584\n- MailHog at http://localhost:8025 (fake SMTP)\n- Scaffold at http://127.0.0.1:3000\n\nBut the full flow has never been tested end-to-end. Task hypercerts-mhp.2 (verify full OTP flow) is still in progress.\n\n## Test Scenarios\n1. **New user sign-up**: Enter email → receive OTP → enter code → account created → session established → redirected to app\n2. **Existing user sign-in**: Enter email → receive OTP → enter code → session established → redirected to app\n3. **Invalid OTP**: Enter wrong code → error shown → can retry\n4. **Expired OTP**: Wait 15 minutes → code rejected → can request new code\n5. **Rate limiting**: Send too many OTP requests → rate limited → Retry-After header\n6. **OAuth consent**: User sees consent screen → approves → tokens issued\n7. **Session persistence**: After login, refresh page → still logged in\n8. **Logout**: Click logout → session cleared → redirected to login\n\n## Hard Constraints\n- Tests must run against the local dev stack (no production PDS)\n- Use MailHog to capture OTP emails (no real email sending)\n- Tests should be automated where possible (Playwright or similar)\n- Manual test checklist for flows that can't be easily automated\n\n## Success Looks Like\n- All 8 test scenarios pass\n- Automated E2E test suite exists (at least for scenarios 1-3)\n- Manual test checklist documented for remaining scenarios\n- Known issues documented with workarounds","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:10:31.581006+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.347542+08:00","closed_at":"2026-02-18T15:44:51.347544+08:00","labels":["scope:medium"]}
{"id":"hypercerts-67k.1","title":"Create E2E test suite for email-first auth flow using Playwright","description":"## Files\n- e2e/auth-flow.spec.ts (create)\n- e2e/helpers/mailhog.ts (create)\n- e2e/playwright.config.ts (create)\n- package.json (modify — add playwright dev dependency)\n\n## What to do\nCreate a Playwright E2E test suite that tests the complete email→OTP→session flow against the local dev stack.\n\n### Prerequisites\nThe local dev stack must be running:\n- Scaffold at http://127.0.0.1:3000\n- PDS at http://localhost:2583\n- Sidecar at http://localhost:2584\n- MailHog at http://localhost:8025\n\n### MailHog helper\n```typescript\n// e2e/helpers/mailhog.ts\nexport async function getLatestOTP(email: string): Promise\u003cstring\u003e {\n  // 1. Poll MailHog API at http://localhost:8025/api/v2/search?kind=to\u0026query=\u003cemail\u003e\n  // 2. Parse the latest email body to extract the 8-digit OTP code\n  // 3. Return the code\n  // Retry up to 10 times with 1s delay (email delivery can be slow)\n}\n\nexport async function clearMailbox(): Promise\u003cvoid\u003e {\n  // DELETE http://localhost:8025/api/v1/messages\n}\n```\n\n### Test scenarios\n```typescript\ntest.describe('Email-first auth flow', () =\u003e {\n  test.beforeEach(async () =\u003e {\n    await clearMailbox()\n  })\n\n  test('new user can sign up with email and OTP', async ({ page }) =\u003e {\n    // 1. Navigate to http://127.0.0.1:3000/login\n    // 2. Enter a unique email (e.g., test-{timestamp}@example.com)\n    // 3. Click Continue\n    // 4. Wait for redirect to sidecar OTP page\n    // 5. Get OTP from MailHog\n    // 6. Enter OTP code\n    // 7. Wait for redirect back to scaffold\n    // 8. Verify user is logged in (check for user avatar or DID display)\n  })\n\n  test('existing user can sign in with email and OTP', async ({ page }) =\u003e {\n    // Same as above but with an email that already has an account\n    // (create account first, then test sign-in)\n  })\n\n  test('invalid OTP shows error and allows retry', async ({ page }) =\u003e {\n    // 1. Go through email entry\n    // 2. Enter wrong OTP code\n    // 3. Verify error message is shown\n    // 4. Enter correct OTP code\n    // 5. Verify login succeeds\n  })\n})\n```\n\n### Playwright config\n- baseURL: http://127.0.0.1:3000\n- timeout: 30000 (OTP email delivery can be slow)\n- retries: 0 (tests should be deterministic)\n- reporter: html\n\n## Don't\n- Start the dev stack from within the tests (assume it's already running)\n- Use real email addresses\n- Hard-code OTP codes (always extract from MailHog)\n- Skip cleanup between tests (clear MailHog mailbox)","acceptance_criteria":"1. Playwright config exists at e2e/playwright.config.ts. 2. MailHog helper can extract OTP codes from emails. 3. At least 3 test scenarios are implemented (sign-up, sign-in, invalid OTP). 4. Tests pass when run against the local dev stack. 5. package.json includes @playwright/test as devDependency.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:10:50.702736+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.438125+08:00","closed_at":"2026-02-18T15:44:51.438128+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-67k.1","depends_on_id":"hypercerts-67k","type":"parent-child","created_at":"2026-02-18T14:10:50.703968+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-67k.1","depends_on_id":"hypercerts-mhp","type":"blocks","created_at":"2026-02-18T14:11:52.624363+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-67k.1","depends_on_id":"hypercerts-hpb.1","type":"blocks","created_at":"2026-02-18T14:11:52.733178+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-67k.2","title":"Create manual test checklist for auth edge cases and security scenarios","description":"## Files\n- docs/manual-test-checklist.md (create)\n\n## What to do\nCreate a comprehensive manual test checklist for auth scenarios that are difficult to automate.\n\n### Checklist format\nEach test case should have:\n- Test ID (e.g., AUTH-001)\n- Description\n- Preconditions\n- Steps (numbered)\n- Expected result\n- Pass/Fail checkbox\n- Notes field\n\n### Test cases to include\n\n**Rate Limiting (AUTH-001 to AUTH-003)**\n- AUTH-001: Send 4 OTP requests for same email within 15 minutes → 4th should be rate limited\n- AUTH-002: Send 6 OTP requests for same email within 1 hour → 6th should be rate limited\n- AUTH-003: Send 11 OTP requests from same IP within 15 minutes → 11th should be rate limited\n\n**OTP Security (AUTH-004 to AUTH-007)**\n- AUTH-004: Enter wrong OTP 5 times → code invalidated, must request new one\n- AUTH-005: Wait 16 minutes after receiving OTP → code expired\n- AUTH-006: Use same OTP code twice → second use rejected (replay protection)\n- AUTH-007: Request new OTP → old OTP invalidated\n\n**Session Management (AUTH-008 to AUTH-011)**\n- AUTH-008: Login → close browser → reopen → still logged in (session persists in Redis)\n- AUTH-009: Login → click logout → try to access protected page → redirected to login\n- AUTH-010: Login on two different browsers → both sessions active\n- AUTH-011: Clear cookies → session lost → must re-authenticate\n\n**Error Handling (AUTH-012 to AUTH-014)**\n- AUTH-012: Enter invalid email format → validation error shown\n- AUTH-013: PDS is down → graceful error message (not stack trace)\n- AUTH-014: Sidecar is down → graceful error message\n\n**OAuth (AUTH-015 to AUTH-017)**\n- AUTH-015: Deny OAuth consent → redirected back to app without session\n- AUTH-016: Login from two different Certified apps → each gets independent session\n- AUTH-017: Revoke OAuth token → app loses access\n\n**Handle-based fallback (AUTH-018)**\n- AUTH-018: Enter ATProto handle instead of email → handle-based login works\n\n## Don't\n- Include automated test cases (those are in the Playwright suite)\n- Skip the rate limiting tests (they're critical for production)\n- Assume the tester knows ATProto internals (explain each step clearly)","acceptance_criteria":"1. docs/manual-test-checklist.md exists with at least 18 test cases. 2. Each test case has ID, description, preconditions, steps, expected result, and pass/fail checkbox. 3. Rate limiting, OTP security, session management, error handling, and OAuth sections are all covered. 4. A tester unfamiliar with the system can follow the checklist.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:11:08.621568+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.528484+08:00","closed_at":"2026-02-18T15:44:51.528488+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-67k.2","depends_on_id":"hypercerts-67k","type":"parent-child","created_at":"2026-02-18T14:11:08.622733+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-6oz","title":"Fix: useEmailLoginMutation missing toast.error on failure vs useLoginMutation pattern (from hypercerts-2bf.2)","description":"Review of hypercerts-2bf.2 found: useEmailLoginMutation onError only calls console.error, while the existing useLoginMutation (the pattern it was asked to follow) also calls toast.error('An error occurred while logging in.'). The spec says 'follow the exact pattern of use-login-mutation.ts'. The email-login form does show an inline error via emailLoginMutation.isError, but the toast notification is missing. This is a minor UX inconsistency. Evidence: queries/auth/use-login-mutation.ts line 18 calls toast.error; queries/auth/use-email-login-mutation.ts line 16 only calls console.error. Fix: add toast.error call in onError, or explicitly document the intentional deviation.","status":"closed","priority":3,"issue_type":"bug","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:53:27.29766+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:27.992137+08:00","closed_at":"2026-02-17T18:56:27.992141+08:00","dependencies":[{"issue_id":"hypercerts-6oz","depends_on_id":"hypercerts-2bf.2","type":"discovered-from","created_at":"2026-02-17T18:53:27.432906+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-8mu","title":"Epic: OTP Service Layer Hardening \u0026 Credential Management","description":"## Goal\nHarden the existing OTP service layer in packages/pds-sidecar/ to be production-ready. Add encrypted auto-generated password storage, improve OTP security, and ensure the service can handle the Ma Earth grants round traffic.\n\n## Context\nThe pds-sidecar already has a working OTP service (packages/pds-sidecar/packages/shared/dist/otp-service.js) with:\n- 8-digit OTP generation with SHA-256 hashing\n- 15-minute expiry, 5 max attempts\n- Timing-safe comparison\n- SQLite storage\n\nWhat's MISSING for production (per the architecture doc):\n1. **Encrypted password storage**: Auto-generated passwords for PDS accounts are stored but not encrypted at rest. Need AES-256-GCM encryption with key from env var or secrets manager.\n2. **OTP replay protection**: Current implementation marks codes as used, but needs explicit single-use enforcement and cleanup.\n3. **Password rotation**: No mechanism to rotate auto-generated passwords if compromised.\n4. **Audit logging**: No structured logging of auth events (OTP sent, verified, failed, account created).\n5. **OTP code cleanup cron**: cleanupExpired() exists but isn't called on a schedule.\n\n## Architecture\nThe sidecar is a monorepo at packages/pds-sidecar/ with three sub-packages:\n- packages/shared/ — DB, OTP service, rate limiter, HMAC signer, mailer (source in TypeScript, compiled to dist/)\n- packages/auth-service/ — Express auth service\n- packages/pds-core/ — PDS wrapper\n\nAll source code needs to be written in TypeScript. The compiled dist/ files exist but source .ts files may need to be created if they don't exist (check the beads/plan-passwordless-login branch for source).\n\n## Hard Constraints\n- No PDS fork — all logic in the sidecar\n- Stock @atproto/pds as npm dependency only\n- SQLite for sidecar data (accounts, OTP tokens)\n- Must work with the existing HMAC callback flow\n\n## Success Looks Like\n- Auto-generated passwords encrypted at rest with AES-256-GCM\n- OTP cleanup runs on a configurable interval\n- Structured audit logging for all auth events\n- Password rotation endpoint exists\n- All changes have unit tests","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:03:07.91474+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.840312+08:00","closed_at":"2026-02-18T15:44:48.840315+08:00","labels":["scope:medium"]}
{"id":"hypercerts-8mu.1","title":"Add AES-256-GCM encrypted storage for auto-generated PDS passwords","description":"## Files\n- packages/pds-sidecar/packages/shared/src/credential-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/credential-store.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add credentials table migration)\n\n## What to do\nCreate a CredentialStore class that encrypts/decrypts auto-generated PDS passwords using AES-256-GCM.\n\n### CredentialStore class\n```typescript\nexport class CredentialStore {\n  constructor(db: BetterSqlite3.Database, encryptionKey: Buffer) // 32-byte key from env\n  encrypt(plaintext: string): { ciphertext: string, iv: string, tag: string }\n  decrypt(ciphertext: string, iv: string, tag: string): string\n  storePassword(did: string, password: string): void  // encrypts then stores\n  getPassword(did: string): string | null  // retrieves and decrypts\n  rotatePassword(did: string, newPassword: string): void  // re-encrypts with new password\n  deletePassword(did: string): void\n}\n```\n\n### DB migration\nAdd a `credentials` table to the SQLite schema:\n```sql\nCREATE TABLE IF NOT EXISTS credentials (\n  did TEXT PRIMARY KEY,\n  encrypted_password TEXT NOT NULL,\n  iv TEXT NOT NULL,\n  auth_tag TEXT NOT NULL,\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### Encryption details\n- Algorithm: AES-256-GCM (node:crypto)\n- Key: 32-byte Buffer from `CREDENTIAL_ENCRYPTION_KEY` env var (hex-encoded)\n- IV: 12 random bytes per encryption (crypto.randomBytes(12))\n- Auth tag: 16 bytes (default for GCM)\n- Store ciphertext, IV, and auth tag as hex strings in SQLite\n\n### Tests\n- Encrypt then decrypt returns original plaintext\n- Different IVs produce different ciphertexts for same plaintext\n- Tampered ciphertext throws on decrypt\n- Tampered auth tag throws on decrypt\n- storePassword + getPassword roundtrip works\n- rotatePassword updates the stored value\n- getPassword for non-existent DID returns null\n\n## Don't\n- Use any encryption library other than node:crypto\n- Store the encryption key in the database\n- Use CBC mode (must be GCM for authenticated encryption)\n- Use a fixed IV (must be random per encryption)","acceptance_criteria":"1. CredentialStore class exists at packages/pds-sidecar/packages/shared/src/credential-store.ts. 2. All 7 test cases pass. 3. Encryption uses AES-256-GCM with random 12-byte IV. 4. credentials table is created in DB migration. 5. No plaintext passwords stored in SQLite (verified by inspecting DB after storePassword call in tests).","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T14:03:23.859328+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.937724+08:00","closed_at":"2026-02-18T15:44:48.937728+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-8mu.1","depends_on_id":"hypercerts-8mu","type":"parent-child","created_at":"2026-02-18T14:03:23.860319+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-8mu.2","title":"Add structured audit logging for all auth events","description":"## Files\n- packages/pds-sidecar/packages/shared/src/audit-logger.ts (create)\n- packages/pds-sidecar/packages/shared/src/audit-logger.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add audit_log table)\n\n## What to do\nCreate an AuditLogger class that records all auth events to SQLite with structured JSON.\n\n### AuditLogger class\n```typescript\nexport enum AuthEvent {\n  OTP_REQUESTED = 'otp_requested',\n  OTP_SENT = 'otp_sent',\n  OTP_SEND_FAILED = 'otp_send_failed',\n  OTP_VERIFIED = 'otp_verified',\n  OTP_FAILED = 'otp_failed',\n  OTP_EXPIRED = 'otp_expired',\n  OTP_MAX_ATTEMPTS = 'otp_max_attempts',\n  ACCOUNT_CREATED = 'account_created',\n  ACCOUNT_LOGIN = 'account_login',\n  RATE_LIMITED = 'rate_limited',\n  CALLBACK_SIGNED = 'callback_signed',\n  CALLBACK_VERIFIED = 'callback_verified',\n  CALLBACK_REJECTED = 'callback_rejected',\n}\n\nexport class AuditLogger {\n  constructor(db: BetterSqlite3.Database)\n  log(event: AuthEvent, metadata: Record\u003cstring, unknown\u003e): void\n  query(filters: { event?: AuthEvent, email?: string, ip?: string, since?: Date, limit?: number }): AuditEntry[]\n}\n```\n\n### DB table\n```sql\nCREATE TABLE IF NOT EXISTS audit_log (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  event TEXT NOT NULL,\n  email TEXT,\n  ip TEXT,\n  metadata TEXT, -- JSON string\n  created_at TEXT DEFAULT (datetime('now'))\n);\nCREATE INDEX IF NOT EXISTS idx_audit_event ON audit_log(event);\nCREATE INDEX IF NOT EXISTS idx_audit_email ON audit_log(email);\nCREATE INDEX IF NOT EXISTS idx_audit_created ON audit_log(created_at);\n```\n\n### Metadata conventions\n- Always include `ip` when available\n- Always include `email` (masked in logs: a***@example.com)\n- Include `did` for account events\n- Include `reason` for failures\n- Include `requestUri` for OAuth flow events\n\n## Don't\n- Log plaintext passwords or OTP codes (log hashed versions or omit)\n- Log full email addresses in the metadata JSON (mask them)\n- Use console.log — use the existing pino logger from packages/shared/dist/logger.js\n- Block the auth flow on logging failures (fire-and-forget)","acceptance_criteria":"1. AuditLogger class exists with all 13 AuthEvent types. 2. log() writes to audit_log table. 3. query() supports filtering by event, email, ip, since, limit. 4. No plaintext passwords or OTP codes appear in any log entry. 5. Email addresses are masked in metadata. 6. Tests verify log + query roundtrip for at least 3 different event types.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T14:03:39.341591+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.038973+08:00","closed_at":"2026-02-18T15:44:49.038976+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-8mu.2","depends_on_id":"hypercerts-8mu","type":"parent-child","created_at":"2026-02-18T14:03:39.343034+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-8mu.3","title":"Add OTP cleanup scheduler and password rotation endpoint","description":"## Files\n- packages/pds-sidecar/packages/shared/src/cleanup-scheduler.ts (create)\n- packages/pds-sidecar/packages/shared/src/cleanup-scheduler.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/admin.ts (create)\n\n## What to do\n\n### 1. Cleanup Scheduler\nCreate a CleanupScheduler that periodically purges expired OTP tokens and old audit logs.\n\n```typescript\nexport class CleanupScheduler {\n  constructor(otpService: OTPService, auditLogger: AuditLogger, intervalMs?: number)\n  start(): void  // starts setInterval\n  stop(): void   // clears interval\n  runOnce(): Promise\u003c{ otpTokensCleaned: number, auditLogsCleaned: number }\u003e\n}\n```\n\n- Default interval: 1 hour (3600000ms)\n- OTP cleanup: delete expired + used tokens (already implemented in OTPService.cleanupExpired())\n- Audit log cleanup: delete entries older than 90 days\n- Log cleanup results via pino logger\n\n### 2. Admin Password Rotation Endpoint\nAdd a POST /admin/rotate-password endpoint to the auth service:\n\n```\nPOST /admin/rotate-password\nAuthorization: Bearer \u003cADMIN_API_KEY\u003e\nBody: { \"did\": \"did:plc:xxx\" }\nResponse: { \"success\": true, \"did\": \"did:plc:xxx\" }\n```\n\nThis endpoint:\n1. Generates a new random 128-char hex password\n2. Calls `com.atproto.server.resetPassword` on the PDS (or uses internal API) to update the PDS account password\n3. Updates the encrypted password in CredentialStore\n4. Logs an ACCOUNT_PASSWORD_ROTATED audit event\n\nProtected by a static API key from `ADMIN_API_KEY` env var (timing-safe comparison).\n\n## Don't\n- Expose the admin endpoint without authentication\n- Use setTimeout recursion (use setInterval)\n- Delete audit logs younger than 90 days\n- Block the main event loop during cleanup","acceptance_criteria":"1. CleanupScheduler starts and stops without errors. 2. runOnce() returns counts of cleaned items. 3. POST /admin/rotate-password returns 200 with valid admin key and 401 without. 4. Password rotation updates CredentialStore. 5. Tests cover: scheduler start/stop, cleanup counts, admin auth rejection, successful rotation.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:03:55.292488+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.131397+08:00","closed_at":"2026-02-18T15:44:49.1314+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-8mu.3","depends_on_id":"hypercerts-8mu","type":"parent-child","created_at":"2026-02-18T14:03:55.293729+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-8mu.3","depends_on_id":"hypercerts-8mu.1","type":"blocks","created_at":"2026-02-18T14:03:55.295217+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-8mu.3","depends_on_id":"hypercerts-8mu.2","type":"blocks","created_at":"2026-02-18T14:03:55.296224+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-97q","title":"Epic: Email-First Passwordless Login UI","description":"## Goal\nReplace the handle-centric login UX with an email-first, passwordless experience that:\n- Collects email (not handle) as the primary identifier\n- Works seamlessly when the PDS supports email OTP (Phase 2, separate repo)\n- Degrades gracefully to handle-based OAuth when the PDS still requires passwords\n- Moves auth from inline dialogs/popovers to dedicated /auth/* pages\n- Supports the cross-app Certified identity model (email as the user-facing identity)\n\n## Context\nThe product spec requires email-first passwordless login for Ma Earth's grants round and the broader Certified ecosystem. The PDS at pds-eu-west4.test.certified.app will be modified separately (see holkexyz/atproto magic-pds for reference implementation). This epic covers only the scaffold-side changes — building the UI, adapting the OAuth flow entry point, and restructuring auth state management.\n\n## Scope\n- IN: New /auth/* pages (signin, verify), auth layout, entryway client, modified login API route, refactored SignedInProvider, updated navbar, cleanup of old login components, config changes\n- OUT: PDS modifications, entryway service, email sending infrastructure, OTP generation/validation (all PDS-side), TOTP/passkey support (future epic)\n\n## Key Constraints\n- The ATProto OAuth flow (PKCE + DPoP) MUST remain functional — it is the only way to get PDS write tokens\n- Redis session/state stores MUST NOT be removed — the ATProto SDK requires them\n- The app/client-metadata.json and app/jwks.json routes MUST NOT be deleted — they are required for ATProto OAuth even with email-first UI\n- Feature flag (NEXT_PUBLIC_ENTRYWAY_URL) controls whether email resolution is attempted; when absent, falls back to handle input\n- All new pages use existing shadcn/ui components and Tailwind CSS v4\n- No new runtime dependencies except the entryway HTTP client (plain fetch)","status":"tombstone","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T15:38:46.019886+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T15:39:18.298716+08:00","labels":["scope:medium"],"deleted_at":"2026-02-17T15:39:18.298716+08:00","deleted_by":"daemon","delete_reason":"delete","original_type":"epic"}
{"id":"hypercerts-ay4","title":"Epic: ATProto/Bluesky Ecosystem Interop","description":"## Goal\nAdd a 'Sign in with ATProto/Bluesky' button alongside the email-first flow, so users with existing Bluesky or ATProto identities can log in using their handle. This provides ecosystem interoperability without compromising the email-first UX for new users.\n\n## Context\nThe architecture doc's execution plan for Day 3 includes: 'Add Sign in with ATProto/Bluesky button for ecosystem interop.'\n\nThe scaffold already has handle-based login (LoginDialog component at components/login-dialog.tsx, /api/auth/login route). This epic adds a clean UX that presents both options:\n1. Primary: 'Sign in with Certified' (email-first, for new/Certified users)\n2. Secondary: 'Sign in with Bluesky/ATProto' (handle-based, for existing ATProto users)\n\nWhen a user signs in with their Bluesky handle, the standard ATProto OAuth flow resolves their handle → DID → PDS and authenticates against their own PDS (e.g., bsky.social). They get a session in our app but their data lives on their own PDS.\n\n## What Has to Be Built\n1. A dual-option login page that presents both auth methods\n2. Handle-based login that resolves to the user's own PDS (not certified.app)\n3. Clear UX distinction between Certified accounts and external ATProto accounts\n4. Session handling that works for both account types\n\n## Hard Constraints\n- Email-first MUST be the primary/default option (larger button, top position)\n- Handle-based login MUST NOT require the user to know their PDS URL\n- Both login methods use the same OAuth callback (/api/auth/callback)\n- External ATProto users don't get OTP — they authenticate on their own PDS\n\n## Success Looks Like\n- Login page shows both options clearly\n- Bluesky users can log in with their handle (e.g., alice.bsky.social)\n- Certified users can log in with email\n- Both get valid sessions in the scaffold app\n- The UX makes it obvious which option to choose","status":"closed","priority":2,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:11:26.060217+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.628769+08:00","closed_at":"2026-02-18T15:44:51.628787+08:00","labels":["scope:small"]}
{"id":"hypercerts-ay4.1","title":"Update /login page with dual-option UI: email-first + ATProto handle fallback","description":"## Files\n- app/login/page.tsx (modify)\n- components/handle-login-section.tsx (create)\n\n## What to do\nUpdate the /login page to present two auth options with email-first as the primary.\n\n### Layout\n```\n┌─────────────────────────────────┐\n│     Sign in to Certified        │\n│                                 │\n│  ┌───────────────────────────┐  │\n│  │  📧 Email address         │  │\n│  │  [alice@example.com    ]  │  │\n│  │  [    Continue →         ]│  │\n│  └───────────────────────────┘  │\n│                                 │\n│  ─── or ────────────────────── │\n│                                 │\n│  Already have a Bluesky or     │\n│  ATProto account?              │\n│  ┌───────────────────────────┐  │\n│  │  🦋 Handle                │  │\n│  │  [alice.bsky.social    ]  │  │\n│  │  [  Sign in with handle ]│  │\n│  └───────────────────────────┘  │\n│                                 │\n└─────────────────────────────────┘\n```\n\n### Behavior\n1. Email section (top, primary):\n   - Uses the existing useEmailLoginMutation hook\n   - Calls /api/auth/email-login with the email\n   - This is the default/highlighted option\n2. Handle section (bottom, secondary):\n   - Uses the existing useLoginMutation hook (from queries/mutations/)\n   - Calls /api/auth/login with the handle\n   - Styled as secondary/muted to indicate it's the alternative\n3. Both sections share the same loading state (disable both while either is in progress)\n4. Error handling: show toast for both (using sonner)\n\n### HandleLoginSection component\n```typescript\nexport function HandleLoginSection(): JSX.Element\n// Renders handle input + submit button\n// Uses existing useLoginMutation\n// Styled as secondary option\n```\n\n### Styling\n- Email section: full-width card with primary button styling\n- Divider: 'or' text with horizontal lines on each side\n- Handle section: smaller, muted styling (outline button, lighter text)\n- Use existing shadcn components (Card, Input, Button, Separator)\n\n## Don't\n- Remove the email-first flow\n- Make the handle option equally prominent (email MUST be primary)\n- Create a new auth flow for handles (reuse existing useLoginMutation)\n- Break the existing /api/auth/login route\n- Add new dependencies","acceptance_criteria":"1. /login page shows email input as primary option. 2. Handle input shown below a divider as secondary option. 3. Email login uses useEmailLoginMutation. 4. Handle login uses existing useLoginMutation. 5. Both options disable during loading. 6. pnpm build succeeds. 7. Email section is visually more prominent than handle section.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T14:11:46.384929+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.714627+08:00","closed_at":"2026-02-18T15:44:51.71463+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-ay4.1","depends_on_id":"hypercerts-ay4","type":"parent-child","created_at":"2026-02-18T14:11:46.386522+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-ay4.1","depends_on_id":"hypercerts-hpb.1","type":"blocks","created_at":"2026-02-18T14:11:46.388024+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-dpt","title":"Epic: Org Repo Management with Server-Side Signing","description":"## Goal\nEnable organizations to have their own ATProto repos on the PDS, with signing keys held server-side. Our backend mediates all writes to org repos based on RBAC permissions.\n\n## Context\nIn ATProto, every repo has exactly one signing key. For personal repos, the user holds the key. For org repos, our backend holds the key and writes on behalf of authorized users.\n\nThe architecture doc references the PdsAdminService + PdsRecordService pattern from MIGRATION.md. This pattern:\n1. Creates a PDS account for the org (with a server-held signing key)\n2. Stores the org's credentials encrypted (using CredentialStore from Epic: OTP Hardening)\n3. Provides an API for authorized users to create/update/delete records in the org's repo\n4. The backend authenticates to the PDS as the org account and performs the write\n\n### How it works\n```\nUser (authenticated) → Scaffold API → Check RBAC (OrgStore) → PdsRecordService → PDS (as org account)\n```\n\nThe PdsRecordService uses the org's stored credentials to authenticate to the PDS via `com.atproto.server.createSession` and then calls XRPC methods (com.atproto.repo.createRecord, etc.) on behalf of the org.\n\n## Hard Constraints\n- Org signing keys MUST be encrypted at rest (use CredentialStore)\n- All writes MUST check RBAC permissions first\n- The PDS sees org writes as coming from the org's own account (not the user's)\n- Must work with stock @atproto/pds — no fork\n- Org accounts are created via com.atproto.server.createAccount (same as user accounts)\n\n## Dependencies\n- Epic: OTP Hardening (CredentialStore for encrypted password storage)\n- Epic: Org Membership \u0026 RBAC (OrgStore for permission checks)\n\n## Success Looks Like\n- Org PDS accounts can be created programmatically\n- Org credentials stored encrypted\n- PdsRecordService can create/read/update/delete records in org repos\n- All writes are RBAC-gated\n- Works with any ATProto Lexicon (hypercerts, profiles, etc.)","status":"closed","priority":2,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:08:49.023193+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.796324+08:00","closed_at":"2026-02-18T15:44:50.796327+08:00","labels":["scope:medium"]}
{"id":"hypercerts-dpt.1","title":"Create PdsAdminService for org account lifecycle management","description":"## Files\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.test.ts (create)\n\n## What to do\nCreate a PdsAdminService that manages org PDS account creation and credential storage.\n\n### PdsAdminService class\n```typescript\nexport class PdsAdminService {\n  constructor(\n    pdsUrl: string,           // e.g., 'https://certified.app'\n    pdsDomain: string,        // e.g., 'certified.app'\n    credentialStore: CredentialStore,\n    orgStore: OrgStore,\n    auditLogger: AuditLogger\n  )\n\n  // Create a new PDS account for an organization\n  // 1. Generate random handle: org-{randomBase36(6)}.certified.app\n  // 2. Generate random password (128 hex chars)\n  // 3. Call com.atproto.server.createAccount via XRPC\n  // 4. Store encrypted password in CredentialStore\n  // 5. Create org record in OrgStore with the returned DID\n  // 6. Add the creating user as admin\n  // 7. Log ACCOUNT_CREATED audit event\n  async createOrgAccount(orgName: string, creatorDid: string): Promise\u003c{ orgId: string, did: string, handle: string }\u003e\n\n  // Delete an org's PDS account (admin only)\n  // 1. Verify caller is admin via OrgStore\n  // 2. Call com.atproto.server.deleteAccount via XRPC (using stored credentials)\n  // 3. Remove from CredentialStore\n  // 4. Remove from OrgStore\n  async deleteOrgAccount(orgId: string, callerDid: string): Promise\u003cvoid\u003e\n\n  // Get a session for an org account (for making writes)\n  // 1. Retrieve encrypted password from CredentialStore\n  // 2. Call com.atproto.server.createSession with org's credentials\n  // 3. Return the session (accessJwt, refreshJwt, did, handle)\n  async getOrgSession(orgId: string): Promise\u003cAtpSessionData\u003e\n}\n```\n\n### XRPC calls\nUse @atproto/api's AtpAgent for XRPC calls:\n```typescript\nimport { AtpAgent } from '@atproto/api'\nconst agent = new AtpAgent({ service: pdsUrl })\nawait agent.createAccount({ handle, email: `org-${orgId}@certified.app`, password })\n```\n\n### Handle format for orgs\n`org-{randomBase36(6)}.certified.app` — prefixed with 'org-' to distinguish from user handles.\n\n## Don't\n- Expose org credentials to the caller\n- Skip RBAC checks on delete\n- Use PDS internal APIs (use XRPC only — this is the external API)\n- Create real email addresses for orgs (use synthetic emails like org-{id}@certified.app)","acceptance_criteria":"1. PdsAdminService class exists with createOrgAccount, deleteOrgAccount, getOrgSession methods. 2. createOrgAccount creates PDS account, stores encrypted credentials, creates OrgStore record, adds creator as admin. 3. deleteOrgAccount verifies admin role before deleting. 4. getOrgSession returns valid session data. 5. Tests mock XRPC calls and verify the full flow.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:09:09.325187+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.89047+08:00","closed_at":"2026-02-18T15:44:50.890472+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-dpt.1","depends_on_id":"hypercerts-dpt","type":"parent-child","created_at":"2026-02-18T14:09:09.326241+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-dpt.1","depends_on_id":"hypercerts-8mu.1","type":"blocks","created_at":"2026-02-18T14:09:09.327966+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-dpt.1","depends_on_id":"hypercerts-xpo.1","type":"blocks","created_at":"2026-02-18T14:09:09.328955+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-dpt.2","title":"Create PdsRecordService for RBAC-gated writes to org repos","description":"## Files\n- packages/pds-sidecar/packages/shared/src/pds-record-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-record-service.test.ts (create)\n\n## What to do\nCreate a PdsRecordService that performs RBAC-gated CRUD operations on org repos.\n\n### PdsRecordService class\n```typescript\nexport class PdsRecordService {\n  constructor(\n    pdsAdminService: PdsAdminService,\n    orgStore: OrgStore,\n    auditLogger: AuditLogger\n  )\n\n  // Create a record in an org's repo\n  // 1. Check RBAC: caller must have 'contributor' or 'admin' role\n  // 2. Get org session via PdsAdminService\n  // 3. Call com.atproto.repo.createRecord via XRPC as the org account\n  // 4. Log audit event\n  async createRecord(orgId: string, callerDid: string, params: {\n    collection: string,  // e.g., 'org.certified.hypercert'\n    record: unknown,     // the record data (any Lexicon)\n    rkey?: string        // optional record key\n  }): Promise\u003c{ uri: string, cid: string }\u003e\n\n  // Get a record from an org's repo (no RBAC needed — ATProto repos are public)\n  async getRecord(orgDid: string, collection: string, rkey: string): Promise\u003cunknown\u003e\n\n  // Update a record in an org's repo\n  // 1. Check RBAC: caller must have 'contributor' or 'admin' role\n  // 2. Get org session\n  // 3. Call com.atproto.repo.putRecord\n  async putRecord(orgId: string, callerDid: string, params: {\n    collection: string,\n    rkey: string,\n    record: unknown,\n    swapRecord?: string  // CID for optimistic concurrency\n  }): Promise\u003c{ uri: string, cid: string }\u003e\n\n  // Delete a record from an org's repo\n  // 1. Check RBAC: caller must have 'admin' role (only admins can delete)\n  // 2. Get org session\n  // 3. Call com.atproto.repo.deleteRecord\n  async deleteRecord(orgId: string, callerDid: string, params: {\n    collection: string,\n    rkey: string,\n    swapRecord?: string\n  }): Promise\u003cvoid\u003e\n\n  // List records in an org's repo (no RBAC needed — public)\n  async listRecords(orgDid: string, collection: string, opts?: {\n    limit?: number,\n    cursor?: string,\n    reverse?: boolean\n  }): Promise\u003c{ records: unknown[], cursor?: string }\u003e\n}\n```\n\n### XRPC calls\nUse @atproto/api's AtpAgent, authenticated with the org's session:\n```typescript\nconst agent = new AtpAgent({ service: pdsUrl })\nagent.session = await pdsAdminService.getOrgSession(orgId)\nawait agent.com.atproto.repo.createRecord({ repo: orgDid, collection, record })\n```\n\n## Don't\n- Skip RBAC checks on any write operation\n- Allow viewers to create/update/delete records\n- Allow contributors to delete records (admin only)\n- Cache org sessions indefinitely (sessions expire — refresh as needed)\n- Expose the org's credentials or session tokens to the caller","acceptance_criteria":"1. PdsRecordService exists with createRecord, getRecord, putRecord, deleteRecord, listRecords. 2. Write operations check RBAC before proceeding. 3. Viewers cannot write. 4. Contributors can create/update but not delete. 5. Admins can do everything. 6. Tests mock XRPC and verify RBAC enforcement for each operation.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:09:26.251834+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.980108+08:00","closed_at":"2026-02-18T15:44:50.98011+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-dpt.2","depends_on_id":"hypercerts-dpt","type":"parent-child","created_at":"2026-02-18T14:09:26.253178+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-dpt.2","depends_on_id":"hypercerts-dpt.1","type":"blocks","created_at":"2026-02-18T14:09:26.255023+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-f9e","title":"Epic: Production Security Hardening","description":"## Goal\nHarden the entire auth stack (sidecar + PDS + scaffold) for production use during the Ma Earth grants round. Cover secrets management, email deliverability, rate limiting verification, HTTPS enforcement, and security headers.\n\n## Context\nThe architecture doc identifies these risks:\n- Auto-generated passwords stored server-side (mitigated by CredentialStore encryption in Epic: OTP Hardening)\n- Single PDS = single point of failure\n- Two auth layers to keep in sync\n\nProduction hardening needs:\n1. **Secrets management**: All sensitive env vars (HMAC secret, encryption key, admin API key, SMTP credentials) stored securely, not in .env files in production\n2. **Email deliverability**: SPF/DKIM/DMARC records for certified.app domain, use reputable SMTP provider (Resend, SES, Postmark)\n3. **Rate limiting verification**: Confirm the existing rate limiter (per-email 3/15min 5/hr, per-IP 10/15min) works correctly under load\n4. **HTTPS enforcement**: All production endpoints must be HTTPS only\n5. **Security headers**: HSTS, CSP, X-Frame-Options, X-Content-Type-Options on all sidecar responses\n6. **CORS configuration**: Sidecar must only accept requests from known origins\n7. **Error handling**: No stack traces or internal details leaked in production error responses\n\n## Existing State\n- The sidecar has rate limiting (packages/pds-sidecar/packages/shared/dist/rate-limiter.js)\n- The sidecar has CSRF protection (double-submit cookie)\n- Docker Compose with Caddy exists (packages/pds-sidecar/docker-compose.yml) — Caddy handles TLS\n- Security headers are mentioned in the epic description but implementation status is unknown\n\n## Success Looks Like\n- All secrets stored in env vars (documented) with no defaults\n- Email deliverability tested (SPF/DKIM/DMARC check passes)\n- Rate limiting verified under simulated load\n- All endpoints HTTPS in production\n- Security headers present on all sidecar responses\n- No internal details in error responses","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:06:26.593184+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.941251+08:00","closed_at":"2026-02-18T15:44:49.941253+08:00","labels":["scope:medium"]}
{"id":"hypercerts-f9e.1","title":"Add security headers middleware to sidecar auth service","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/middleware/security-headers.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/security-headers.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/app.ts (modify — add middleware)\n\n## What to do\nCreate an Express middleware that adds security headers to all sidecar responses.\n\n### Headers to set\n```\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\nContent-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; frame-ancestors 'none'\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 0\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: camera=(), microphone=(), geolocation=()\nCache-Control: no-store, no-cache, must-revalidate (for auth endpoints only)\n```\n\n### Middleware implementation\n```typescript\nexport function securityHeaders(): RequestHandler {\n  return (req, res, next) =\u003e {\n    // Set all headers listed above\n    // For /auth/* and /oauth/* routes, also set Cache-Control: no-store\n    next()\n  }\n}\n```\n\n### Integration\nAdd the middleware to the Express app in app.ts BEFORE any route handlers:\n```typescript\napp.use(securityHeaders())\n```\n\n### Tests\n- Verify each header is present on a response\n- Verify Cache-Control: no-store is set on /auth/send-code\n- Verify Cache-Control: no-store is set on /oauth/authorize\n- Verify headers are NOT set on health check endpoint (optional — health checks can have headers)\n\n## Don't\n- Use helmet.js or any external dependency (implement manually for transparency)\n- Set CSP that blocks the OTP form's inline styles (the form uses inline styles for the email input)\n- Set HSTS in development (check NODE_ENV)","acceptance_criteria":"1. Security headers middleware exists. 2. All 8 headers are set on auth responses. 3. Cache-Control: no-store is set on /auth/* and /oauth/* routes. 4. HSTS is only set when NODE_ENV=production. 5. Tests verify all headers are present.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:06:41.18835+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.041793+08:00","closed_at":"2026-02-18T15:44:50.041797+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-f9e.1","depends_on_id":"hypercerts-f9e","type":"parent-child","created_at":"2026-02-18T14:06:41.189421+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-f9e.2","title":"Add production error handler that strips internal details","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/middleware/error-handler.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/error-handler.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/app.ts (modify — add error handler)\n\n## What to do\nCreate an Express error-handling middleware that catches all unhandled errors and returns safe responses.\n\n### Error handler behavior\n```typescript\nexport function errorHandler(): ErrorRequestHandler {\n  return (err, req, res, next) =\u003e {\n    // 1. Log the full error (stack trace, details) via pino logger\n    // 2. In production (NODE_ENV=production):\n    //    - Return { error: 'Internal Server Error' } with status 500\n    //    - Never include stack traces, file paths, or internal details\n    //    - For known error types (ValidationError, RateLimitError), return appropriate status codes\n    // 3. In development:\n    //    - Return { error: err.message, stack: err.stack } for debugging\n  }\n}\n```\n\n### Known error types to handle\n- ValidationError (400) — missing/invalid request params\n- RateLimitError (429) — rate limit exceeded (include Retry-After header)\n- AuthenticationError (401) — invalid OTP, expired session\n- ForbiddenError (403) — invalid HMAC signature\n- NotFoundError (404) — unknown route\n- All others (500) — generic internal error\n\n### Custom error classes\nCreate simple error classes:\n```typescript\nexport class AppError extends Error {\n  constructor(message: string, public statusCode: number, public isOperational: boolean = true) {\n    super(message)\n  }\n}\nexport class ValidationError extends AppError { constructor(msg: string) { super(msg, 400) } }\nexport class RateLimitError extends AppError { constructor(retryAfter: number) { super('Too Many Requests', 429); this.retryAfter = retryAfter } }\nexport class AuthenticationError extends AppError { constructor(msg: string) { super(msg, 401) } }\n```\n\n## Don't\n- Expose stack traces in production\n- Expose file paths in production\n- Expose database error details in production\n- Swallow errors without logging them\n- Use console.log (use pino logger)","acceptance_criteria":"1. Error handler middleware exists. 2. In production mode, no stack traces or file paths in responses. 3. Known error types return correct HTTP status codes. 4. All errors are logged via pino. 5. Tests verify: production mode hides details, dev mode shows details, each error type returns correct status code.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:06:56.706777+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.139317+08:00","closed_at":"2026-02-18T15:44:50.13932+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-f9e.2","depends_on_id":"hypercerts-f9e","type":"parent-child","created_at":"2026-02-18T14:06:56.707926+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-f9e.3","title":"Create production environment configuration and secrets documentation","description":"## Files\n- docs/production-deployment.md (create)\n- packages/pds-sidecar/.env.production.example (create)\n\n## What to do\nDocument all environment variables needed for production deployment and create an example .env file.\n\n### .env.production.example contents\nList every env var with description, required/optional, and example value:\n\n```bash\n# === PDS Configuration ===\nPDS_HOSTNAME=certified.app          # Required. The PDS domain name\nPDS_DATA_DIRECTORY=/pds/data         # Required. Where PDS stores SQLite + blobs\nPDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=  # Required. secp256k1 private key (hex)\nPDS_JWT_SECRET=                      # Required. Random 32+ char string\nPDS_ADMIN_PASSWORD=                  # Required. PDS admin password\nPDS_EMAIL_SMTP_URL=smtps://...       # Required. SMTP connection string\nPDS_EMAIL_FROM_ADDRESS=noreply@certified.app\n\n# === Sidecar Configuration ===\nSIDECAR_PORT=3001                    # Default: 3001\nSIDECAR_SESSION_SECRET=              # Required. Random 64+ char string\nHMAC_SECRET=                         # Required. Shared secret between sidecar and PDS (64+ hex chars)\nCREDENTIAL_ENCRYPTION_KEY=           # Required. 32-byte hex key for AES-256-GCM\nADMIN_API_KEY=                       # Required. API key for admin endpoints\n\n# === SMTP (for sidecar OTP emails) ===\nSMTP_HOST=smtp.resend.com\nSMTP_PORT=465\nSMTP_USER=resend\nSMTP_PASS=                           # Required. SMTP password\nSMTP_FROM=auth@certified.app\n\n# === Auth Service ===\nAUTH_SERVICE_URL=https://auth.certified.app  # Required. Public URL of sidecar\nPDS_INTERNAL_URL=http://pds:3000     # Required. Internal Docker network URL\n\n# === Node ===\nNODE_ENV=production\n```\n\n### production-deployment.md contents\n1. **Prerequisites** — Docker, Docker Compose, domain with DNS access, SMTP provider account\n2. **DNS Setup** — A records, wildcard for handles, auth subdomain\n3. **Email Deliverability** — SPF, DKIM, DMARC record examples for certified.app\n4. **Secrets Generation** — Commands to generate each secret (openssl rand, etc.)\n5. **Docker Compose** — Reference the existing docker-compose.yml, explain each service\n6. **Caddy Configuration** — TLS, reverse proxy, wildcard certs\n7. **Health Checks** — Endpoints to monitor\n8. **Backup Strategy** — SQLite backup for PDS data and sidecar data\n9. **Monitoring** — What to alert on (auth failures, rate limit hits, PDS errors)\n\n## Don't\n- Include actual secrets or API keys\n- Skip the email deliverability section (SPF/DKIM/DMARC is critical)\n- Assume the reader knows Docker internals\n- Skip the backup strategy","acceptance_criteria":"1. .env.production.example exists with all env vars documented. 2. production-deployment.md exists with all 9 sections. 3. SPF/DKIM/DMARC record examples are included. 4. Secret generation commands are provided for every secret. 5. No actual secrets appear in any file.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T14:07:16.74566+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.310573+08:00","closed_at":"2026-02-18T15:44:50.310578+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-f9e.3","depends_on_id":"hypercerts-f9e","type":"parent-child","created_at":"2026-02-18T14:07:16.746925+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-hpb","title":"Epic: OAuth Client Integration for Certified Apps (BFF Pattern)","description":"## Goal\nImplement the OAuth client integration pattern that allows multiple Certified apps (Ma Earth, GainForest, Silvi) to authenticate users via the single Certified PDS using the Backend-for-Frontend (BFF) pattern. Each app gets independent OAuth tokens (DPoP-bound) for the same DID.\n\n## Context\nThe scaffold app (hypercerts-scaffold) already has a working OAuth flow:\n- POST /api/auth/login initiates OAuth via sdk.authorize(handle)\n- GET /api/auth/callback handles the OAuth callback\n- Session stored in Redis via @atproto/oauth-client-node\n- DPoP token binding is handled by the SDK\n\nThe key change for email-first auth: instead of `sdk.authorize(handle)`, apps call `sdk.authorize('https://certified.app')` with `login_hint=email`. This skips handle resolution entirely.\n\nThe /login page and /api/auth/email-login route were built on the beads/plan-passwordless-login branch (tasks hypercerts-2bf.1, 2bf.2, 2bf.3 — all completed). These need to be merged to main and verified.\n\n### BFF Pattern\nEach Certified app runs its own backend that:\n1. Has its own OAuth client_id (derived from its public URL per ATProto spec)\n2. Stores its own session/state in Redis\n3. Calls sdk.authorize('https://certified.app', { login_hint: email })\n4. Handles its own /api/auth/callback\n5. Gets DPoP-bound tokens for the user's DID\n\nThe PDS sees each app as a separate OAuth client. The user consents once per app.\n\n## What Has to Be Built\n1. Verify the email-login flow works end-to-end with the sidecar (merge from beads branch)\n2. Document the BFF integration pattern for other Certified apps\n3. Create a minimal example/template that GainForest/Silvi can copy\n4. Add 'Sign in with Certified' button component that's reusable across apps\n\n## Hard Constraints\n- Each app MUST have its own OAuth client_id (no shared clients)\n- Each app MUST run its own backend (no shared sessions)\n- The PDS URL is hardcoded to 'https://certified.app' (or configured via env var)\n- login_hint MUST be passed as email for the sidecar to auto-send OTP\n\n## Success Looks Like\n- Scaffold app authenticates via email-first flow against the Certified PDS\n- Integration guide exists for other Certified apps\n- Reusable 'Sign in with Certified' button component exists\n- Example .env and route files for a new Certified app","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:05:23.165082+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.588829+08:00","closed_at":"2026-02-18T15:44:49.588832+08:00","labels":["scope:medium"]}
{"id":"hypercerts-hpb.1","title":"Merge email-login flow from beads branch and verify against local PDS","description":"## Files\n- app/login/page.tsx (from beads/plan-passwordless-login branch)\n- app/api/auth/email-login/route.ts (from beads/plan-passwordless-login branch)\n- queries/mutations/use-email-login-mutation.ts (from beads/plan-passwordless-login branch)\n- lib/api/auth.ts (modified on beads branch)\n\n## What to do\n1. Cherry-pick or merge the email-login commits from beads/plan-passwordless-login into the current branch\n2. Resolve any merge conflicts\n3. Verify the /login page renders correctly at http://127.0.0.1:3000/login\n4. Verify the /api/auth/email-login route accepts POST with { email } body\n5. Verify the route calls sdk.authorize() with the PDS URL and login_hint=email\n6. Run `pnpm build` to ensure no TypeScript errors\n7. Run `pnpm lint` to ensure no lint errors\n\n### Commits to cherry-pick (from beads/plan-passwordless-login)\n- 0ce88fd: Add useEmailLoginMutation hook and emailLogin API function\n- c354707: fix: address P1/P2 review findings\n- 062b00d: Create /login page with email input form\n- bd90c35: fix: allow /login page to bypass SignedInProvider auth gate\n\n## Don't\n- Modify the existing handle-based login flow (LoginDialog, /api/auth/login)\n- Change any environment variables\n- Modify the OAuth callback route (it handles both flows identically)\n- Cherry-pick unrelated commits from the beads branch","acceptance_criteria":"1. /login page exists and renders email input form. 2. POST /api/auth/email-login accepts { email } and initiates OAuth. 3. pnpm build succeeds. 4. pnpm lint passes. 5. Old handle-based login at / still works (LoginDialog unchanged).","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:05:36.667168+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.676826+08:00","closed_at":"2026-02-18T15:44:49.676829+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-hpb.1","depends_on_id":"hypercerts-hpb","type":"parent-child","created_at":"2026-02-18T14:05:36.668579+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-hpb.2","title":"Create Certified OAuth integration guide for partner apps","description":"## Files\n- docs/certified-oauth-integration.md (create)\n\n## What to do\nWrite a comprehensive integration guide that GainForest, Silvi, or any new Certified app can follow to add 'Sign in with Certified' to their app.\n\n### Guide structure\n1. **Overview** — What Certified auth is, how it works (email → OTP → OAuth), what the app needs\n2. **Prerequisites** — Node.js, Redis, @atproto/oauth-client-node or @hypercerts-org/sdk-core\n3. **Step 1: Environment setup** — Required env vars:\n   - NEXT_PUBLIC_PDS_URL=https://certified.app\n   - NEXT_PUBLIC_BASE_URL=https://your-app.com\n   - ATPROTO_JWK_PRIVATE (how to generate with `pnpm run generate-jwk`)\n   - REDIS_HOST, REDIS_PORT, REDIS_PASSWORD\n4. **Step 2: OAuth client metadata** — Explain how ATProto derives client_id from the app's public URL. Show the client-metadata.json and jwks.json route handlers (copy from scaffold).\n5. **Step 3: SDK initialization** — Show createATProtoSDK() setup with Redis session/state stores\n6. **Step 4: Login route** — Show the /api/auth/email-login route that calls sdk.authorize(pdsUrl, { login_hint: email })\n7. **Step 5: Callback route** — Show the /api/auth/callback route\n8. **Step 6: Frontend** — Show the email input form and useEmailLoginMutation hook\n9. **Step 7: Session management** — How to check if user is logged in, get their DID, make authenticated API calls\n10. **Troubleshooting** — Common errors (loopback client issues, CORS, Redis connection, DPoP errors)\n\n### Code examples\nAll code examples should be copied from the actual scaffold codebase (not invented). Reference specific files.\n\n## Don't\n- Include org/RBAC setup (that's a separate guide)\n- Include PDS deployment instructions (that's for the Certified infra team)\n- Invent code examples — copy from the scaffold\n- Skip the troubleshooting section","acceptance_criteria":"1. docs/certified-oauth-integration.md exists with all 10 sections. 2. All code examples are real (copied from scaffold source files with file path references). 3. Environment variable list is complete. 4. A developer unfamiliar with ATProto can follow the guide to add Certified auth to a new Next.js app.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:05:54.239742+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.772251+08:00","closed_at":"2026-02-18T15:44:49.772254+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-hpb.2","depends_on_id":"hypercerts-hpb","type":"parent-child","created_at":"2026-02-18T14:05:54.241525+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-hpb.3","title":"Create reusable SignInWithCertified button component","description":"## Files\n- components/sign-in-with-certified.tsx (create)\n\n## What to do\nCreate a reusable React button component that initiates the Certified email-first auth flow.\n\n### Component API\n```typescript\ninterface SignInWithCertifiedProps {\n  variant?: 'default' | 'outline' | 'ghost'  // maps to shadcn Button variants\n  size?: 'default' | 'sm' | 'lg'\n  className?: string\n  redirectTo?: string  // where to redirect after login (default: '/')\n}\n\nexport function SignInWithCertified(props: SignInWithCertifiedProps): JSX.Element\n```\n\n### Behavior\n1. Renders a button with the Certified logo/icon and text 'Sign in with Certified'\n2. On click, redirects to /login page (or opens a modal with email input — match the existing LoginDialog pattern)\n3. Uses the existing useEmailLoginMutation hook for the auth flow\n4. Shows loading spinner during OAuth redirect\n5. Handles errors with toast notifications (using sonner, matching existing pattern)\n\n### Styling\n- Use shadcn Button component as base\n- Certified brand color: use the existing gradient/glassmorphism design system\n- Include a small shield/lock icon (from lucide-react) next to the text\n- Responsive: full-width on mobile, auto-width on desktop\n\n### Usage example\n```tsx\nimport { SignInWithCertified } from '@/components/sign-in-with-certified'\n\nexport default function LandingPage() {\n  return \u003cSignInWithCertified variant='default' size='lg' /\u003e\n}\n```\n\n## Don't\n- Add new dependencies (use existing shadcn, lucide-react, sonner)\n- Create a new auth flow — reuse the existing useEmailLoginMutation\n- Hard-code the PDS URL in the component (use NEXT_PUBLIC_PDS_URL from config)\n- Break the existing LoginDialog component","acceptance_criteria":"1. SignInWithCertified component exists at components/sign-in-with-certified.tsx. 2. Renders a button with 'Sign in with Certified' text. 3. On click, navigates to /login or triggers email input. 4. Uses existing useEmailLoginMutation hook. 5. Shows loading state during auth. 6. No new dependencies added.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:06:08.77502+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.857081+08:00","closed_at":"2026-02-18T15:44:49.857084+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-hpb.3","depends_on_id":"hypercerts-hpb","type":"parent-child","created_at":"2026-02-18T14:06:08.776449+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-hpb.3","depends_on_id":"hypercerts-hpb.1","type":"blocks","created_at":"2026-02-18T14:06:08.777668+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-i6a","title":"Epic: Prototype Evaluation \u0026 PDS Fork Assessment","description":"## Goal\nEvaluate Holke's existing prototype (maearth-demo + magic-pds + holkexyz/atproto fork) to determine what can be reused and what must be rebuilt for Option A (single stock PDS + application-layer passwordless OTP).\n\n## Context\nThree repos exist from Holke's prototype work:\n- `holkexyz/maearth-demo` — Next.js OAuth client at maearth-demo.vercel.app with passwordless email login against pds.certs.network\n- `holkexyz/magic-pds` — 'Passwordless AT Protocol PDS' auth service at auth.pds.certs.network\n- `holkexyz/atproto` — Fork of bluesky-social/atproto labeled 'HolkesPDS - a friendly fork'\n\nThe critical question: does magic-pds require the PDS fork, or does it work against a stock PDS? This determines whether we can reuse the prototype or must rebuild the auth layer.\n\nAdditionally, we already have a pds-sidecar built in this repo (packages/pds-sidecar/) with OTP service, rate limiter, HMAC callback signer, mailer, auth-service routes, and PDS core wrapper. We need to determine the overlap and best path forward.\n\n## Key Questions to Answer\n1. Is holkexyz/atproto actually deployed at pds.certs.network? How far has it diverged from upstream?\n2. How does magic-pds authenticate against the PDS? Hidden-password? Direct DB access? Fork-specific API?\n3. Is magic-pds modifying PDS internals or purely wrapping it?\n4. What hardening exists? Rate limiting, OTP expiry, error handling, email deliverability?\n5. Can we migrate to a stock PDS without breaking magic-pds?\n6. How does our existing pds-sidecar compare to magic-pds? What's the delta?\n\n## Success Looks Like\nA written assessment document (markdown) in docs/ that answers all 6 questions above with concrete evidence (code references, deployment configs, test results). Clear recommendation on whether to adopt magic-pds, adapt our pds-sidecar, or hybrid approach.\n\n## Scope\nResearch and documentation only. No code changes.","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:02:15.064862+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:40.275429+08:00","closed_at":"2026-02-18T15:44:40.275432+08:00","labels":["scope:medium"]}
{"id":"hypercerts-i6a.1","title":"Audit holkexyz/magic-pds: determine auth mechanism and PDS fork dependency","description":"## Files\n- docs/prototype-assessment.md (create)\n\n## What to do\n1. Clone holkexyz/magic-pds and read the source code\n2. Determine how it authenticates against the PDS:\n   - Does it use hidden auto-generated passwords (Option A1 pattern)?\n   - Does it directly access the PDS database?\n   - Does it call fork-specific APIs not in stock @atproto/pds?\n   - Does it bypass PDS auth entirely and issue its own tokens?\n3. Check if magic-pds imports anything from holkexyz/atproto that doesn't exist in bluesky-social/atproto\n4. Document the auth flow step-by-step with code references\n5. Write findings in docs/prototype-assessment.md under a '## magic-pds Auth Mechanism' section\n\n## Don't\n- Modify any code in magic-pds or this repo\n- Make assumptions — cite specific code lines\n- Skip checking package.json dependencies for fork references","acceptance_criteria":"docs/prototype-assessment.md exists with a '## magic-pds Auth Mechanism' section that includes: (1) the exact auth method used (hidden password / DB access / fork API / other), (2) at least 3 code references with file paths and line numbers from magic-pds, (3) a yes/no answer to 'Does magic-pds require the PDS fork?' with evidence","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:02:27.921641+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.551399+08:00","closed_at":"2026-02-18T15:44:48.551402+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-i6a.1","depends_on_id":"hypercerts-i6a","type":"parent-child","created_at":"2026-02-18T14:02:27.923368+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-i6a.2","title":"Audit holkexyz/atproto fork: measure divergence from upstream bluesky-social/atproto","description":"## Files\n- docs/prototype-assessment.md (modify — append section)\n\n## What to do\n1. Clone holkexyz/atproto\n2. Identify the upstream commit it forked from (check git log for the fork point)\n3. Run `git diff \u003cfork-point\u003e..HEAD --stat` to measure total divergence\n4. List every modified file with a 1-line description of what changed\n5. Categorize changes: (a) PDS auth changes, (b) OAuth provider changes, (c) other\n6. Check if pds.certs.network is running this fork (inspect any deployment configs, Dockerfiles, or CI in the repo)\n7. Append findings to docs/prototype-assessment.md under '## Fork Divergence Analysis'\n\n## Don't\n- Modify the fork repo\n- Skip measuring the exact number of changed files and lines\n- Assume the fork is deployed without evidence","acceptance_criteria":"docs/prototype-assessment.md has a '## Fork Divergence Analysis' section that includes: (1) fork point commit hash, (2) total files changed and lines added/removed, (3) categorized list of all changes, (4) evidence-based answer to 'Is this fork deployed at pds.certs.network?'","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:02:37.812386+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.646765+08:00","closed_at":"2026-02-18T15:44:48.646768+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-i6a.2","depends_on_id":"hypercerts-i6a","type":"parent-child","created_at":"2026-02-18T14:02:37.81556+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-i6a.3","title":"Compare pds-sidecar vs magic-pds: feature matrix and recommendation","description":"## Files\n- docs/prototype-assessment.md (modify — append section)\n\n## What to do\n1. Read the existing pds-sidecar code in packages/pds-sidecar/ (compiled JS in dist/ dirs)\n2. Read the magic-pds source code (cloned in previous task)\n3. Create a feature comparison matrix covering:\n   - OTP generation and verification (code length, hashing, expiry, max attempts)\n   - Rate limiting (per-email, per-IP, windows)\n   - Email sending (SMTP integration, templates)\n   - Account creation (handle generation, password management)\n   - OAuth metadata override mechanism\n   - HMAC callback signing\n   - Session management\n   - CSRF protection\n   - Security headers\n   - Error handling and logging\n   - Test coverage\n4. Write a recommendation: adopt magic-pds, keep pds-sidecar, or hybrid\n5. Append to docs/prototype-assessment.md under '## Sidecar vs magic-pds Comparison'\n\n## Don't\n- Modify any code\n- Recommend without justifying each point\n- Skip any of the 10 comparison dimensions listed above","acceptance_criteria":"docs/prototype-assessment.md has a '## Sidecar vs magic-pds Comparison' section with: (1) a feature matrix table with all 10 dimensions, (2) a clear recommendation (adopt/keep/hybrid) with rationale, (3) a list of gaps that need to be filled regardless of which approach is chosen","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:02:49.262643+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.74298+08:00","closed_at":"2026-02-18T15:44:48.742982+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-i6a.3","depends_on_id":"hypercerts-i6a","type":"parent-child","created_at":"2026-02-18T14:02:49.264462+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-i6a.3","depends_on_id":"hypercerts-i6a.1","type":"blocks","created_at":"2026-02-18T14:02:49.265724+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-iv0","title":"Epic: Domain Consolidation \u0026 Production Deployment to certified.app","description":"## Goal\nMigrate the entire stack from pds.certs.network to certified.app. Deploy the stock PDS + sidecar auth service under the certified.app domain so that `oauthClient.authorize('https://certified.app')` works in production.\n\n## Context\nCurrently the prototype runs on:\n- PDS: pds.certs.network\n- Auth: auth.pds.certs.network\n\nThe architecture doc recommends everything under certified.app:\n- PDS: certified.app (the PDS hostname)\n- Auth sidecar: auth.certified.app (or as a route on the same domain)\n- Handle resolution: *.certified.app (wildcard DNS for user handles like alice.certified.app)\n\nThis simplifies the `authorize('https://certified.app')` pattern and unifies the brand.\n\n## What Has to Be Done\n1. **DNS configuration**: A records for certified.app, auth.certified.app, and wildcard *.certified.app\n2. **TLS certificates**: Caddy with Let's Encrypt for all domains (DNS challenge for wildcard)\n3. **Docker Compose update**: Update the existing docker-compose.yml to use certified.app hostnames\n4. **PDS configuration**: Set PDS_HOSTNAME=certified.app, configure SMTP for @certified.app\n5. **Sidecar configuration**: Set AUTH_SERVICE_URL=https://auth.certified.app\n6. **Data migration**: If there are existing accounts on pds.certs.network, plan migration (or start fresh)\n7. **Smoke test**: Verify the full flow works with the new domain\n\n## Hard Constraints\n- Stock PDS only — no fork\n- Must support wildcard DNS for handle resolution\n- TLS on all endpoints (no HTTP in production)\n- The PDS at certified.app must serve OAuth authorization server metadata correctly\n- Sidecar must be reachable at auth.certified.app\n\n## Success Looks Like\n- certified.app resolves to the PDS\n- auth.certified.app resolves to the sidecar\n- *.certified.app resolves for handle verification\n- Full email→OTP→OAuth flow works against certified.app\n- OAuth metadata at certified.app/.well-known/oauth-authorization-server shows auth.certified.app as authorization_endpoint","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:09:43.125235+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.073705+08:00","closed_at":"2026-02-18T15:44:51.073708+08:00","labels":["scope:medium"]}
{"id":"hypercerts-iv0.1","title":"Update Docker Compose and Caddyfile for certified.app domain","description":"## Files\n- packages/pds-sidecar/docker-compose.yml (modify)\n- packages/pds-sidecar/Caddyfile (modify or create)\n- packages/pds-sidecar/.env.production.example (modify)\n\n## What to do\nUpdate the Docker Compose stack and Caddy configuration to use the certified.app domain.\n\n### Docker Compose changes\n1. Update PDS service environment:\n   - PDS_HOSTNAME=certified.app\n   - PDS_EMAIL_FROM_ADDRESS=noreply@certified.app\n2. Update sidecar service environment:\n   - AUTH_SERVICE_URL=https://auth.certified.app\n3. Update Caddy service configuration to route:\n   - certified.app → PDS (port 3000)\n   - auth.certified.app → sidecar auth service (port 3001)\n   - *.certified.app → PDS (for handle resolution)\n\n### Caddyfile\n```\ncertified.app {\n  reverse_proxy pds:3000\n}\n\nauth.certified.app {\n  reverse_proxy auth-service:3001\n}\n\n*.certified.app {\n  reverse_proxy pds:3000\n}\n```\n\nFor wildcard TLS, Caddy needs DNS challenge. Add the DNS provider plugin (e.g., cloudflare, route53) and configure via environment variables.\n\n### .env.production.example updates\nAdd/update:\n- CADDY_DNS_PROVIDER (e.g., cloudflare)\n- CADDY_DNS_API_TOKEN (for DNS challenge)\n- PDS_HOSTNAME=certified.app\n- AUTH_SERVICE_URL=https://auth.certified.app\n\n## Don't\n- Remove the existing pds.certs.network configuration (keep it as comments for reference)\n- Hard-code DNS provider credentials\n- Skip wildcard TLS (handles MUST resolve via HTTPS)\n- Change the Docker network topology (PDS and sidecar on same network)","acceptance_criteria":"1. docker-compose.yml uses certified.app hostnames. 2. Caddyfile routes certified.app to PDS and auth.certified.app to sidecar. 3. Wildcard *.certified.app is configured with DNS challenge TLS. 4. .env.production.example is updated with new vars. 5. docker compose config validates without errors.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T14:09:56.999471+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.170445+08:00","closed_at":"2026-02-18T15:44:51.170448+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-iv0.1","depends_on_id":"hypercerts-iv0","type":"parent-child","created_at":"2026-02-18T14:09:57.00088+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-iv0.2","title":"Create DNS and email deliverability setup checklist for certified.app","description":"## Files\n- docs/dns-setup-checklist.md (create)\n\n## What to do\nCreate a step-by-step checklist for configuring DNS and email deliverability for the certified.app domain.\n\n### DNS Records Needed\n```\n# A records (replace with actual server IP)\ncertified.app          A    \u003cserver-ip\u003e\nauth.certified.app     A    \u003cserver-ip\u003e\n*.certified.app        A    \u003cserver-ip\u003e\n\n# SPF record (for email sending)\ncertified.app          TXT  \"v=spf1 include:amazonses.com include:resend.com ~all\"\n\n# DKIM record (provider-specific, e.g., Resend)\nresend._domainkey.certified.app  CNAME  \u003cresend-dkim-value\u003e\n\n# DMARC record\n_dmarc.certified.app   TXT  \"v=DMARC1; p=quarantine; rua=mailto:dmarc@certified.app\"\n\n# ATProto-specific: _atproto TXT record for handle verification\n_atproto.certified.app TXT  \"did=did:plc:\u003cpds-did\u003e\"\n```\n\n### Checklist format\nEach item should have:\n- [ ] checkbox\n- What to do\n- How to verify (dig command, curl command, or online tool)\n- Common mistakes to avoid\n\n### Sections\n1. **DNS A Records** — Point all domains to the server\n2. **Wildcard DNS** — Verify *.certified.app resolves\n3. **SPF Setup** — Configure for your SMTP provider\n4. **DKIM Setup** — Generate and add DKIM records\n5. **DMARC Setup** — Configure DMARC policy\n6. **ATProto Handle Verification** — _atproto TXT record\n7. **TLS Verification** — Confirm Caddy issues certs for all domains\n8. **Email Deliverability Test** — Send test email, check spam score\n\n### Verification commands\nInclude specific commands:\n```bash\ndig certified.app A\ndig auth.certified.app A\ndig *.certified.app A\ndig certified.app TXT\ndig _dmarc.certified.app TXT\ncurl -s https://certified.app/xrpc/_health\ncurl -s https://auth.certified.app/health\ncurl -s https://certified.app/.well-known/oauth-authorization-server | jq .authorization_endpoint\n```\n\n## Don't\n- Include actual IP addresses or API keys\n- Skip the verification commands\n- Assume a specific DNS provider (keep it generic)\n- Skip the ATProto-specific DNS records","acceptance_criteria":"1. docs/dns-setup-checklist.md exists with all 8 sections. 2. Each section has checkboxes, instructions, and verification commands. 3. SPF/DKIM/DMARC examples are included. 4. ATProto handle verification DNS is documented. 5. All verification commands are correct and runnable.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:10:13.99869+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.258845+08:00","closed_at":"2026-02-18T15:44:51.258848+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-iv0.2","depends_on_id":"hypercerts-iv0","type":"parent-child","created_at":"2026-02-18T14:10:14.000213+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-jbx","title":"Fix: OTP generateOTP uses 8-digit range but spec says 6-digit (from hypercerts-qc3.2)","description":"Review of hypercerts-qc3.2 found: OTPService.generateOTP() uses crypto.randomInt(10000000, 99999999) which generates 8-digit codes, but the epic description (hypercerts-qc3) says '6-digit OTP code'. The OTP page template (templates.ts) also uses maxlength='8' and pattern='[0-9]{8}', and the test expects /^\\d{8}$/. There is an internal inconsistency: the epic says 6-digit but the implementation is 8-digit throughout. The implementation is self-consistent (all 8-digit), but it contradicts the epic spec. This should be clarified and the spec or implementation aligned. Evidence: otp-service.ts line 13: randomInt(10000000, 99999999); epic description says '6-digit OTP code'.","status":"closed","priority":1,"issue_type":"bug","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:53:35.160737+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:54:37.717098+08:00","closed_at":"2026-02-17T18:54:37.717108+08:00","dependencies":[{"issue_id":"hypercerts-jbx","depends_on_id":"hypercerts-qc3.2","type":"discovered-from","created_at":"2026-02-17T18:53:35.355411+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-jw5","title":"Epic: Remove all SDS references and organization features","description":"Remove all Shared Data Server (SDS) infrastructure and organization-related features from the codebase. This includes environment configuration, type definitions, organization pages/components/queries, profile switching, and all related documentation. The application will only support PDS (Personal Data Server) going forward.","status":"closed","priority":1,"issue_type":"epic","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:19.625374856+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:08:54.570180551+06:00","closed_at":"2026-02-13T11:08:54.570180551+06:00","close_reason":"Completed: All SDS references and organization features removed"}
{"id":"hypercerts-jw5.1","title":"Remove SDS from environment configuration","description":"Remove NEXT_PUBLIC_SDS_URL environment variable from .env.example and .env.local. Remove sdsUrl field and validation from lib/config.ts (lines 194, 210, 236). Files affected: .env.example (lines 52-53), .env.local (line 20), lib/config.ts (lines 194, 210, 236).","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:25.0772292+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:01:21.906727001+06:00","closed_at":"2026-02-13T11:01:21.906727001+06:00","close_reason":"Completed: 970322f3161f84168f0130778997293b3c3cc853","dependencies":[{"issue_id":"hypercerts-jw5.1","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:57:25.078964487+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.10","title":"Remove profile switching dialog","description":"Delete components/profile-switch-dialog.tsx entirely. Remove this component from any layouts or pages that import it (likely in app/layout.tsx or similar). Remove the SignedInProvider usage from providers/SignedInProvider.tsx (line 27) that fetches organization data with getAuthenticatedRepo('sds'). This task depends on hypercerts-jw5.3 (session management) because the provider uses serverOverride.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:58:14.830834235+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:06:47.965297704+06:00","closed_at":"2026-02-13T11:06:47.965297704+06:00","close_reason":"Completed: af38f1b","dependencies":[{"issue_id":"hypercerts-jw5.10","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:58:14.832712721+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.10","depends_on_id":"hypercerts-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:36.962725875+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.11","title":"Update repo context to handle PDS only","description":"Simplify lib/repo-context.ts to only handle PDS. Remove the server determination logic at line 61 (targetDid === userDid ? 'pds' : 'sds'). Remove RepoServer type field from interfaces if no longer needed. This task depends on hypercerts-jw5.2 (type definitions) and hypercerts-jw5.3 (session management) because we need the core types and session logic updated first.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:58:20.278269871+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:06:32.355814639+06:00","closed_at":"2026-02-13T11:06:32.355814639+06:00","close_reason":"Completed: 024d9b8b1dfe9cd5b49a45aeb7cae96cc95e2667","dependencies":[{"issue_id":"hypercerts-jw5.11","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:58:20.279708313+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.11","depends_on_id":"hypercerts-jw5.2","type":"blocks","created_at":"2026-02-13T10:58:37.013357307+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.11","depends_on_id":"hypercerts-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:37.06325177+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.12","title":"Clean up organization query keys","description":"Remove organization-related query key definitions from lib/api/query-keys.ts (lines 41-48). This task depends on hypercerts-jw5.7 (delete organization queries) because we need to ensure no queries are using these keys before removing them.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:58:24.864366819+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:05:14.468657802+06:00","closed_at":"2026-02-13T11:05:14.468657802+06:00","close_reason":"Completed: 2e96aef","dependencies":[{"issue_id":"hypercerts-jw5.12","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:58:24.866971645+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.12","depends_on_id":"hypercerts-jw5.7","type":"blocks","created_at":"2026-02-13T10:58:37.11335342+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.13","title":"Update README to remove SDS documentation","description":"Remove all SDS references from README.md: line 10 (PDS/SDS account mention), line 45 (environment variable table entry), line 63 (test server URL example), lines 119-127 (architecture diagram and PDS vs SDS explanation), line 196 (organizations on SDS mention), line 254 (link to SDS GitHub repo). Update documentation to reflect PDS-only architecture. This task depends on all previous tasks (hypercerts-jw5.1 through hypercerts-jw5.12) because documentation should be updated last after all code changes are complete.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:58:31.437345428+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:08:36.620756909+06:00","closed_at":"2026-02-13T11:08:36.620756909+06:00","close_reason":"Completed: README already updated by previous commits","dependencies":[{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:58:31.438988373+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.1","type":"blocks","created_at":"2026-02-13T10:58:42.980883411+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.2","type":"blocks","created_at":"2026-02-13T10:58:43.031383969+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:43.083619404+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.4","type":"blocks","created_at":"2026-02-13T10:58:43.135155641+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.5","type":"blocks","created_at":"2026-02-13T10:58:43.197015061+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.6","type":"blocks","created_at":"2026-02-13T10:58:43.246763992+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.7","type":"blocks","created_at":"2026-02-13T10:58:43.295935142+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.8","type":"blocks","created_at":"2026-02-13T10:58:43.345300956+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.9","type":"blocks","created_at":"2026-02-13T10:58:43.395508806+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.10","type":"blocks","created_at":"2026-02-13T10:58:43.443782516+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.11","type":"blocks","created_at":"2026-02-13T10:58:43.492942164+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.13","depends_on_id":"hypercerts-jw5.12","type":"blocks","created_at":"2026-02-13T10:58:43.545747096+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.2","title":"Update type definitions to remove SDS","description":"Change RepoServer type from 'pds' | 'sds' to just 'pds' in lib/repo-context.ts (line 8). Remove serverOverride parameter type that includes 'sds' from lib/atproto-session.ts (line 8). Update all type usage to reflect PDS-only infrastructure. Files affected: lib/repo-context.ts (lines 8, 23, 30, 61), lib/atproto-session.ts (lines 8, 19).","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:31.387671487+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:01:52.916414734+06:00","closed_at":"2026-02-13T11:01:52.916414734+06:00","close_reason":"Completed: 7cb57ff4f0e9545e9fd8b27d194de5236d269061","dependencies":[{"issue_id":"hypercerts-jw5.2","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:57:31.390035933+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.3","title":"Simplify session management by removing SDS logic","description":"Remove serverOverride parameter from getAuthenticatedRepo function in lib/atproto-session.ts (line 8). Remove server determination logic that defaults organizations to SDS (lines 19-26). Simplify to always use PDS. Remove comment about SDS default for organizations (line 23). This task depends on hypercerts-jw5.2 (type definition updates) because we need the types updated first.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:36.812241339+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:03:28.27736993+06:00","closed_at":"2026-02-13T11:03:28.27736993+06:00","close_reason":"Completed: f904aed717e18e851fcd2d6e590836fa9b7dc689","dependencies":[{"issue_id":"hypercerts-jw5.3","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:57:36.814164408+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.3","depends_on_id":"hypercerts-jw5.2","type":"blocks","created_at":"2026-02-13T10:58:36.651339481+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.4","title":"Update SDK initialization to remove SDS","description":"Remove 'sds: config.sdsUrl' from SDK server configuration in lib/hypercerts-sdk.ts (line 39). Update SDK initialization to only use PDS. This task depends on hypercerts-jw5.1 (environment config removal) because we need config.sdsUrl removed first.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:41.609155705+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:03:51.936722151+06:00","closed_at":"2026-02-13T11:03:51.936722151+06:00","close_reason":"Completed: 0ee8d8c967f42b720a0203022ce99e33647cb12a","dependencies":[{"issue_id":"hypercerts-jw5.4","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:57:41.611008192+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.4","depends_on_id":"hypercerts-jw5.1","type":"blocks","created_at":"2026-02-13T10:58:36.701434689+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.5","title":"Delete organization pages","description":"Delete the entire app/organizations/ directory, which includes: page.tsx (organization list), [orgDid]/page.tsx (organization detail), create/page.tsx (create organization), create/layout.tsx, loading.tsx, and [orgDid]/loading.tsx. This task depends on hypercerts-jw5.3 (session management simplification) because those files use the serverOverride parameter that will be removed.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:46.81007388+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:04:11.172066695+06:00","closed_at":"2026-02-13T11:04:11.172066695+06:00","close_reason":"Completed: 3428fe02f55fe17c9193be3d78e01b24903474a5","dependencies":[{"issue_id":"hypercerts-jw5.5","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:57:46.811920897+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.5","depends_on_id":"hypercerts-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:36.75669208+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.6","title":"Delete organization components","description":"Delete organization-related components: components/organization-form.tsx, components/organization-detail-view.tsx, components/organization-creation-success.tsx, components/collaborators-list-view.tsx, components/add-contributors-form.tsx. Remove any imports of these components from other files. This task can run in parallel with hypercerts-jw5.5 (delete pages) since they are independent.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:52.089516982+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:02:17.815171991+06:00","closed_at":"2026-02-13T11:02:17.815171991+06:00","close_reason":"Completed: 4299fe74ca5d3a6bc7dcd16db4478e21495c7e5c","dependencies":[{"issue_id":"hypercerts-jw5.6","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:57:52.091170987+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.7","title":"Delete organization queries","description":"Delete the entire queries/organizations/ directory, which includes use-check-handle-query.ts and index.ts. Also remove checkHandleAvailability function from lib/api/external/bluesky.ts (lines 42-60) that checks handle availability on SDS server. This task can run in parallel with hypercerts-jw5.5 and hypercerts-jw5.6.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:57:57.491629768+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:02:44.401504275+06:00","closed_at":"2026-02-13T11:02:44.401504275+06:00","close_reason":"Completed: f20bf2f4eb234d67c9e06a9b71b103be938c90f9","dependencies":[{"issue_id":"hypercerts-jw5.7","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:57:57.493747823+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.8","title":"Remove organization operations from create-actions","description":"Remove organization-related functions from lib/create-actions.ts: lines 202 (create org with serverOverride), 214 (add collaborators), 232 (remove collaborators), 246 (list organizations). This task depends on hypercerts-jw5.3 (session management) because these functions use serverOverride parameter.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:58:02.724974343+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:07:24.646163697+06:00","closed_at":"2026-02-13T11:07:24.646163697+06:00","close_reason":"Completed: 8b6439f","dependencies":[{"issue_id":"hypercerts-jw5.8","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:58:02.726703099+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.8","depends_on_id":"hypercerts-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:36.812943121+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-jw5.9","title":"Simplify blob utilities to remove SDS URL handling","description":"Remove SDS URL handling from lib/blob-utils.ts (line 25) - simplify blob URL resolution to only use PDS. Remove SDS URL usage from app/hypercerts/[hypercertUri]/page.tsx (line 86) for image blob resolution. This task depends on hypercerts-jw5.1 (environment config) and hypercerts-jw5.5 (delete org pages) because we need config cleaned up and no org pages referencing blobs.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T10:58:09.274201803+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:07:42.730303409+06:00","closed_at":"2026-02-13T11:07:42.730303409+06:00","close_reason":"Completed: Already cleaned up in previous commits","dependencies":[{"issue_id":"hypercerts-jw5.9","depends_on_id":"hypercerts-jw5","type":"parent-child","created_at":"2026-02-13T10:58:09.276322082+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.9","depends_on_id":"hypercerts-jw5.1","type":"blocks","created_at":"2026-02-13T10:58:36.863175646+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-jw5.9","depends_on_id":"hypercerts-jw5.5","type":"blocks","created_at":"2026-02-13T10:58:36.913677646+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-l3s","title":"Epic: Certified Email-First Auth (Option A1)","description":"## Goal\nImplement Option A1 from docs/architecture-decision-certified-email-auth.md: passwordless email login for Certified apps using a stock (unmodified) PDS at certified.app.\n\n## Context\nUsers currently see 'enter your handle' and leave. We need: email → OTP code → they're in. No handles, no passwords, no 'what's a PDS.' Sign-up and sign-in are identical from the user's perspective.\n\n## Architecture (Option A1)\nA separate Certified backend service handles the passwordless UX:\n1. User enters email on our app\n2. Backend generates OTP, sends via email\n3. User enters code, backend validates\n4. Backend authenticates against the stock PDS using an auto-generated password the user never sees\n5. On sign-up: backend calls com.atproto.server.createAccount with a random password, stores it encrypted\n6. After OTP validation: backend initiates the ATProto OAuth flow server-side using the hidden password\n7. User sees OAuth consent screen, approves, gets redirected back\n\n## Hard Constraints\n- NO PDS fork — stock PDS only, all logic in our application layer\n- NO sidecar — no wrapping/intercepting PDS internals\n- NO modifying PDS source code\n- The PDS stays vanilla and upgradeable\n- Talk to PDS only via its public XRPC API\n\n## What Success Looks Like\nUser on Ma Earth clicks 'Sign in with Certified' → enters email → gets OTP → enters code → approves OAuth consent → redirected back, logged in. Sign-up is identical (auto-creates account if email unknown).\n\n## Scope\nAuth only. Org/RBAC is a separate parallel workstream.\n\n## Reference\nSee docs/architecture-decision-certified-email-auth.md for full architecture decision document.","status":"closed","priority":1,"issue_type":"epic","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T16:05:21.16283+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.096751+08:00","closed_at":"2026-02-18T17:09:26.096751+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:medium"]}
{"id":"hypercerts-l3s.1","title":"Set up credential store schema and encryption utilities","description":"## Files\n- lib/auth/credential-store.ts (create)\n- lib/auth/encryption.ts (create)\n\n## What to do\nCreate the credential store that maps email → {did, handle, encryptedPassword} and the encryption utilities for storing auto-generated PDS passwords.\n\n### credential-store.ts\n- Use Redis (already available in the project via lib/config.ts redis config) to store user credentials\n- Key pattern: `certified:user:{email}` → JSON object: `{ did: string, handle: string, encryptedPassword: string, createdAt: string }`\n- Key pattern: `certified:did:{did}` → email (reverse lookup)\n- Export functions:\n  - `storeUserCredentials(email: string, did: string, handle: string, password: string): Promise\u003cvoid\u003e` — encrypts password before storing\n  - `getUserByEmail(email: string): Promise\u003c{ did: string, handle: string, encryptedPassword: string } | null\u003e`\n  - `getUserByDid(did: string): Promise\u003c{ email: string, did: string, handle: string, encryptedPassword: string } | null\u003e`\n  - `getDecryptedPassword(email: string): Promise\u003cstring | null\u003e` — retrieves and decrypts the password\n  - `userExists(email: string): Promise\u003cboolean\u003e`\n\n### encryption.ts\n- Use Node.js built-in `crypto` module (no new dependencies)\n- AES-256-GCM encryption/decryption\n- Encryption key from env var `CREDENTIAL_ENCRYPTION_KEY` (32-byte hex string)\n- Export functions:\n  - `encrypt(plaintext: string): string` — returns `iv:authTag:ciphertext` (all hex-encoded)\n  - `decrypt(encrypted: string): string` — parses and decrypts\n  - `generatePassword(): string` — generates a cryptographically random 32-char password using `crypto.randomBytes`\n\n## Don't\n- Don't use any external encryption libraries — Node.js crypto is sufficient\n- Don't store passwords in plaintext\n- Don't use a separate database — use the existing Redis instance\n- Don't import from or depend on the PDS codebase","acceptance_criteria":"1. encrypt() produces a string that decrypt() can reverse to the original plaintext\n2. generatePassword() returns a 32-character string of hex characters\n3. storeUserCredentials() stores encrypted (not plaintext) password in Redis\n4. getUserByEmail() returns null for unknown emails, correct data for known ones\n5. getDecryptedPassword() returns the original plaintext password\n6. Reverse lookup getUserByDid() works correctly\n7. CREDENTIAL_ENCRYPTION_KEY env var is validated on import (throws if missing or wrong length)\n8. All functions are properly typed with TypeScript","status":"closed","priority":1,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T16:05:48.357409+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.728803+08:00","closed_at":"2026-02-18T17:09:29.728803+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-l3s.1","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:05:48.36201+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-l3s.1","depends_on_id":"hypercerts-l3s.7","type":"blocks","created_at":"2026-02-18T16:08:24.692104+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-l3s.2","title":"Build OTP generation, validation, and email sending service","description":"## Files\n- lib/auth/otp-service.ts (create)\n- lib/auth/email-sender.ts (create)\n\n## What to do\nBuild the OTP service that generates codes, stores them in Redis with expiry, validates them, and sends them via email.\n\n### otp-service.ts\n- OTP codes: 6-digit numeric strings (zero-padded)\n- Generate using `crypto.randomInt(0, 999999)`\n- Store in Redis with key pattern: `certified:otp:{email}` → JSON: `{ code: string, attempts: number, createdAt: number }`\n- TTL: 10 minutes (configurable via `OTP_TTL_SECONDS` env var, default 600)\n- Max attempts per code: 5 (configurable via `OTP_MAX_ATTEMPTS` env var, default 5)\n- Rate limiting: max 3 OTP requests per email per 15 minutes. Use Redis key `certified:otp-rate:{email}` with TTL 900s, increment on each send\n- Export functions:\n  - `generateAndSendOTP(email: string): Promise\u003c{ success: boolean, error?: string }\u003e` — generates code, stores in Redis, sends email. Returns error if rate limited.\n  - `validateOTP(email: string, code: string): Promise\u003c{ valid: boolean, error?: string }\u003e` — checks code, increments attempt counter, deletes on success. Returns error if expired or max attempts exceeded.\n  - `invalidateOTP(email: string): Promise\u003cvoid\u003e` — deletes the OTP (used after successful auth)\n\n### email-sender.ts\n- Use Nodemailer (add `nodemailer` + `@types/nodemailer` as dependencies)\n- Configure via env var `SMTP_URL` (standard Nodemailer connection string, e.g. `smtps://user:pass@smtp.example.com`)\n- `FROM_EMAIL` env var for sender address (default: `noreply@certified.app`)\n- Export function:\n  - `sendOTPEmail(to: string, code: string): Promise\u003cvoid\u003e`\n- Email template: simple HTML with the 6-digit code prominently displayed. Subject: 'Your Certified login code'. Body: 'Your verification code is: {code}. It expires in 10 minutes. If you didn't request this, ignore this email.'\n- Log email sends (but not the code itself) for debugging\n\n## Don't\n- Don't use any OTP library — the logic is simple enough to implement directly\n- Don't store OTP codes without expiry\n- Don't log the actual OTP code in production (only in development mode)\n- Don't allow unlimited OTP attempts (must enforce max attempts)\n- Don't skip rate limiting","acceptance_criteria":"1. generateAndSendOTP() creates a 6-digit code and stores it in Redis with correct TTL\n2. validateOTP() returns valid:true for correct code within TTL and attempt limit\n3. validateOTP() returns valid:false with error for wrong code, expired code, or exceeded attempts\n4. validateOTP() deletes the OTP from Redis on successful validation\n5. Rate limiting blocks more than 3 OTP requests per email per 15 minutes\n6. sendOTPEmail() sends an email via SMTP with the code in the body\n7. OTP codes are not logged in production mode\n8. All env vars (SMTP_URL, FROM_EMAIL) are validated on import\n9. nodemailer is added to package.json dependencies","status":"closed","priority":1,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T16:06:08.090862+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.731903+08:00","closed_at":"2026-02-18T17:09:29.731903+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-l3s.2","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:06:08.092285+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-l3s.2","depends_on_id":"hypercerts-l3s.7","type":"blocks","created_at":"2026-02-18T16:08:24.847074+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-l3s.3","title":"Build PDS account management service (create account, create session)","description":"## Files\n- lib/auth/pds-account-service.ts (create)\n\n## What to do\nCreate a service that talks to the stock PDS via its public XRPC API to create accounts and sessions. This is the bridge between our OTP layer and the PDS.\n\n### pds-account-service.ts\nUses the `@atproto/api` package (already in package.json) to call PDS XRPC endpoints.\n\n- PDS URL from existing `config.pdsUrl` (lib/config.ts)\n- Export functions:\n\n#### createAccount\n`createPdsAccount(email: string, password: string): Promise\u003c{ did: string, handle: string, accessJwt: string, refreshJwt: string }\u003e`\n- Calls `com.atproto.server.createAccount` on the PDS\n- Handle generation: extract local part of email (before @), sanitize to alphanumeric + hyphens only, lowercase. If collision (PDS returns error), append random 4-digit suffix and retry (max 3 retries).\n- The handle format is `{localpart}.{pds-hostname}` — e.g. for email `alice@example.com` on PDS `certified.app`, handle = `alice.certified.app`\n- Pass the email and password to createAccount\n- Return the DID, handle, accessJwt, refreshJwt from the PDS response\n\n#### createSession\n`createPdsSession(identifier: string, password: string): Promise\u003c{ did: string, handle: string, accessJwt: string, refreshJwt: string }\u003e`\n- Calls `com.atproto.server.createSession` on the PDS\n- `identifier` can be a DID or handle\n- Returns the session tokens\n\n#### describeServer\n`describePdsServer(): Promise\u003c{ availableUserDomains: string[], inviteCodeRequired: boolean }\u003e`\n- Calls `com.atproto.server.describeServer` to check PDS configuration\n- Used to verify the PDS is reachable and get available user domains for handle generation\n\n### Error handling\n- Wrap XRPC errors in typed errors: `PdsAccountError` with fields `{ code: string, message: string, status: number }`\n- Handle specific error codes: `HandleNotAvailable`, `InvalidHandle`, `AccountTakedown`, network errors\n- Log errors with context but never log passwords\n\n## Don't\n- Don't import PDS internals — only use the public `@atproto/api` client (`AtpAgent`)\n- Don't cache sessions — each call creates a fresh session\n- Don't modify the PDS in any way\n- Don't use admin endpoints — only public XRPC endpoints\n- Don't hardcode the PDS URL — use config.pdsUrl","acceptance_criteria":"1. createPdsAccount() calls com.atproto.server.createAccount via XRPC and returns {did, handle, accessJwt, refreshJwt}\n2. Handle generation sanitizes email local part correctly (alice@example.com → alice.{pds-domain})\n3. Handle collision retry works (appends random suffix, max 3 retries)\n4. createPdsSession() calls com.atproto.server.createSession and returns session tokens\n5. describePdsServer() returns PDS server description\n6. XRPC errors are wrapped in typed PdsAccountError\n7. Passwords are never logged\n8. Uses AtpAgent from @atproto/api (already in package.json, no new deps needed)\n9. PDS URL comes from config.pdsUrl, not hardcoded","status":"closed","priority":1,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T16:06:30.962242+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.081943+08:00","closed_at":"2026-02-18T17:09:26.081943+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-l3s.3","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:06:30.963484+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-l3s.4","title":"Build unified auth orchestrator (sign-up + sign-in via OTP)","description":"## Files\n- lib/auth/auth-orchestrator.ts (create)\n\n## What to do\nCreate the orchestrator that ties together the OTP service, credential store, and PDS account service into the unified sign-up/sign-in flow described in the architecture doc. Sign-up and sign-in are identical from the user's perspective.\n\n### auth-orchestrator.ts\nThis is the main entry point for the auth flow. It coordinates the other services.\n\n#### Flow: Request OTP\n`requestOTP(email: string): Promise\u003c{ success: boolean, isNewUser: boolean, error?: string }\u003e`\n1. Validate email format (basic regex: contains @ and a dot after @)\n2. Normalize email: lowercase, trim whitespace\n3. Check if user exists in credential store (getUserByEmail)\n4. Call generateAndSendOTP(email) from otp-service\n5. Return success + whether this is a new user (informational only — flow is identical either way)\n\n#### Flow: Verify OTP and authenticate\n`verifyOTPAndAuthenticate(email: string, code: string): Promise\u003c{ success: boolean, did: string, handle: string, error?: string }\u003e`\n1. Call validateOTP(email, code) from otp-service\n2. If invalid, return error\n3. If valid, check if user exists in credential store:\n   - **Existing user**: retrieve decrypted password, call createPdsSession(did, password) to verify PDS account still works\n   - **New user**: generate password via generatePassword(), call createPdsAccount(email, password), store credentials via storeUserCredentials(email, did, handle, password)\n4. Return { success: true, did, handle }\n\n#### Flow: Get OAuth authorize URL\n`getOAuthAuthorizeUrl(did: string): Promise\u003cstring\u003e`\n1. Use the existing SDK (`lib/hypercerts-sdk.ts`) to call `sdk.authorize(config.pdsUrl)`\n2. This returns the PDS OAuth authorize URL that the user should be redirected to\n3. The PDS will show its consent screen (the user already authenticated via OTP, so this is just consent)\n\nNote: The tricky part is that the PDS OAuth flow normally requires the user to enter handle+password on the PDS login form. Since we've already verified the user via OTP, we need the user to complete the PDS login form using their hidden credentials. There are two approaches:\n- **Approach 1 (simpler)**: After OTP verification, redirect user to PDS OAuth authorize URL. The PDS shows its login form. We pre-fill or auto-submit the form with the hidden credentials. This requires client-side JS to interact with the PDS login page — fragile.\n- **Approach 2 (recommended)**: After OTP verification, the backend creates a PDS session (createSession), then uses that session to programmatically complete the OAuth authorization. The user only sees the consent screen.\n\nFor now, implement the simpler version: after OTP verification, return the user's DID and handle. The frontend will initiate the OAuth flow via `sdk.authorize(config.pdsUrl)`, and the user will need to complete the PDS login form. We'll address the UX gap (user seeing PDS password form) in a follow-up task.\n\n**Important**: Document this UX gap clearly in a code comment. The architecture doc's ideal flow (steps 2-6) assumes the user never sees a password form, but achieving that requires either intercepting the PDS OAuth flow or building a custom OAuth provider — both of which are out of scope for this task.\n\n## Don't\n- Don't build a custom OAuth provider\n- Don't modify the PDS\n- Don't try to programmatically fill in the PDS login form (fragile, will break)\n- Don't skip email validation\n- Don't allow OTP verification without a prior OTP request","acceptance_criteria":"1. requestOTP() validates email format and rejects invalid emails\n2. requestOTP() normalizes email to lowercase\n3. requestOTP() returns isNewUser correctly based on credential store lookup\n4. verifyOTPAndAuthenticate() creates a new PDS account for unknown emails\n5. verifyOTPAndAuthenticate() retrieves stored credentials for known emails\n6. verifyOTPAndAuthenticate() stores credentials in credential store after new account creation\n7. verifyOTPAndAuthenticate() returns {did, handle} on success\n8. verifyOTPAndAuthenticate() returns error on invalid OTP\n9. The UX gap (user seeing PDS login form) is documented in a code comment\n10. No PDS modifications, no custom OAuth provider","status":"closed","priority":1,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T16:07:00.532776+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.735282+08:00","closed_at":"2026-02-18T17:09:29.735282+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-l3s.4","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:07:00.533767+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-l3s.4","depends_on_id":"hypercerts-l3s.1","type":"blocks","created_at":"2026-02-18T16:08:24.993909+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-l3s.4","depends_on_id":"hypercerts-l3s.2","type":"blocks","created_at":"2026-02-18T16:08:25.178576+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-l3s.4","depends_on_id":"hypercerts-l3s.3","type":"blocks","created_at":"2026-02-18T16:08:25.296417+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-l3s.5","title":"Create API routes for OTP auth flow","description":"## Files\n- app/api/auth/otp/request/route.ts (create)\n- app/api/auth/otp/verify/route.ts (create)\n\n## What to do\nCreate Next.js API routes that expose the OTP auth flow to the frontend.\n\n### POST /api/auth/otp/request\nRequest body: `{ email: string }`\nResponse 200: `{ success: true, isNewUser: boolean }`\nResponse 400: `{ error: 'Invalid email format' }`\nResponse 429: `{ error: 'Too many requests. Try again later.' }`\nResponse 500: `{ error: 'Failed to send verification code' }`\n\nImplementation:\n1. Parse and validate request body (email is required, must be a string)\n2. Call `requestOTP(email)` from auth-orchestrator\n3. Return appropriate response based on result\n\n### POST /api/auth/otp/verify\nRequest body: `{ email: string, code: string }`\nResponse 200: `{ success: true, did: string, handle: string, authUrl: string }`\nResponse 400: `{ error: 'Invalid or expired code' }` or `{ error: 'Too many attempts' }`\nResponse 500: `{ error: 'Authentication failed' }`\n\nImplementation:\n1. Parse and validate request body (email and code are required)\n2. Call `verifyOTPAndAuthenticate(email, code)` from auth-orchestrator\n3. If successful, call `sdk.authorize(config.pdsUrl)` to get the OAuth authorize URL (same pattern as existing app/api/auth/login/route.ts)\n4. Return the authUrl along with did and handle\n\n### Shared concerns\n- Both routes are POST-only (return 405 for other methods — Next.js handles this automatically by only exporting POST)\n- Use standard Next.js 16 route handler patterns (see existing routes in app/api/auth/ for reference)\n- Import from `@/lib/auth/auth-orchestrator`\n- Import sdk from `@/lib/hypercerts-sdk` (for the authorize call in verify)\n- Log errors server-side but don't expose internal details to the client\n\n## Don't\n- Don't add authentication middleware to these routes (they ARE the auth flow)\n- Don't return internal error details to the client\n- Don't use GET methods for these routes (they mutate state)\n- Don't duplicate logic from auth-orchestrator — just call it","acceptance_criteria":"1. POST /api/auth/otp/request accepts {email} and returns {success, isNewUser}\n2. POST /api/auth/otp/request returns 400 for missing/invalid email\n3. POST /api/auth/otp/request returns 429 when rate limited\n4. POST /api/auth/otp/verify accepts {email, code} and returns {success, did, handle, authUrl}\n5. POST /api/auth/otp/verify returns 400 for invalid/expired code\n6. POST /api/auth/otp/verify returns authUrl from sdk.authorize(config.pdsUrl)\n7. Both routes follow the same patterns as existing routes in app/api/auth/\n8. Internal errors are logged but not exposed to client\n9. TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T16:07:19.552259+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.737406+08:00","closed_at":"2026-02-18T17:09:29.737406+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-l3s.5","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:07:19.553674+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-l3s.5","depends_on_id":"hypercerts-l3s.4","type":"blocks","created_at":"2026-02-18T16:08:25.397689+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-l3s.6","title":"Build email-first login UI (replace handle input with email+OTP flow)","description":"## Files\n- components/email-login-dialog.tsx (create)\n- queries/otp-auth.ts (create)\n- components/login-dialog.tsx (modify — add toggle or replace)\n\n## What to do\nCreate a new email-first login component that implements the OTP flow, and wire it into the app.\n\n### queries/otp-auth.ts\nCreate React Query mutation hooks for the OTP API routes:\n\n```typescript\n// Hook: useRequestOTP\n// Calls POST /api/auth/otp/request with { email }\n// Returns mutation with { success, isNewUser } on success\n\n// Hook: useVerifyOTP\n// Calls POST /api/auth/otp/verify with { email, code }\n// On success: redirects to authUrl (same pattern as useLoginMutation in queries/auth.ts)\n```\n\nFollow the same patterns as the existing `queries/auth.ts` file.\n\n### components/email-login-dialog.tsx\nA multi-step login form with two states:\n\n**Step 1: Email input**\n- Header: 'Sign In' (same as current)\n- Subtext: 'Enter your email to continue'\n- Email input field (type=email, placeholder='alice@example.com')\n- 'Continue' button → calls useRequestOTP\n- Loading state while sending OTP\n- Error display for invalid email or rate limiting\n\n**Step 2: OTP code input**\n- Header: 'Check your email'\n- Subtext: 'We sent a 6-digit code to {email}'\n- 6-digit code input field (type=text, inputMode=numeric, maxLength=6, autoFocus)\n- 'Verify' button → calls useVerifyOTP\n- 'Use a different email' link → goes back to step 1\n- 'Resend code' button (disabled for 30 seconds after send, then enabled)\n- Loading state while verifying\n- Error display for invalid code or too many attempts\n\n**Styling**: Use the same Shadcn/ui components and Tailwind classes as the existing login-dialog.tsx. Match the existing visual style (glass-panel, create-accent colors, font-outfit, font-syne, animate-fade-in-up).\n\n### components/login-dialog.tsx (modify)\n- Add an 'Or sign in with ATProto handle' link/button below the email form that shows the existing handle-based login (for ecosystem interop, as mentioned in the architecture doc)\n- OR: Replace the default view with EmailLoginDialog and add a toggle to switch to handle-based login\n- The handle-based login should still work exactly as before\n\n## Don't\n- Don't remove the existing handle-based login — keep it as a fallback\n- Don't change the existing OAuth callback flow (app/api/auth/callback/route.ts)\n- Don't add new UI libraries — use existing Shadcn/ui components\n- Don't auto-submit the OTP form (let the user click Verify)\n- Don't show the PDS password to the user anywhere","acceptance_criteria":"1. EmailLoginDialog renders with email input on step 1\n2. Submitting email calls POST /api/auth/otp/request\n3. After successful OTP request, transitions to step 2 (code input)\n4. Submitting code calls POST /api/auth/otp/verify\n5. On successful verify, redirects to authUrl (user goes to PDS OAuth consent)\n6. Error states display correctly (invalid email, rate limit, wrong code, too many attempts)\n7. 'Resend code' button works with 30-second cooldown\n8. 'Use a different email' link returns to step 1\n9. Handle-based login is still accessible as a fallback option\n10. Visual style matches existing login-dialog.tsx (same components, colors, fonts)\n11. TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T16:07:44.112169+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.739338+08:00","closed_at":"2026-02-18T17:09:29.739338+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-l3s.6","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:07:44.113579+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-l3s.6","depends_on_id":"hypercerts-l3s.5","type":"blocks","created_at":"2026-02-18T16:08:25.503365+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-l3s.7","title":"Update environment configuration for OTP auth","description":"## Files\n- .env.example (modify)\n- lib/config.ts (modify)\n\n## What to do\nAdd the new environment variables needed for the OTP auth flow to the config system.\n\n### .env.example (modify)\nAdd a new section after the existing 'Redis Configuration' section:\n\n```\n# -----------------------------\n# Certified Email Auth (OTP)\n# -----------------------------\n# Encryption key for storing auto-generated PDS passwords\n# Must be a 64-character hex string (32 bytes)\n# Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"\nCREDENTIAL_ENCRYPTION_KEY=\n\n# SMTP configuration for sending OTP emails\n# Format: smtps://user:pass@smtp.example.com\nSMTP_URL=\n\n# Sender email address for OTP emails\nFROM_EMAIL=noreply@certified.app\n\n# OTP configuration (optional, defaults shown)\n# OTP_TTL_SECONDS=600\n# OTP_MAX_ATTEMPTS=5\n```\n\n### lib/config.ts (modify)\nAdd the new env vars to the config object and validation:\n\n1. Add to the `config` object:\n   - `credentialEncryptionKey: process.env.CREDENTIAL_ENCRYPTION_KEY!`\n   - `smtpUrl: process.env.SMTP_URL!`\n   - `fromEmail: process.env.FROM_EMAIL || 'noreply@certified.app'`\n   - `otpTtlSeconds: parseInt(process.env.OTP_TTL_SECONDS || '600', 10)`\n   - `otpMaxAttempts: parseInt(process.env.OTP_MAX_ATTEMPTS || '5', 10)`\n\n2. Add `CREDENTIAL_ENCRYPTION_KEY` and `SMTP_URL` to the `requiredEnvVars` array\n\n3. Add validation for CREDENTIAL_ENCRYPTION_KEY: must be exactly 64 hex characters. Throw a descriptive error if not.\n\n4. Add to the startup log:\n   - `SMTP: configured` (don't log the actual URL — it contains credentials)\n   - `OTP TTL: {otpTtlSeconds}s`\n\n## Don't\n- Don't log SMTP_URL or CREDENTIAL_ENCRYPTION_KEY values\n- Don't change existing config values or behavior\n- Don't remove any existing env vars\n- Don't add the actual secret values to .env.example","acceptance_criteria":"1. .env.example has new section with CREDENTIAL_ENCRYPTION_KEY, SMTP_URL, FROM_EMAIL, OTP_TTL_SECONDS, OTP_MAX_ATTEMPTS\n2. .env.example includes generation command for CREDENTIAL_ENCRYPTION_KEY\n3. config object has all new fields (credentialEncryptionKey, smtpUrl, fromEmail, otpTtlSeconds, otpMaxAttempts)\n4. CREDENTIAL_ENCRYPTION_KEY is validated as 64 hex chars on startup\n5. CREDENTIAL_ENCRYPTION_KEY and SMTP_URL are in requiredEnvVars\n6. Startup log shows SMTP configured status and OTP TTL without leaking secrets\n7. Existing config values and behavior are unchanged\n8. TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":20,"created_at":"2026-02-18T16:08:04.733181+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.092782+08:00","closed_at":"2026-02-18T17:09:26.092782+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-l3s.7","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:08:04.73518+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-l3s.8","title":"Clean up old pds-sidecar artifacts","description":"## Files\n- packages/pds-sidecar/ (delete entire directory)\n- .gitmodules (modify if it references pds-sidecar)\n\n## What to do\nDelete the old `packages/pds-sidecar/` directory. It contains only orphaned compiled JS files from an old prototype — no source code, no package.json, no tsconfig. It's dead code that confuses anyone reading the repo.\n\n1. Delete the entire `packages/pds-sidecar/` directory\n2. Check `.gitmodules` — if it references pds-sidecar, remove that entry\n3. Check `package.json` at root — if it has any workspace references to pds-sidecar, remove them\n4. If `packages/` directory is now empty, leave it (other packages may be added later)\n\n## Don't\n- Don't delete anything outside of packages/pds-sidecar/\n- Don't modify any other package configuration","acceptance_criteria":"1. packages/pds-sidecar/ directory no longer exists\n2. .gitmodules has no pds-sidecar references (if it had any)\n3. Root package.json has no pds-sidecar workspace references (if it had any)\n4. git status shows the deletion cleanly\n5. No other files are modified","status":"closed","priority":2,"issue_type":"task","owner":"sharfy-test.climateai.org","estimated_minutes":10,"created_at":"2026-02-18T16:08:15.90162+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.094467+08:00","closed_at":"2026-02-18T17:09:26.094467+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-l3s.8","depends_on_id":"hypercerts-l3s","type":"parent-child","created_at":"2026-02-18T16:08:15.907237+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-m4o","title":"Epic: Ship Email-First Auth to Production","description":"## Goal\nGet the email-first passwordless auth flow live at certified.app for the Ma Earth grants round. This is the critical path — everything else can follow.\n\n## What Option A1 Is\nOne stock (unmodified) PDS at certified.app. A separate sidecar auth service handles passwordless UX — OTP generation, email sending, code validation — and authenticates against the PDS using auto-generated passwords the user never sees. Apps use oauthClient.authorize('https://certified.app') with login_hint=email. No handle entry needed. The PDS stays vanilla and upgradeable.\n\n## What's Already Built\n- **Scaffold UI** (beads branch): /login page with email input, /api/auth/email-login route, useEmailLoginMutation hook (3 tasks completed: hypercerts-2bf.1, 2bf.2, 2bf.3)\n- **PDS Sidecar** (beads branch): OTP service (8-digit, SHA-256 hashed, 15min expiry, 5 max attempts), rate limiter (per-email, per-IP), HMAC callback signer, mailer, auth-service Express routes (/oauth/authorize, /auth/send-code, /auth/verify-code), PDS core wrapper with OAuth metadata override + magic-callback endpoint (7 tasks completed: hypercerts-qc3.1-7)\n- **Docker Compose** (beads branch): Caddy + PDS + sidecar stack (1 task completed: hypercerts-0yp.1)\n- **Local dev setup** (beads branch): Startup script + .env for PDS at localhost:2583, sidecar at localhost:2584, MailHog at localhost:8025 (1 task completed: hypercerts-mhp.1)\n\n## What's Left (this epic)\n1. Merge all completed work from beads/plan-passwordless-login to this branch\n2. Get the local E2E flow working (hypercerts-mhp.2 is in progress but not done)\n3. Add encrypted credential storage (AES-256-GCM for auto-generated passwords)\n4. Add security headers + production error handling to sidecar\n5. Update Docker Compose for certified.app domain\n6. Create production .env template + DNS/email deliverability docs\n7. Add 'Sign in with ATProto/Bluesky' handle fallback to /login page\n8. E2E smoke test\n\n## Auth Flow (what the user sees)\n1. On Ma Earth, clicks 'Sign in with Certified'\n2. Redirected to certified.app/oauth/authorize\n3. Enters email address\n4. Receives OTP code via email\n5. Enters code\n6. Approves Ma Earth's access (OAuth consent)\n7. Redirected back to Ma Earth, logged in\n\nSign-up is identical: if email is new, account auto-created (random handle, hidden password).\n\n## Hard Constraints\n- Stock PDS only — no fork of bluesky-social/atproto\n- All passwordless logic in the sidecar, not the PDS\n- Auto-generated passwords encrypted at rest (AES-256-GCM)\n- Sign-up and sign-in visually identical (anti-enumeration)\n- Must ship within days, not weeks","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T15:42:34.248702+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:40.103073+08:00","closed_at":"2026-02-18T15:44:40.103077+08:00","labels":["scope:medium"]}
{"id":"hypercerts-m4o.1","title":"Merge all email-auth work from beads/plan-passwordless-login branch","description":"## Files\n- All files from beads/plan-passwordless-login that aren't on main yet\n\n## What to do\n1. Run `git log main..beads/plan-passwordless-login --oneline` to see all commits to merge\n2. Merge or cherry-pick the beads/plan-passwordless-login branch into the current branch (certified-email-auth-option-a)\n3. Resolve any conflicts\n4. Verify: `pnpm install \u0026\u0026 pnpm build` succeeds\n5. Verify: /login page exists at app/login/page.tsx\n6. Verify: /api/auth/email-login route exists\n7. Verify: packages/pds-sidecar/ has all three sub-packages (shared, auth-service, pds-core)\n8. Verify: packages/pds-sidecar/docker-compose.yml exists\n9. Verify: scripts/start-local-pds.sh (or similar) exists for local dev\n\n## Don't\n- Cherry-pick selectively — merge the whole branch to get everything\n- Modify any of the merged code in this task\n- Skip the build verification","acceptance_criteria":"1. All commits from beads/plan-passwordless-login are on the current branch. 2. pnpm build succeeds. 3. app/login/page.tsx exists. 4. app/api/auth/email-login/route.ts exists. 5. packages/pds-sidecar/packages/{shared,auth-service,pds-core} all exist with dist/ dirs.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":20,"created_at":"2026-02-18T15:42:48.145298+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:40.190543+08:00","closed_at":"2026-02-18T15:44:40.190547+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-m4o.1","depends_on_id":"hypercerts-m4o","type":"parent-child","created_at":"2026-02-18T15:42:48.148206+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-mhp","title":"Epic: Local Test PDS with Sidecar for End-to-End OTP Flow","description":"## Goal\nSet up a local test PDS with the sidecar auth service so we can test the complete email-first passwordless login flow end-to-end on localhost. The user enters their email in the scaffold app → gets redirected to the sidecar → receives an OTP email → enters the code → gets redirected back to the scaffold with an active session.\n\n## Context\nWe have built:\n1. **Scaffold app** (Next.js at `/Users/sharfy/Code/hypercerts-scaffold`) — has a `/login` page with email input that calls `/api/auth/email-login`, which initiates ATProto OAuth with `login_hint=\u003cemail\u003e`. The scaffold runs on `http://127.0.0.1:3000`.\n2. **PDS sidecar** (at `packages/pds-sidecar/`) — contains three packages:\n   - `packages/shared/` — OTP service, rate limiter, HMAC callback signer, mailer, SQLite DB\n   - `packages/auth-service/` — Express app that serves email input + OTP verification pages\n   - `packages/pds-core/` — Wraps stock `@atproto/pds` with OAuth metadata override + magic-callback endpoint\n\nThe sidecar code is built and tests pass (56/56). But we've never run the full stack together. The current Docker Compose setup (`packages/pds-sidecar/docker-compose.yml`) is designed for production with Caddy, real DNS, and TLS — it won't work on localhost.\n\n## What We Need\nA **local development setup** that runs all three services on localhost without Docker, TLS, or real DNS:\n\n```\nScaffold (Next.js)     → http://127.0.0.1:3000\nPDS Core (ATProto PDS) → http://localhost:2583\nAuth Service (sidecar) → http://localhost:2584\nMailHog (fake SMTP)    → SMTP on :1025, Web UI on http://localhost:8025\n```\n\n### How the flow works\n1. User visits `http://127.0.0.1:3000/login`, enters email, clicks Continue\n2. Scaffold POSTs to `/api/auth/email-login` → calls `sdk.authorize('http://localhost:2583')` with `login_hint=email`\n3. SDK does PAR to PDS at `http://localhost:2583`\n4. PDS returns authorization URL → but metadata override rewrites `authorization_endpoint` to `http://localhost:2584/oauth/authorize`\n5. Browser redirects to sidecar at `http://localhost:2584/oauth/authorize?request_uri=...\u0026login_hint=email`\n6. Sidecar auto-sends OTP email via MailHog (SMTP on localhost:1025)\n7. User opens MailHog web UI at `http://localhost:8025`, copies the 8-digit code\n8. User enters code on sidecar's OTP page\n9. Sidecar verifies code, builds HMAC-signed callback URL\n10. Browser redirects to PDS at `http://localhost:2583/oauth/magic-callback?...\u0026sig=HMAC...`\n11. PDS verifies HMAC, creates account if new, issues OAuth auth code\n12. Browser redirects back to scaffold at `http://127.0.0.1:3000/api/auth/callback?code=...\u0026state=...\u0026iss=....`\n13. Scaffold exchanges code for session → user is logged in\n\n### Key Technical Challenges\n1. **ATProto PDS requires specific env vars and crypto keys** — PLC rotation key (secp256k1), JWT secret, admin password. These must be generated.\n2. **The PDS needs to reach the PLC directory** — `https://plc.directory` for DID creation. This requires internet access.\n3. **OAuth client ID for localhost** — The scaffold uses `http://localhost?scope=...` as client ID in dev mode (loopback client). The PDS must accept loopback clients.\n4. **The PDS hostname must match what the scaffold sends** — The scaffold's `NEXT_PUBLIC_PDS_URL` must point to the local PDS.\n5. **The auth service URL in the metadata override must be reachable from the browser** — It's `http://localhost:2584`.\n6. **MailHog for fake SMTP** — No real email provider needed. MailHog captures all emails and shows them in a web UI.\n7. **The `pds-core` wrapper uses PDS internal APIs** — These are accessed via `as any` casts and may not work exactly as expected. This is the riskiest part. If internal APIs don't match, we need to debug and fix.\n\n## Success Criteria\n- All three services start without errors\n- `GET http://localhost:2583/xrpc/_health` returns OK\n- `GET http://localhost:2584/health` returns `{\"status\":\"ok\"}`\n- `GET http://localhost:2583/.well-known/oauth-authorization-server` returns metadata with `authorization_endpoint` pointing to `http://localhost:2584/oauth/authorize`\n- The scaffold at `http://127.0.0.1:3000/login` can complete the full email→OTP→session flow\n- OTP emails appear in MailHog at `http://localhost:8025`","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T19:31:28.411132+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.684411+08:00","closed_at":"2026-02-18T15:50:27.684414+08:00","labels":["scope:medium"]}
{"id":"hypercerts-mhp.1","title":"Create local dev startup script and .env for PDS + sidecar + MailHog","description":"## Files\n- packages/pds-sidecar/scripts/dev-start.sh (create)\n- packages/pds-sidecar/.env.dev (create)\n- packages/pds-sidecar/scripts/generate-pds-keys.mjs (create)\n\n## What to do\nCreate a local development startup script that runs the PDS, auth service, and MailHog together on localhost without Docker or TLS. This is for testing the full email→OTP→session flow locally.\n\n### Architecture\n```\nScaffold (Next.js)     → http://127.0.0.1:3000  (started separately by the developer)\nPDS Core (ATProto PDS) → http://localhost:2583   (started by this script)\nAuth Service (sidecar) → http://localhost:2584   (started by this script)\nMailHog (fake SMTP)    → SMTP on :1025, Web UI on http://localhost:8025 (Docker)\n```\n\n### `scripts/generate-pds-keys.mjs`\nA Node.js script that generates all required crypto keys and outputs them as environment variables. It should:\n1. Generate a PLC rotation key (secp256k1 private key, 64 hex chars). Use `@noble/secp256k1` or `crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' })` and extract the private key as hex. If those don't work, use `crypto.randomBytes(32).toString('hex')` — the PDS will validate it.\n2. Generate a JWT secret: `crypto.randomBytes(32).toString('hex')`\n3. Generate a session secret: `crypto.randomBytes(32).toString('hex')`\n4. Generate a callback secret: `crypto.randomBytes(32).toString('hex')`\n5. Generate an admin password: `crypto.randomBytes(16).toString('hex')`\n6. Print them all as KEY=VALUE lines that can be pasted into .env.dev\n\n### `.env.dev`\nPre-configured environment file for local development. All values should work out of the box EXCEPT the crypto keys (which the developer generates with the script above). Include clear comments.\n\n```env\n# PDS Core\nPDS_HOSTNAME=localhost\nPDS_PORT=2583\nPDS_DATA_DIRECTORY=./data/pds\nPDS_BLOBSTORE_DISK_LOCATION=./data/pds/blobs\nPDS_DID_PLC_URL=https://plc.directory\nPDS_ADMIN_PASSWORD=\u003cgenerated\u003e\nPDS_JWT_SECRET=\u003cgenerated\u003e\nPDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=\u003cgenerated\u003e\n\n# Auth Service\nAUTH_PORT=2584\nAUTH_DB_PATH=./data/auth/auth.sqlite\nSESSION_SECRET=\u003cgenerated\u003e\nCALLBACK_SECRET=\u003cgenerated\u003e\nPDS_URL=http://localhost:2583\nAUTH_SERVICE_URL=http://localhost:2584\n\n# SMTP (MailHog)\nSMTP_HOST=localhost\nSMTP_PORT=1025\nSMTP_SECURE=false\nSMTP_USER=\nSMTP_PASS=\nSMTP_FROM=Hypercerts Scaffold \u003cnoreply@localhost\u003e\n\n# Sidecar DB (used by PDS core)\nSIDECAR_DB_PATH=./data/pds/sidecar.sqlite\n```\n\n### `scripts/dev-start.sh`\nA bash script that:\n1. Checks prerequisites: Node.js \u003e= 20, Docker (for MailHog)\n2. Creates data directories: `./data/pds/blobs`, `./data/auth`\n3. Checks if `.env.dev` has been configured (look for `\u003cgenerated\u003e` placeholder values). If not, run `generate-pds-keys.mjs` and tell the user to paste the output into `.env.dev`.\n4. Loads `.env.dev` into the shell environment\n5. Starts MailHog via Docker: `docker run -d --name mailhog-dev -p 1025:1025 -p 8025:8025 mailhog/mailhog` (skip if already running)\n6. Builds the sidecar packages: `npm run build`\n7. Starts the PDS core in the background: `node packages/pds-core/dist/index.js \u0026`\n8. Waits for PDS health check: poll `http://localhost:2583/xrpc/_health` until it responds (max 30 seconds)\n9. Starts the auth service in the background: `node packages/auth-service/dist/index.js \u0026`\n10. Waits for auth health check: poll `http://localhost:2584/health` until it responds\n11. Prints a summary:\n    ```\n    ✅ All services running:\n       PDS:         http://localhost:2583\n       Auth:        http://localhost:2584\n       MailHog:     http://localhost:8025\n       \n    Next: Start the scaffold app:\n       cd /Users/sharfy/Code/hypercerts-scaffold\n       # Update .env.local: NEXT_PUBLIC_PDS_URL=http://localhost:2583\n       npm run dev\n       # Then visit http://127.0.0.1:3000/login\n    ```\n12. Waits for Ctrl+C, then kills both background processes and stops MailHog\n\nMake the script executable (`chmod +x`).\n\n### Important: PDS_HOSTNAME for localhost\nThe ATProto PDS uses `PDS_HOSTNAME` to determine its issuer URL. For local dev, set it to `localhost`. The PDS will serve on the port specified by `PDS_PORT` env var (which `@atproto/pds` reads from `readEnv()`). Check the PDS source — it may use `PDS_PORT` or default to 2583. If the PDS doesn't read `PDS_PORT`, you may need to set it via the config object in `packages/pds-core/src/index.ts`.\n\n### Important: PDS_PORT configuration\nThe current `packages/pds-core/src/index.ts` uses `readEnv()` + `envToCfg()` from `@atproto/pds`. Check if `PDS_PORT` is read by `readEnv()`. If not, you may need to modify `index.ts` to accept a port override. The PDS default port is 2583.\n\n### Important: AUTH_SERVICE_URL\nThe `AUTH_SERVICE_URL` env var is used by the PDS core's metadata override to rewrite `authorization_endpoint`. For local dev, it must be `http://localhost:2584` — this is the URL the **browser** will be redirected to, so it must be reachable from the developer's machine.\n\n## Don't\n- Don't modify any existing source files unless absolutely necessary (e.g., if PDS_PORT isn't configurable)\n- Don't use Docker for the PDS or auth service — run them directly with Node.js\n- Don't require real DNS or TLS\n- Don't commit actual secret values — use placeholders in .env.dev\n- Don't modify the scaffold app's .env.local (just document what needs to change)","acceptance_criteria":"1. `node scripts/generate-pds-keys.mjs` outputs valid KEY=VALUE pairs for all required secrets\n2. `scripts/dev-start.sh` starts MailHog, PDS, and auth service without errors\n3. `curl http://localhost:2583/xrpc/_health` returns a success response\n4. `curl http://localhost:2584/health` returns `{\"status\":\"ok\"}`\n5. `curl http://localhost:2583/.well-known/oauth-authorization-server` returns JSON with `authorization_endpoint` containing `http://localhost:2584/oauth/authorize`\n6. MailHog web UI is accessible at `http://localhost:8025`\n7. Data directories are created under `./data/`\n8. Ctrl+C cleanly stops all services","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-17T19:32:07.834948+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T19:55:39.722956+08:00","closed_at":"2026-02-17T19:55:39.722956+08:00","close_reason":"508a006 feat: local dev startup script and .env for PDS + sidecar + MailHog","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-mhp.1","depends_on_id":"hypercerts-mhp","type":"parent-child","created_at":"2026-02-17T19:32:07.836725+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-mhp.2","title":"Update scaffold .env.local to point to local test PDS and verify full OTP flow","description":"## Files\n- .env.local (modify — at repo root /Users/sharfy/Code/hypercerts-scaffold/.env.local)\n\n## What to do\nAfter the local PDS + sidecar are running (from the previous task), update the scaffold's `.env.local` to point to the local PDS and test the complete end-to-end flow.\n\n### Step 1: Update .env.local\nChange `NEXT_PUBLIC_PDS_URL` from the remote PDS to the local one:\n```\nNEXT_PUBLIC_PDS_URL=http://localhost:2583\n```\nKeep all other values the same.\n\n### Step 2: Restart the scaffold\n```bash\n# Kill existing dev server if running\nlsof -ti:3000 | xargs kill -9 2\u003e/dev/null\nrm -rf .next\nnpm run dev\n```\n\n### Step 3: Test the full flow\n1. Open `http://127.0.0.1:3000/login` in a browser (or use curl to simulate)\n2. Enter an email address (e.g., `test@example.com`)\n3. The scaffold should redirect to the PDS, which should redirect to the sidecar\n4. The sidecar should send an OTP email to MailHog\n5. Check MailHog at `http://localhost:8025` for the OTP email\n6. Enter the 8-digit code on the sidecar's OTP page\n7. The sidecar should redirect back to the PDS with a signed callback\n8. The PDS should create the account and redirect back to the scaffold\n9. The scaffold should exchange the code for a session\n10. The user should be logged in\n\n### Step 4: Debug and fix any issues\nThe most likely failure points are:\n- **PDS internal API mismatches** — The `magic-callback.ts` and `account-creator.ts` use `as any` casts to access PDS internals. If the API shape doesn't match, you'll get runtime errors. Debug by reading the actual PDS source in `node_modules/@atproto/pds/` and adjusting the code.\n- **OAuth redirect URI mismatch** — The scaffold's redirect URI must match what the PDS expects. Check the error messages.\n- **CORS issues** — The sidecar may need CORS headers for cross-origin requests from the scaffold.\n- **Cookie issues** — The sidecar sets session cookies. These may not work across different localhost ports. May need `SameSite=None` or same-origin setup.\n\n### Step 5: Document what works and what doesn't\nCreate a brief summary of:\n- What worked out of the box\n- What needed fixing (and what the fix was)\n- Any remaining issues\n\n## Don't\n- Don't modify the sidecar code unless there are actual runtime errors that need fixing\n- Don't change the scaffold's auth flow logic\n- Don't commit .env.local to git (it's in .gitignore)","acceptance_criteria":"1. The scaffold at http://127.0.0.1:3000/login shows the email form\n2. Entering an email redirects to the sidecar's OTP page (not the stock PDS password form)\n3. An OTP email appears in MailHog at http://localhost:8025\n4. Entering the correct OTP code completes the OAuth flow\n5. The user is redirected back to the scaffold with an active session\n6. OR: A clear list of what broke and what needs fixing, with specific error messages","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-17T19:32:31.917935+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.565009+08:00","closed_at":"2026-02-18T15:54:59.565012+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-mhp.2","depends_on_id":"hypercerts-mhp","type":"parent-child","created_at":"2026-02-17T19:32:31.919372+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-mhp.2","depends_on_id":"hypercerts-mhp.1","type":"blocks","created_at":"2026-02-17T19:32:31.934553+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-mws","title":"Epic: Sidecar Auth Service (OTP + PDS Wrapper)","description":"## Goal\nBuild a standalone sidecar auth service that runs alongside a stock @atproto/pds to provide email-first passwordless login via OTP codes. This is the core backend for Option A1.\n\n## Architecture (Option A1)\n```\nClient App (scaffold)\n  │\n  │ 1. PAR request to PDS\n  │ 8. Token exchange (stock ATProto)\n  ▼\nStock PDS (@atproto/pds, unmodified npm package)\n  │  OAuth AS metadata overridden:\n  │  authorization_endpoint → sidecar\n  │\n  │ 2. Redirect to sidecar    7. Auth code issued via HMAC-signed callback\n  ▼                            ▲\nSidecar Auth Service (Express.js)\n  GET  /oauth/authorize     ← shows email input (or auto-sends OTP if login_hint present)\n  POST /auth/send-code      ← generates OTP, sends email\n  POST /auth/verify-code    ← validates OTP, builds HMAC callback to PDS\n  │\n  │ 3-5. Sends 8-digit OTP code via email\n  ▼\nUser's inbox\n```\n\n## How It Works\n1. Client calls `sdk.authorize('https://certified.app')` with `login_hint=email`\n2. SDK does PAR to PDS → PDS returns authorization URL\n3. But the PDS's OAuth metadata has been overridden: `authorization_endpoint` points to the sidecar\n4. Browser redirects to sidecar's /oauth/authorize with the PAR request_uri + login_hint\n5. Sidecar sends OTP email, shows code entry form\n6. User enters code → sidecar verifies → builds HMAC-signed callback URL\n7. Browser redirects to PDS's /oauth/magic-callback with signed params\n8. PDS verifies HMAC, creates account if new (random handle + hidden password), issues OAuth auth code\n9. Browser redirects back to client with auth code → client exchanges for tokens\n\n## Key Design Decisions\n- **Wrap, don't fork.** @atproto/pds is an npm dependency, not modified source.\n- **HMAC-SHA256 signed callback** between sidecar and PDS to prevent account takeover.\n- **Unified sign-in/sign-up.** New emails get auto-created; existing emails get authenticated. Both look identical.\n- **Random handles.** New accounts get random handles (e.g., a3x9kf.certified.app) — no email leakage.\n- **8-digit OTP codes.** SHA-256 hashed before storage, single-use, 15-min expiry, max 5 attempts.\n- **Auto-generated passwords.** Users never see a password. Backend generates 128-char hex passwords, encrypts with AES-256-GCM, stores server-side.\n\n## Project Structure\n```\npackages/pds-sidecar/\n  package.json              ← root workspace\n  tsconfig.json\n  docker-compose.yml        ← Caddy + PDS + sidecar\n  Caddyfile\n  .env.example\n  scripts/\n    start-local.sh          ← local dev: PDS + sidecar + MailHog\n  packages/\n    shared/                 ← DB, OTP service, rate limiter, HMAC signer, mailer, credential store\n    auth-service/           ← Express app (routes, middleware, templates)\n    pds-core/               ← PDS wrapper (metadata override, magic-callback, account creator)\n```\n\n## What Exists on Main\npackages/pds-sidecar/ has compiled dist/ files from a previous prototype but NO source code, NO package.json, NO tsconfig. The dist/ files can be used as reference for the implementation but everything must be built from scratch as a proper TypeScript project.\n\n## Hard Constraints\n- Stock @atproto/pds as npm dependency — NO fork\n- All passwordless logic in the sidecar\n- Auto-generated passwords encrypted at rest (AES-256-GCM)\n- SQLite for sidecar data (OTP tokens, accounts, credentials)\n- Must work on localhost for development (no TLS required locally)","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T15:45:22.366037+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.496736+08:00","closed_at":"2026-02-18T15:54:59.496738+08:00","labels":["scope:medium"]}
{"id":"hypercerts-mws.1","title":"Initialize sidecar monorepo with TypeScript project structure","description":"## Files\n- packages/pds-sidecar/package.json (create)\n- packages/pds-sidecar/tsconfig.json (create)\n- packages/pds-sidecar/packages/shared/package.json (create)\n- packages/pds-sidecar/packages/shared/tsconfig.json (create)\n- packages/pds-sidecar/packages/shared/src/index.ts (create)\n- packages/pds-sidecar/packages/auth-service/package.json (create)\n- packages/pds-sidecar/packages/auth-service/tsconfig.json (create)\n- packages/pds-sidecar/packages/auth-service/src/index.ts (create)\n- packages/pds-sidecar/packages/pds-core/package.json (create)\n- packages/pds-sidecar/packages/pds-core/tsconfig.json (create)\n- packages/pds-sidecar/packages/pds-core/src/index.ts (create)\n- packages/pds-sidecar/.env.example (create)\n\n## What to do\nDelete the existing orphaned dist/ files in packages/pds-sidecar/ and create a proper TypeScript monorepo from scratch.\n\n1. Remove packages/pds-sidecar/packages/*/dist/ directories and packages/pds-sidecar/data/ directory\n2. Create root package.json with pnpm workspaces pointing to packages/*\n3. Create root tsconfig.json with project references\n4. Create each sub-package with:\n   - package.json (name: @certified/shared, @certified/auth-service, @certified/pds-core)\n   - tsconfig.json extending root, outputting to dist/\n   - src/index.ts with a placeholder export\n5. Dependencies to install:\n   - shared: better-sqlite3, @types/better-sqlite3, nodemailer, @types/nodemailer, pino\n   - auth-service: express, @types/express, cookie-parser, @types/cookie-parser, @certified/shared (workspace:*)\n   - pds-core: @atproto/pds, @atproto/api, @certified/shared (workspace:*)\n   - All: typescript, vitest (devDependencies)\n6. Create .env.example listing all required env vars with comments\n7. Add build/test/dev scripts to root package.json\n8. Verify: `pnpm install \u0026\u0026 pnpm build` succeeds from packages/pds-sidecar/\n\n## Don't\n- Keep any old dist/ files — delete them all\n- Use npm or yarn — this is a pnpm workspace\n- Add any business logic yet — just project scaffolding\n- Add docker-compose yet — that's a separate task","acceptance_criteria":"1. pnpm install succeeds in packages/pds-sidecar/. 2. pnpm build compiles all three packages. 3. Each package has src/index.ts and outputs to dist/. 4. @certified/auth-service can import from @certified/shared. 5. @certified/pds-core can import from @certified/shared. 6. Old dist/ files are gone. 7. .env.example exists.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T15:45:41.340562+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.42796+08:00","closed_at":"2026-02-18T15:54:59.427962+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-mws.1","depends_on_id":"hypercerts-mws","type":"parent-child","created_at":"2026-02-18T15:45:41.341839+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-mws.2","title":"Implement shared package: DB, OTP service, rate limiter, credential store, HMAC signer, mailer","description":"## Files\n- packages/pds-sidecar/packages/shared/src/db.ts (create)\n- packages/pds-sidecar/packages/shared/src/otp-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/rate-limiter.ts (create)\n- packages/pds-sidecar/packages/shared/src/credential-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/callback-signer.ts (create)\n- packages/pds-sidecar/packages/shared/src/mailer.ts (create)\n- packages/pds-sidecar/packages/shared/src/logger.ts (create)\n- packages/pds-sidecar/packages/shared/src/types.ts (create)\n- packages/pds-sidecar/packages/shared/src/index.ts (modify — re-export all)\n- packages/pds-sidecar/packages/shared/src/*.test.ts (create tests for each)\n\n## What to do\nImplement all shared services. Use the compiled JS files in the OLD dist/ directories as reference (they contain the exact logic from the previous prototype). The old dist/ files were deleted in the previous task, but their content is documented here.\n\n### db.ts — SQLite database setup\n- Initialize better-sqlite3 database\n- Create tables on init:\n  ```sql\n  otp_tokens (id INTEGER PK, email TEXT, token_hash TEXT, attempts INT, max_attempts INT, expires_at TEXT, used INT, created_at TEXT DEFAULT datetime('now'))\n  accounts (email TEXT PK, did TEXT UNIQUE, handle TEXT, email_verified INT DEFAULT 0, created_at TEXT, updated_at TEXT)\n  credentials (did TEXT PK, encrypted_password TEXT, iv TEXT, auth_tag TEXT, created_at TEXT, updated_at TEXT)\n  rate_limits (key TEXT, action TEXT, count INT, window_start TEXT, PRIMARY KEY(key, action))\n  ```\n\n### otp-service.ts — OTP generation and verification\n- generateOTP(email): generates 8-digit code, SHA-256 hashes it, stores hash in DB, invalidates old codes for same email, returns { code, expiresAt }. Expiry: 15 minutes. Max attempts: 5.\n- verifyOTP(email, code): hashes provided code, timing-safe compares with stored hash, increments attempts, marks used on success or max attempts. Returns { valid, error? }.\n- cleanupExpired(): deletes expired/used tokens.\n\n### rate-limiter.ts — Per-email and per-IP rate limiting\n- checkLimit(key, action, maxCount, windowMinutes): returns { allowed, retryAfterSeconds? }\n- Predefined limits: SEND_PER_EMAIL (3/15min), SEND_PER_EMAIL_HOURLY (5/60min), SEND_PER_IP (10/15min), VERIFY_PER_IP (20/15min)\n\n### credential-store.ts — AES-256-GCM encrypted password storage\n- constructor(db, encryptionKey: Buffer) — 32-byte key from CREDENTIAL_ENCRYPTION_KEY env var\n- storePassword(did, password): encrypts with AES-256-GCM (random 12-byte IV), stores ciphertext+iv+tag\n- getPassword(did): retrieves and decrypts\n- rotatePassword(did, newPassword): re-encrypts\n- deletePassword(did): removes\n\n### callback-signer.ts — HMAC-SHA256 for sidecar↔PDS communication\n- constructor(secret: string) — shared HMAC secret\n- sign(params: CallbackParams): returns hex signature\n- verify(params, signature, maxAge?): returns { valid, error? }\n- buildCallbackUrl(pdsUrl, params): builds full URL with signature\n- static parseCallbackUrl(url): extracts params + signature\n\n### mailer.ts — Email sending via SMTP\n- constructor(smtpConfig: { host, port, user, pass, from })\n- sendOTP(email, code): sends formatted OTP email with the 8-digit code\n\n### logger.ts — Pino logger setup\n\n## Don't\n- Use any encryption library other than node:crypto\n- Store plaintext passwords or OTP codes in the database\n- Use fixed IVs for encryption (must be random per encryption)\n- Skip timing-safe comparison for OTP verification\n- Skip tests — every service needs at least 3 test cases","acceptance_criteria":"1. All 7 source files exist in packages/shared/src/. 2. pnpm build succeeds. 3. pnpm test passes with at least 15 test cases total. 4. OTP codes are SHA-256 hashed before storage. 5. Passwords are AES-256-GCM encrypted. 6. Rate limiter correctly blocks after threshold. 7. HMAC signer produces verifiable signatures.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T15:46:08.819055+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.340874+08:00","closed_at":"2026-02-18T15:54:59.340876+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-mws.2","depends_on_id":"hypercerts-mws","type":"parent-child","created_at":"2026-02-18T15:46:08.820257+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-mws.2","depends_on_id":"hypercerts-mws.1","type":"blocks","created_at":"2026-02-18T15:46:08.821838+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-mws.3","title":"Implement auth-service Express app with OTP routes and email/code UI pages","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/app.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/index.ts (modify)\n- packages/pds-sidecar/packages/auth-service/src/session.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/templates.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/authorize.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/send-code.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/verify-code.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/security-headers.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/error-handler.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/auth.test.ts (create)\n\n## What to do\nBuild the Express auth service that serves the email input + OTP verification pages.\n\n### app.ts — Express application setup\n- Create Express app with: JSON body parser, cookie-parser, CSRF double-submit cookie, security headers middleware, error handler\n- Mount routes: authorize, send-code, verify-code\n- Health check at GET /health returning { status: 'ok' }\n\n### Routes\n\n**GET /oauth/authorize** — Entry point from PDS redirect\n- Receives query params: request_uri, client_id, login_hint (optional)\n- If login_hint is an email: auto-send OTP, show code entry page\n- If no login_hint: show email input page\n- Store request_uri + client_id in signed session cookie\n\n**POST /auth/send-code** — Send OTP email\n- Body: { email }\n- Rate limit check (per-email + per-IP)\n- Generate OTP via OTPService\n- Send email via Mailer\n- Show OTP entry page (always — even if email doesn't exist, for anti-enumeration)\n- Store email in session cookie\n\n**POST /auth/verify-code** — Verify OTP and redirect to PDS\n- Body: { code }\n- Get email from session cookie\n- Verify OTP via OTPService\n- If invalid: re-render OTP page with error\n- If valid: check if account exists in sidecar DB\n- Build HMAC-signed callback URL with: requestUri, email, approved=true, newAccount=(bool), timestamp\n- Redirect browser to PDS's /oauth/magic-callback?...\u0026sig=HMAC...\n\n### session.ts — Signed cookie session management\n- Uses HMAC-signed JSON cookies (not express-session — keep it stateless)\n- Stores: email, requestUri, clientId, csrfToken\n\n### templates.ts — Server-rendered HTML pages\n- renderEmailPage(opts): email input form with CSRF token\n- renderOTPPage(opts): 8-digit code input with masked email display, error message, resend link\n- renderErrorPage(opts): generic error page\n- All pages: minimal CSS, mobile-friendly, Certified branding (simple — just a heading + form)\n\n### Middleware\n- security-headers.ts: HSTS (prod only), CSP, X-Frame-Options: DENY, X-Content-Type-Options: nosniff, Cache-Control: no-store on auth routes\n- error-handler.ts: catches unhandled errors, logs full details via pino, returns safe error in production (no stack traces)\n\n## Don't\n- Use express-session or any session store — use signed cookies\n- Render React/JSX — use plain HTML template strings\n- Skip CSRF protection\n- Skip rate limiting on send-code\n- Expose internal error details in production responses","acceptance_criteria":"1. Express app starts on configurable port. 2. GET /health returns 200. 3. GET /oauth/authorize renders email page (or auto-sends OTP with login_hint). 4. POST /auth/send-code rate-limits and sends OTP. 5. POST /auth/verify-code validates code and redirects to PDS callback URL with HMAC signature. 6. Security headers present on all responses. 7. Tests cover: happy path (send + verify), invalid code, rate limiting.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T15:46:35.738718+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.269704+08:00","closed_at":"2026-02-18T15:54:59.269707+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-mws.3","depends_on_id":"hypercerts-mws","type":"parent-child","created_at":"2026-02-18T15:46:35.740242+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-mws.3","depends_on_id":"hypercerts-mws.2","type":"blocks","created_at":"2026-02-18T15:46:35.742276+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-mws.4","title":"Implement pds-core: PDS wrapper with metadata override, magic-callback, and account creator","description":"## Files\n- packages/pds-sidecar/packages/pds-core/src/index.ts (modify)\n- packages/pds-sidecar/packages/pds-core/src/metadata-override.ts (create)\n- packages/pds-sidecar/packages/pds-core/src/magic-callback.ts (create)\n- packages/pds-sidecar/packages/pds-core/src/account-creator.ts (create)\n- packages/pds-sidecar/packages/pds-core/src/pds-core.test.ts (create)\n\n## What to do\nBuild the PDS wrapper that starts a stock @atproto/pds with two additions: OAuth metadata override and a magic-callback endpoint.\n\n### index.ts — PDS startup with sidecar integration\n```typescript\n// 1. Import and configure stock @atproto/pds\n// 2. Inject metadata override middleware BEFORE PDS routes\n// 3. Add /oauth/magic-callback route\n// 4. Start PDS\n// 5. Export for use by the startup script\nexport async function startPdsCore(config: PdsCoreConfig): Promise\u003c{ pds: PDS, app: Express }\u003e\n```\n\n### metadata-override.ts — Intercept OAuth AS metadata\n- Express middleware that intercepts GET /.well-known/oauth-authorization-server\n- Collects the PDS's response (may be chunked/compressed), decompresses if needed\n- Replaces `authorization_endpoint` with the sidecar's URL (e.g., https://auth.certified.app/oauth/authorize)\n- Re-sends the modified JSON response\n- Must handle gzip, brotli, and deflate compression\n- Must be injected BEFORE PDS route handlers in the Express stack\n\n### magic-callback.ts — Handle HMAC-signed callback from sidecar\n- Express handler for GET /oauth/magic-callback\n- Steps:\n  1. Parse query params using CallbackSigner.parseCallbackUrl\n  2. Verify HMAC signature (max age 300 seconds)\n  3. If newAccount=true, create account via AccountCreator\n  4. Look up user's DID from PDS's internal account manager (pds.ctx.accountManager.getAccountByEmail)\n  5. Create/load device session via PDS's OAuthProvider.deviceManager\n  6. Load PAR request via requestManager.get(requestUri, deviceId)\n  7. Mark request as authorized via requestManager.setAuthorized()\n  8. Redirect to client via /oauth/authorize/redirect with auth code + state + iss\n\n### account-creator.ts — Create ATProto accounts for new users\n- Uses PDS internal API: pds.ctx.oauthProvider.store.createAccount({ handle, email, password, locale })\n- Generates random handle: `${randomBase36(6)}.${pdsDomain}`\n- Generates random password: crypto.randomBytes(64).toString('hex')\n- Stores email→DID mapping in sidecar DB\n- Stores encrypted password via CredentialStore\n- Retries up to 5 times on handle collision\n\n### Internal API access pattern\nThe PDS class exposes `ctx` as a public property. We access internal APIs via `as any` casts:\n- `(pds as any).ctx.oauthProvider` — OAuthProvider instance\n- `(pds as any).ctx.accountManager` — PDS AccountManager\n- `(pds as any).ctx.oauthProvider.deviceManager` — DeviceManager\n- `(pds as any).ctx.oauthProvider.requestManager` — RequestManager\n- `(pds as any).ctx.oauthProvider.clientManager` — ClientManager\nThese are tested against @atproto/pds ^0.4.0.\n\n## Don't\n- Modify @atproto/pds source code — it's an npm dependency only\n- Skip HMAC verification on magic-callback (security critical)\n- Store plaintext passwords (use CredentialStore)\n- Use a fixed handle (must be random per account)\n- Skip the metadata decompression handling (PDS may gzip the response)","acceptance_criteria":"1. PDS starts with metadata override active. 2. GET /.well-known/oauth-authorization-server returns modified authorization_endpoint. 3. GET /oauth/magic-callback verifies HMAC and rejects invalid signatures with 403. 4. New accounts are created with random handles. 5. Existing accounts are looked up by email. 6. Auth code is issued and browser is redirected to client. 7. Tests cover: metadata override, HMAC rejection, account creation.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T15:47:03.004193+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.201426+08:00","closed_at":"2026-02-18T15:54:59.201429+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-mws.4","depends_on_id":"hypercerts-mws","type":"parent-child","created_at":"2026-02-18T15:47:03.019267+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-mws.4","depends_on_id":"hypercerts-mws.2","type":"blocks","created_at":"2026-02-18T15:47:03.021587+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-mws.5","title":"Create local dev startup script and Docker Compose for production","description":"## Files\n- packages/pds-sidecar/scripts/start-local.sh (create)\n- packages/pds-sidecar/.env.local.example (create)\n- packages/pds-sidecar/docker-compose.yml (create)\n- packages/pds-sidecar/Caddyfile (create)\n- packages/pds-sidecar/.env.production.example (create)\n\n## What to do\n\n### Local dev script (start-local.sh)\nA bash script that starts all services for local development:\n1. Check prerequisites: node, pnpm, MailHog (or install via brew)\n2. Start MailHog in background (SMTP on :1025, web UI on :8025)\n3. Build all packages: pnpm build\n4. Start PDS core on port 2583 (with sidecar integration)\n5. Start auth service on port 2584\n6. Print URLs:\n   - Scaffold: http://127.0.0.1:3000\n   - PDS: http://localhost:2583\n   - Auth service: http://localhost:2584\n   - MailHog: http://localhost:8025\n7. Trap SIGINT to clean up background processes\n\n### .env.local.example\n```bash\nPDS_HOSTNAME=localhost\nPDS_PORT=2583\nPDS_DATA_DIRECTORY=./data\nPDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=\u003cgenerate with: openssl rand -hex 32\u003e\nPDS_JWT_SECRET=\u003cgenerate with: openssl rand -hex 32\u003e\nPDS_ADMIN_PASSWORD=local-admin-password\nPDS_EMAIL_SMTP_URL=smtp://localhost:1025\nPDS_EMAIL_FROM_ADDRESS=noreply@localhost\n\nSIDECAR_PORT=2584\nSIDECAR_SESSION_SECRET=\u003cgenerate with: openssl rand -hex 32\u003e\nHMAC_SECRET=\u003cgenerate with: openssl rand -hex 32\u003e\nCREDENTIAL_ENCRYPTION_KEY=\u003cgenerate with: openssl rand -hex 32\u003e\nAUTH_SERVICE_URL=http://localhost:2584\nPDS_INTERNAL_URL=http://localhost:2583\n\nSMTP_HOST=localhost\nSMTP_PORT=1025\nSMTP_FROM=noreply@localhost\n# No SMTP_USER/SMTP_PASS needed for MailHog\n```\n\n### Docker Compose (production)\nServices:\n- **caddy**: Caddy reverse proxy with TLS. Routes certified.app → pds:3000, auth.certified.app → auth-service:3001, *.certified.app → pds:3000\n- **pds**: Stock @atproto/pds with sidecar integration (pds-core). Port 3000 internal.\n- **auth-service**: Sidecar auth service. Port 3001 internal.\n- Shared Docker network, shared volumes for PDS data and sidecar SQLite\n\n### Caddyfile\n```\ncertified.app {\n    reverse_proxy pds:3000\n}\nauth.certified.app {\n    reverse_proxy auth-service:3001\n}\n*.certified.app {\n    reverse_proxy pds:3000\n}\n```\nUse DNS challenge for wildcard TLS (configurable provider via env var).\n\n## Don't\n- Hard-code any secrets or domain names (use env vars)\n- Require Docker for local development (script uses node directly)\n- Skip the MailHog setup in the local script\n- Forget to make start-local.sh executable (chmod +x)","acceptance_criteria":"1. start-local.sh is executable and starts PDS + auth service + MailHog. 2. .env.local.example has all required vars with generation commands. 3. docker-compose.yml defines caddy, pds, and auth-service. 4. Caddyfile routes correctly. 5. .env.production.example has all production vars. 6. docker compose config validates.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T15:47:25.856425+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.130632+08:00","closed_at":"2026-02-18T15:54:59.130634+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-mws.5","depends_on_id":"hypercerts-mws","type":"parent-child","created_at":"2026-02-18T15:47:25.858213+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-mws.5","depends_on_id":"hypercerts-mws.3","type":"blocks","created_at":"2026-02-18T15:47:25.85956+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-mws.5","depends_on_id":"hypercerts-mws.4","type":"blocks","created_at":"2026-02-18T15:47:25.860595+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-p33","title":"Epic: Organization Membership, RBAC \u0026 Repo Management","description":"## Goal\nBuild the application-layer organization system: membership management, role-based access control, and server-side repo signing for org data. This is independent of the auth flow and can be built in parallel.\n\n## Context\nATProto has NO native org support. Every repo has exactly one signing key. All org logic lives in our application layer. The architecture doc specifies:\n- Our backend maintains org membership (user_did → [org_ids])\n- Roles: admin (manage members + write + delete), contributor (write), viewer (read)\n- Org repos are DID-based PDS accounts whose signing keys we hold server-side\n- The org/RBAC layer is completely independent of how users authenticate\n\n### How Orgs Work\nEach org is a regular ATProto account on the PDS. The difference:\n- The org's signing key (password) is held by our backend, encrypted with AES-256-GCM\n- Our backend mediates all writes: User → Scaffold API → RBAC check → PDS write as org account\n- Users never directly interact with the org's PDS credentials\n\n### Data Model\n- organizations: id (UUID), did, handle, name, created_at\n- org_memberships: org_id + user_did (composite PK), role, invited_by, created_at\n\n## What Has to Be Built\n1. OrgStore — data access layer for orgs and memberships (SQLite)\n2. PdsAdminService — creates/deletes org PDS accounts, manages encrypted credentials\n3. PdsRecordService — RBAC-gated CRUD on org repos via XRPC\n4. Org API routes — REST endpoints for org management\n5. Scaffold UI — org listing page after login\n\n## Hard Constraints\n- All org data in sidecar SQLite (same DB as auth data)\n- Org PDS accounts created via com.atproto.server.createAccount (XRPC, not internal API)\n- Org credentials encrypted at rest (reuse CredentialStore from shared package)\n- Stock PDS only — no protocol changes\n- Must work with any ATProto Lexicon (hypercerts, profiles, etc.)","status":"closed","priority":2,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T15:48:27.289644+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.840465+08:00","closed_at":"2026-02-18T15:54:59.840467+08:00","labels":["scope:medium"]}
{"id":"hypercerts-p33.1","title":"Implement OrgStore data layer and org API routes","description":"## Files\n- packages/pds-sidecar/packages/shared/src/org-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/org-store.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add org tables)\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.test.ts (create)\n\n## What to do\n\n### OrgStore class (shared/src/org-store.ts)\nData access layer for organizations and memberships.\n\nTypes: OrgRole = 'admin' | 'contributor' | 'viewer'\n\nMethods:\n- createOrg({ did, handle, name }): Organization\n- getOrg(id), getOrgByDid(did), getOrgByHandle(handle): Organization | null\n- updateOrg(id, { name?, handle? }): Organization\n- deleteOrg(id): void\n- addMember(orgId, userDid, role, invitedBy): OrgMembership\n- removeMember(orgId, userDid): void — cannot remove last admin\n- updateRole(orgId, userDid, newRole): void\n- getMember(orgId, userDid): OrgMembership | null\n- getMembers(orgId): OrgMembership[]\n- getUserOrgs(userDid): (Organization \u0026 { role })[]\n- canWrite(orgId, userDid): boolean — admin or contributor\n- canAdmin(orgId, userDid): boolean — admin only\n\nDB tables:\n```sql\norganizations (id TEXT PK, did TEXT UNIQUE, handle TEXT UNIQUE, name TEXT, created_at TEXT)\norg_memberships (org_id TEXT, user_did TEXT, role TEXT CHECK(IN admin/contributor/viewer), invited_by TEXT, created_at TEXT, PK(org_id, user_did))\n```\n\n### Org API routes (auth-service/src/routes/orgs.ts)\nAll routes require auth (user DID from Authorization header — simplified for now).\n\nPOST /api/orgs — create org (creator becomes admin)\nGET /api/orgs — list user's orgs\nGET /api/orgs/:orgId — get org (must be member)\nPUT /api/orgs/:orgId — update org (admin only)\nDELETE /api/orgs/:orgId — delete org (admin only)\nPOST /api/orgs/:orgId/members — add member (admin only)\nGET /api/orgs/:orgId/members — list members (must be member)\nPUT /api/orgs/:orgId/members/:did — update role (admin only)\nDELETE /api/orgs/:orgId/members/:did — remove member (admin only, can't remove last admin)\n\n## Don't\n- Create PDS accounts for orgs in this task (that's PdsAdminService)\n- Use an external UUID library (use crypto.randomUUID())\n- Allow removing the last admin from an org\n- Skip input validation on API routes","acceptance_criteria":"1. OrgStore class exists with all methods. 2. All 9 API routes return correct status codes. 3. RBAC enforced: admin-only routes reject non-admins with 403. 4. Cannot remove last admin. 5. getUserOrgs returns orgs with roles. 6. Tests cover CRUD + RBAC + edge cases.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T15:48:47.222864+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.772439+08:00","closed_at":"2026-02-18T15:54:59.772441+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-p33.1","depends_on_id":"hypercerts-p33","type":"parent-child","created_at":"2026-02-18T15:48:47.225035+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-p33.1","depends_on_id":"hypercerts-mws.1","type":"blocks","created_at":"2026-02-18T15:48:47.226361+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-p33.2","title":"Implement PdsAdminService and PdsRecordService for org repo management","description":"## Files\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-record-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-record-service.test.ts (create)\n\n## What to do\n\n### PdsAdminService — Org account lifecycle\nManages creating/deleting PDS accounts for organizations.\n\n```typescript\nclass PdsAdminService {\n  constructor(pdsUrl: string, pdsDomain: string, credentialStore: CredentialStore, orgStore: OrgStore)\n\n  async createOrgAccount(orgName: string, creatorDid: string): Promise\u003c{ orgId, did, handle }\u003e\n  // 1. Generate handle: org-{randomBase36(6)}.{pdsDomain}\n  // 2. Generate password: crypto.randomBytes(64).toString('hex')\n  // 3. Call com.atproto.server.createAccount via AtpAgent XRPC\n  //    - email: org-{uuid}@{pdsDomain} (synthetic, not real)\n  //    - handle, password from above\n  // 4. Store encrypted password via credentialStore.storePassword(did, password)\n  // 5. Create org in orgStore, add creator as admin\n  // 6. Return { orgId, did, handle }\n\n  async deleteOrgAccount(orgId: string, callerDid: string): Promise\u003cvoid\u003e\n  // 1. Verify caller is admin via orgStore.canAdmin()\n  // 2. Get org's credentials, create session\n  // 3. Call com.atproto.server.deleteAccount via XRPC\n  // 4. Delete from credentialStore and orgStore\n\n  async getOrgSession(orgId: string): Promise\u003cAtpSessionData\u003e\n  // 1. Get org DID from orgStore\n  // 2. Get decrypted password from credentialStore\n  // 3. Call com.atproto.server.createSession via XRPC\n  // 4. Return session data\n}\n```\n\n### PdsRecordService — RBAC-gated CRUD on org repos\n```typescript\nclass PdsRecordService {\n  constructor(pdsAdminService: PdsAdminService, orgStore: OrgStore)\n\n  async createRecord(orgId, callerDid, { collection, record, rkey? }): Promise\u003c{ uri, cid }\u003e\n  // Check canWrite → get org session → com.atproto.repo.createRecord\n\n  async getRecord(orgDid, collection, rkey): Promise\u003cunknown\u003e\n  // No RBAC needed (ATProto repos are public)\n\n  async putRecord(orgId, callerDid, { collection, rkey, record }): Promise\u003c{ uri, cid }\u003e\n  // Check canWrite → get org session → com.atproto.repo.putRecord\n\n  async deleteRecord(orgId, callerDid, { collection, rkey }): Promise\u003cvoid\u003e\n  // Check canAdmin (only admins delete) → get org session → com.atproto.repo.deleteRecord\n\n  async listRecords(orgDid, collection, { limit?, cursor? }): Promise\u003c{ records, cursor? }\u003e\n  // No RBAC needed\n}\n```\n\nAll XRPC calls use @atproto/api's AtpAgent, authenticated with the org's session.\n\n## Don't\n- Expose org credentials to callers\n- Skip RBAC checks on any write operation\n- Allow contributors to delete records (admin only)\n- Cache sessions indefinitely (they expire)\n- Use PDS internal APIs (use XRPC only — external API)","acceptance_criteria":"1. PdsAdminService creates org accounts with encrypted credentials. 2. PdsRecordService enforces RBAC on all writes. 3. Viewers cannot write. Contributors can create/update but not delete. Admins can do everything. 4. Tests mock AtpAgent XRPC calls and verify the full flow. 5. No plaintext passwords exposed.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T15:49:09.204251+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.704454+08:00","closed_at":"2026-02-18T15:54:59.704456+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-p33.2","depends_on_id":"hypercerts-p33","type":"parent-child","created_at":"2026-02-18T15:49:09.208196+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-p33.2","depends_on_id":"hypercerts-p33.1","type":"blocks","created_at":"2026-02-18T15:49:09.210359+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-p33.2","depends_on_id":"hypercerts-mws.2","type":"blocks","created_at":"2026-02-18T15:49:09.211473+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-p33.3","title":"Add org listing page and components to scaffold app","description":"## Files\n- app/orgs/page.tsx (create)\n- components/org-list.tsx (create)\n- components/org-card.tsx (create)\n- lib/api/orgs.ts (create)\n- queries/queries/use-user-orgs-query.ts (create)\n\n## What to do\nAfter login, users should be able to see their organizations. Create the org listing page.\n\n### /orgs page (app/orgs/page.tsx)\nServer component that renders the OrgList client component. Protected by SignedInProvider (requires auth).\n\n### OrgList component (components/org-list.tsx)\nClient component. Uses useUserOrgsQuery to fetch orgs from the sidecar API. Renders a responsive grid of OrgCard components. Shows empty state with 'Create Organization' CTA if no orgs.\n\n### OrgCard component (components/org-card.tsx)\nDisplays: org name, handle (e.g., maearth.certified.app), user's role as a badge (admin=red, contributor=blue, viewer=gray). Clicking navigates to /orgs/[orgId]. Uses shadcn Card + Badge.\n\n### API client (lib/api/orgs.ts)\n- getUserOrgs(): fetches GET /api/orgs from sidecar\n- getOrg(orgId): fetches GET /api/orgs/:orgId\n- createOrg(name): POSTs to /api/orgs\n\n### Query hook\nuseUserOrgsQuery wraps getUserOrgs with TanStack Query. Key: ['orgs'].\n\n### Styling\n- Responsive grid: 1 col mobile, 2 tablet, 3 desktop\n- Use existing design system: shadcn Card, Badge, Syne headings, Outfit body\n- Match the existing glassmorphism/gradient aesthetic\n\n## Don't\n- Implement org creation form (just the listing + empty state CTA)\n- Implement member management UI\n- Fetch from PDS directly — go through sidecar API\n- Break existing pages or navigation\n- Add new npm dependencies","acceptance_criteria":"1. /orgs page renders org list. 2. OrgCard shows name, handle, role badge. 3. Empty state shown when no orgs. 4. useUserOrgsQuery fetches from sidecar. 5. Responsive grid works. 6. pnpm build succeeds.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T15:49:27.344802+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.634635+08:00","closed_at":"2026-02-18T15:54:59.634638+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-p33.3","depends_on_id":"hypercerts-p33","type":"parent-child","created_at":"2026-02-18T15:49:27.345935+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-p33.3","depends_on_id":"hypercerts-p33.1","type":"blocks","created_at":"2026-02-18T15:49:27.347315+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-p5n","title":"Epic: Unified Sign-up/Sign-in Flow with Handle Assignment","description":"## Goal\nImplement a unified auth flow where sign-up and sign-in are identical from the user's perspective. User enters email → gets OTP → enters code → they're in. If the email is new, an account is auto-created. If existing, they're logged in. Handle assignment is automatic and invisible.\n\n## Context\nThe architecture doc specifies Option A1: application-layer OTP + hidden password. The pds-sidecar already has:\n- AccountCreator (packages/pds-sidecar/packages/pds-core/dist/account-creator.js) that creates accounts with random handles (6-char base36 + domain) and random passwords\n- OTP verification flow in auth-service routes\n- verify-code route that checks if account exists and builds HMAC callback\n\nWhat's MISSING:\n1. **Email→account lookup before OTP send**: The send-code route should check if the email already has an account and behave identically either way (anti-enumeration)\n2. **Handle collision detection**: randomBase36(6) could collide. Need retry logic.\n3. **Handle customization later**: Users should be able to change their handle after signup (not in this epic, but the schema should support it)\n4. **Credential storage integration**: AccountCreator generates a random password but doesn't store it encrypted via CredentialStore (from Epic: OTP Hardening)\n5. **Email verification status**: Track whether an email has been verified via OTP at least once\n\n## User Flow (detailed)\n1. User enters email on scaffold /login page\n2. Scaffold calls /api/auth/email-login with email\n3. SDK calls authorize('https://certified.app') with login_hint=email\n4. PDS returns auth URL → sidecar's /oauth/authorize\n5. Sidecar receives login_hint, auto-sends OTP email\n6. User enters 8-digit code\n7. Sidecar verifies code\n8. If new email: sidecar creates account (random handle, random encrypted password), stores credentials\n9. If existing email: sidecar looks up DID from accounts table\n10. Sidecar builds HMAC-signed callback → PDS magic-callback → OAuth code → scaffold callback → session\n\n## Hard Constraints\n- Sign-up and sign-in MUST be visually identical (anti-enumeration)\n- Handle format: `{random6}.certified.app` (or configured domain)\n- Auto-generated passwords: 128 hex chars, encrypted via CredentialStore\n- No user-visible password at any point\n- Stock PDS — account creation via com.atproto.server.createAccount or PDS internal OAuthStore.createAccount\n\n## Success Looks Like\n- New email → account created → OTP verified → session established\n- Existing email → OTP verified → session established\n- Both flows look identical to the user\n- Handle collisions are retried automatically (max 5 attempts)\n- Credentials stored encrypted","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:04:18.311383+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.22461+08:00","closed_at":"2026-02-18T15:44:49.224613+08:00","labels":["scope:medium"]}
{"id":"hypercerts-p5n.1","title":"Add handle collision retry logic to AccountCreator","description":"## Files\n- packages/pds-sidecar/packages/pds-core/src/account-creator.ts (modify)\n- packages/pds-sidecar/packages/pds-core/src/account-creator.test.ts (create)\n\n## What to do\nModify the AccountCreator.createAccount() method to retry handle generation on collision.\n\n### Current behavior (account-creator.js in dist/)\n- Generates a single random handle: `${randomBase36(6)}.${pdsDomain}`\n- If the handle already exists on the PDS, the createAccount call throws and the user gets an error\n\n### New behavior\n1. Wrap the account creation in a retry loop (max 5 attempts)\n2. On each attempt, generate a new random handle\n3. If createAccount throws with a handle-already-exists error (check for 'HandleNotAvailable' or similar ATProto error code), retry with a new handle\n4. If all 5 attempts fail, throw a clear error: 'Failed to generate unique handle after 5 attempts'\n5. Log each retry attempt via pino logger\n\n### Source code location\nThe TypeScript source for account-creator.ts should be on the beads/plan-passwordless-login branch. Check there first. If not available, recreate from the compiled dist/account-creator.js (which is readable and well-commented).\n\n## Don't\n- Change the handle format (keep randomBase36(6))\n- Increase handle length (6 chars = 2.1 billion combinations, collisions are rare)\n- Retry on non-collision errors (only retry HandleNotAvailable)\n- Add more than 5 retry attempts","acceptance_criteria":"1. AccountCreator.createAccount() retries up to 5 times on handle collision. 2. Non-collision errors are thrown immediately without retry. 3. After 5 failed attempts, a clear error message is thrown. 4. Test exists that mocks a collision on first attempt and succeeds on second. 5. Test exists that verifies 5 consecutive collisions produce the expected error.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:04:32.95251+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.313671+08:00","closed_at":"2026-02-18T15:44:49.313674+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-p5n.1","depends_on_id":"hypercerts-p5n","type":"parent-child","created_at":"2026-02-18T14:04:32.953804+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-p5n.2","title":"Integrate CredentialStore into AccountCreator for encrypted password storage","description":"## Files\n- packages/pds-sidecar/packages/pds-core/src/account-creator.ts (modify)\n- packages/pds-sidecar/packages/pds-core/src/account-creator.test.ts (modify)\n\n## What to do\nUpdate AccountCreator to use CredentialStore (from Epic: OTP Hardening) to encrypt and store auto-generated passwords.\n\n### Current behavior\nAccountCreator.createAccount() generates a random password (`crypto.randomBytes(64).toString('hex')`) and passes it to the PDS's OAuthStore.createAccount(). The password is stored in the sidecar's accounts table as plaintext (it's not stored at all currently — only the email→DID mapping is stored).\n\n### New behavior\n1. Add CredentialStore as a constructor dependency:\n   ```typescript\n   constructor(pds: any, pdsDomain: string, sidecarDb: Database, credentialStore: CredentialStore)\n   ```\n2. After successful account creation, call `credentialStore.storePassword(did, password)`\n3. Add a `getPasswordForDid(did: string): string | null` method that delegates to `credentialStore.getPassword(did)`\n4. Update tests to verify password is stored encrypted after account creation\n\n### Why this matters\nThe architecture doc identifies this as a key risk: 'We hold auto-generated passwords server-side — if our backend is compromised, all PDS accounts are exposed.' Encrypting at rest with AES-256-GCM mitigates this.\n\n## Don't\n- Store plaintext passwords anywhere\n- Change the password generation logic (keep crypto.randomBytes(64).toString('hex'))\n- Remove the existing email→DID mapping storage (keep both)\n- Make CredentialStore optional — it's required","acceptance_criteria":"1. AccountCreator constructor requires CredentialStore parameter. 2. After createAccount(), the password is stored via credentialStore.storePassword(). 3. getPasswordForDid() returns the decrypted password. 4. No plaintext password appears in the sidecar SQLite database. 5. Tests verify encrypted storage after account creation.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:04:47.431356+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.403943+08:00","closed_at":"2026-02-18T15:44:49.403956+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-p5n.2","depends_on_id":"hypercerts-p5n","type":"parent-child","created_at":"2026-02-18T14:04:47.432789+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-p5n.2","depends_on_id":"hypercerts-8mu.1","type":"blocks","created_at":"2026-02-18T14:04:47.44827+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-p5n.3","title":"Add email verification tracking to accounts table","description":"## Files\n- packages/pds-sidecar/packages/shared/src/db.ts (modify)\n- packages/pds-sidecar/packages/shared/src/account-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/account-service.test.ts (create)\n\n## What to do\nCreate an AccountService that manages the email→DID mapping and tracks email verification status.\n\n### AccountService class\n```typescript\nexport class AccountService {\n  constructor(db: BetterSqlite3.Database)\n  findByEmail(email: string): { did: string, handle: string, emailVerified: boolean, createdAt: string } | null\n  findByDid(did: string): { email: string, handle: string, emailVerified: boolean, createdAt: string } | null\n  create(email: string, did: string, handle: string): void\n  markEmailVerified(email: string): void\n  isEmailVerified(email: string): boolean\n  updateHandle(did: string, newHandle: string): void\n}\n```\n\n### DB migration\nAlter the existing accounts table (or create if not exists):\n```sql\nCREATE TABLE IF NOT EXISTS accounts (\n  email TEXT PRIMARY KEY,\n  did TEXT UNIQUE NOT NULL,\n  handle TEXT NOT NULL,\n  email_verified INTEGER DEFAULT 0,\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\nCREATE INDEX IF NOT EXISTS idx_accounts_did ON accounts(did);\n```\n\n### Integration point\nAfter OTP verification succeeds in verify-code route, call `accountService.markEmailVerified(email)`. This is NOT done in this task — just create the service. The route integration is a separate task.\n\n## Don't\n- Delete or modify existing account records during migration\n- Make email case-sensitive (normalize to lowercase before storage)\n- Add any auth logic to AccountService (it's a data layer only)","acceptance_criteria":"1. AccountService class exists with all 6 methods. 2. findByEmail and findByDid return correct data. 3. markEmailVerified flips the flag. 4. Email is normalized to lowercase. 5. Tests cover: create + find roundtrip, email verification toggle, findByDid lookup, null return for non-existent accounts.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-18T14:05:01.225752+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.499263+08:00","closed_at":"2026-02-18T15:44:49.499266+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-p5n.3","depends_on_id":"hypercerts-p5n","type":"parent-child","created_at":"2026-02-18T14:05:01.227197+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-p9n","title":"Epic: Document SDK Packaging and Enhance Developer Experience","status":"closed","priority":1,"issue_type":"epic","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:18:09.88485984+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:28:40.447887994+06:00","closed_at":"2026-02-13T11:28:40.447887994+06:00","close_reason":"Completed all 7 documentation tasks: created DEVELOPMENT.md, added SDK warnings, enhanced loopback docs, improved prerequisites, updated .env.example, reorganized footer, and reviewed code examples"}
{"id":"hypercerts-p9n.1","title":"Create DEVELOPMENT.md with SDK version warnings and development guide","description":"Create a comprehensive DEVELOPMENT.md file covering: (1) Critical warning about unreleased SDK version (0.10.0-beta.8 from vendor/), (2) Explanation of packed packages and why we use them for dogfooding, (3) Warning that installing latest SDK may break scaffold, (4) Step-by-step instructions to update vendor SDK package manually, (5) Local development workflow and setup, (6) Contributing guidelines encouraging users to file issues for @kzoeps. This file serves as the technical reference for developers working with the scaffold.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:18:18.009152902+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:23:15.860547626+06:00","closed_at":"2026-02-13T11:23:15.860547626+06:00","close_reason":"Completed: 5ec8a6e - Created comprehensive DEVELOPMENT.md covering SDK version warnings, packed package explanation, update instructions, development workflow, troubleshooting, and contributing guidelines","dependencies":[{"issue_id":"hypercerts-p9n.1","depends_on_id":"hypercerts-p9n","type":"parent-child","created_at":"2026-02-13T11:18:18.010805084+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-p9n.2","title":"Add SDK version warning section to README.md","description":"Add a prominent '⚠️ Important: SDK Version \u0026 Breaking Changes' section to README.md immediately after the Quick Start section (around line 32). This section must explain: (1) Uses unreleased v0.10.0-beta.8 from vendor/, (2) Built from github.com/hypercerts-org/hypercerts-sdk not npm, (3) Purpose is dogfooding latest features, (4) Contains unreleased/unmerged changes, (5) Breaking changes expected, (6) Installing latest SDK may break scaffold, (7) Link to DEVELOPMENT.md for details, (8) Link to issues at github.com/hypercerts-org/hypercerts-scaffold-atproto with @kzoeps as maintainer. Depends on hypercerts-p9n.1 because DEVELOPMENT.md must exist to link to it.","status":"closed","priority":1,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:18:25.62233731+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:23:59.686592067+06:00","closed_at":"2026-02-13T11:23:59.686592067+06:00","close_reason":"Completed: 1e8c516 - Added SDK version warning section to README after Quick Start with all required details","dependencies":[{"issue_id":"hypercerts-p9n.2","depends_on_id":"hypercerts-p9n","type":"parent-child","created_at":"2026-02-13T11:18:25.623979997+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-p9n.2","depends_on_id":"hypercerts-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:05.137659881+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-p9n.3","title":"Enhance README loopback configuration documentation","description":"Improve the existing loopback configuration docs in README.md: (1) Make Quick Start note more prominent (line 31) - emphasize OAuth requirement for 127.0.0.1, (2) Add TL;DR to 'Localhost Redirect' section (line 127) explaining that .env.local MUST use 127.0.0.1 for OAuth to work, (3) Add troubleshooting subsection with common OAuth issues (callback failed, invalid redirect_uri, redirect loops, ngrok issues). The loopback docs are already comprehensive, this task just enhances clarity and adds troubleshooting.","status":"closed","priority":2,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:18:33.299950647+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:24:57.350432049+06:00","closed_at":"2026-02-13T11:24:57.350432049+06:00","close_reason":"Completed: 2a3277f - Enhanced loopback docs with prominent OAuth requirement, TL;DR, and troubleshooting section","dependencies":[{"issue_id":"hypercerts-p9n.3","depends_on_id":"hypercerts-p9n","type":"parent-child","created_at":"2026-02-13T11:18:33.30151496+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-p9n.4","title":"Improve README prerequisites and installation section","description":"Update Prerequisites section (lines 5-10) in README.md to be more detailed and helpful: (1) Specify Node.js 20+ with nvm recommendation, (2) Mention pnpm explicitly with install command, (3) Expand Redis section with both local Docker and cloud options, (4) Clarify PDS account requirement, (5) Add note referencing DEVELOPMENT.md for SDK details. Update Quick Start section to mention pnpm explicitly and add Redis check before running dev server. Depends on hypercerts-p9n.1 because needs DEVELOPMENT.md to reference it.","status":"closed","priority":2,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:18:41.139193052+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:25:37.166639803+06:00","closed_at":"2026-02-13T11:25:37.166639803+06:00","close_reason":"Completed: e31646b - Updated prerequisites with detailed requirements and Quick Start with pnpm/Redis clarity","dependencies":[{"issue_id":"hypercerts-p9n.4","depends_on_id":"hypercerts-p9n","type":"parent-child","created_at":"2026-02-13T11:18:41.141044172+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-p9n.4","depends_on_id":"hypercerts-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:05.725129883+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-p9n.5","title":"Update .env.example with SDK version reference","description":"Add a header comment block at the top of .env.example file explaining: (1) This scaffold uses unreleased packed SDK version, (2) Reference DEVELOPMENT.md for SDK details and breaking changes, (3) Reference README.md for setup instructions. This provides context for developers when they first copy the file. Depends on hypercerts-p9n.1 because needs DEVELOPMENT.md to reference it.","status":"closed","priority":2,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:18:47.282193967+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:26:10.199986381+06:00","closed_at":"2026-02-13T11:26:10.199986381+06:00","close_reason":"Completed: 4818387 - Added header comment with SDK version warning and references to DEVELOPMENT.md","dependencies":[{"issue_id":"hypercerts-p9n.5","depends_on_id":"hypercerts-p9n","type":"parent-child","created_at":"2026-02-13T11:18:47.283647269+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-p9n.5","depends_on_id":"hypercerts-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:06.370792289+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-p9n.6","title":"Add DEVELOPMENT.md link to README footer","description":"Update the 'Learn More' section (around line 242) in README.md to add DEVELOPMENT.md as the first link under a new 'Scaffold Documentation' subsection. Also add links to report issues (github.com/hypercerts-org/hypercerts-scaffold-atproto/issues) and mention @kzoeps as maintainer. Reorganize external docs links into a separate subsection. Depends on hypercerts-p9n.1 because DEVELOPMENT.md must exist to link to it.","status":"closed","priority":3,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:18:53.526270655+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:26:50.075541431+06:00","closed_at":"2026-02-13T11:26:50.075541431+06:00","close_reason":"Completed: 9aee7d0 - Reorganized Learn More section with DEVELOPMENT.md, external docs, and issue reporting links","dependencies":[{"issue_id":"hypercerts-p9n.6","depends_on_id":"hypercerts-p9n","type":"parent-child","created_at":"2026-02-13T11:18:53.528019597+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-p9n.6","depends_on_id":"hypercerts-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:06.902665893+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-p9n.7","title":"Review and update code examples in README","description":"Review all code snippets throughout README.md for accuracy with current codebase: (1) Check Authentication section code example (lines 170-187), (2) Check Repository Context section (lines 193-210), (3) Verify all imports are correct, (4) Verify function signatures match current SDK version, (5) Add helpful comments where appropriate, (6) Ensure examples follow best practices. This is a review/polish task to ensure documentation matches implementation.","status":"closed","priority":3,"issue_type":"task","assignee":"kzoeps","owner":"kzoepa@gmail.com","created_at":"2026-02-13T11:19:00.53603122+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:28:18.636827322+06:00","closed_at":"2026-02-13T11:28:18.636827322+06:00","close_reason":"Completed: 91d11f0 - Reviewed and improved all code examples, added simpler alternatives, fixed authentication flow description","dependencies":[{"issue_id":"hypercerts-p9n.7","depends_on_id":"hypercerts-p9n","type":"parent-child","created_at":"2026-02-13T11:19:00.537513614+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-qc3","title":"Epic: PDS Sidecar Auth Service","description":"## Goal\nBuild a standalone Express.js auth service that runs alongside the stock `@atproto/pds` package to provide email-first passwordless login via OTP codes. This lives in `packages/pds-sidecar/` within the hypercerts-scaffold repo (same PR as the scaffold UI changes).\n\n## Context\nATProto's PDS has a built-in OAuth authorization server with a password-based sign-in form. We want to replace this with email + OTP for the Certified ecosystem (Ma Earth, GainForest, etc.). The PDS is ~80% ready for email OTP — the `emailOtp` field exists in the sign-in schema, `SecondAuthenticationFactorRequiredError` is implemented, email token infrastructure is production-ready, and password is already optional at the AccountManager level. The blocker is a hard `throw new Error('Email OTP is not supported')` in `OAuthStore.authenticateAccount()`.\n\nRather than forking the PDS, we build a **sidecar auth service** that:\n1. Overrides the PDS's OAuth authorization server metadata (`/.well-known/oauth-authorization-server`) to redirect the `authorization_endpoint` to itself\n2. Serves its own email input + OTP verification pages\n3. After OTP verification, calls into the PDS's internal `OAuthProvider` APIs to create accounts (if new) and issue OAuth authorization codes\n4. Redirects the user back to the client app with a standard OAuth code\n\nFrom the client app's perspective, this is a normal OAuth flow. The client doesn't know the sidecar exists.\n\n## Location\nAll sidecar code lives under `packages/pds-sidecar/` in the hypercerts-scaffold repo. This is a monorepo with three sub-packages:\n- `packages/pds-sidecar/packages/shared/` — DB, OTP service, rate limiter, HMAC signer, mailer\n- `packages/pds-sidecar/packages/auth-service/` — Express auth service\n- `packages/pds-sidecar/packages/pds-core/` — PDS wrapper\n\n## Architecture\n```\nClient App (scaffold)\n  │\n  │ 1. PAR request\n  │ 8. Token exchange (stock ATProto)\n  ▼\nPDS Core (stock @atproto/pds, unmodified npm package)\n  │  AS metadata overridden:\n  │  authorization_endpoint → auth.pds.certs.network\n  │\n  │ 2. Redirect to sidecar    7. Auth code issued via signed callback\n  ▼                            ▲\nSidecar Auth Service (Express)\n  GET  /oauth/authorize     ← email input form\n  POST /auth/send-code      ← generate OTP, send email\n  POST /auth/verify-code    ← validate OTP\n  GET  /auth/consent        ← consent screen\n  │\n  │ 3-5. Email 6-digit OTP code\n  ▼\nUser's inbox\n```\n\n## Key Design Decisions\n1. **Wrap, don't fork.** `@atproto/pds` is an npm dependency, not modified source.\n2. **Signed callback.** HMAC-SHA256 between sidecar and PDS to prevent account takeover.\n3. **Unified sign-in/sign-up.** New emails get an account auto-created; existing emails get authenticated.\n4. **`login_hint` passthrough.** Client passes email as `login_hint` → sidecar sends OTP immediately.\n5. **Random handles.** New accounts get random handles to avoid leaking emails.\n6. **8-digit OTP codes.** Better brute-force resistance.\n\n## Security Requirements\n- HMAC-SHA256 signed callback between sidecar and PDS\n- OTP codes: 8 digits, SHA-256 hashed before storage, single-use, 15-min expiry, max 5 attempts\n- Rate limiting: per-email (3/15min, 5/hr), per-IP (10/15min)\n- Anti-enumeration: show OTP form regardless of whether email exists\n- CSRF protection: double-submit cookie with timing-safe comparison\n- Security headers: HSTS, CSP, X-Frame-Options, X-Content-Type-Options\n\n## Success Criteria\n- Sidecar starts alongside stock PDS, overrides AS metadata\n- Email OTP flow works end-to-end\n- New accounts auto-created with random handles\n- Callback between sidecar and PDS is HMAC-signed\n- Rate limiting and anti-enumeration in place","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:12:07.512977+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.496331+08:00","closed_at":"2026-02-18T15:50:27.496334+08:00","labels":["scope:medium"]}
{"id":"hypercerts-qc3.1","title":"Initialize sidecar repo with monorepo structure","description":"## Files\n- packages/pds-sidecar/package.json (create)\n- packages/pds-sidecar/tsconfig.json (create)\n- packages/pds-sidecar/packages/shared/package.json (create)\n- packages/pds-sidecar/packages/shared/src/index.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (create)\n- packages/pds-sidecar/packages/shared/src/types.ts (create)\n- packages/pds-sidecar/packages/shared/src/logger.ts (create)\n- packages/pds-sidecar/packages/auth-service/package.json (create)\n- packages/pds-sidecar/packages/auth-service/src/index.ts (create)\n- packages/pds-sidecar/packages/pds-core/package.json (create)\n- packages/pds-sidecar/packages/pds-core/src/index.ts (create)\n- packages/pds-sidecar/.gitignore (create)\n- packages/pds-sidecar/README.md (create)\n\n## What to do\nCreate the PDS sidecar monorepo structure under `packages/pds-sidecar/` in the hypercerts-scaffold repo. This directory contains three sub-packages using npm workspaces.\n\n### Root `packages/pds-sidecar/package.json`\n- Name: `@certified/pds-sidecar`\n- Private: true\n- Workspaces: `['packages/*']`\n- Scripts: `dev`, `build`, `test`, `lint`\n- Engine: Node.js \u003e= 20\n\n### `packages/pds-sidecar/packages/shared`\nShared utilities used by both auth-service and pds-core:\n- **`db.ts`**: Initialize better-sqlite3 database. Export a `createDatabase(path: string)` function that creates the SQLite file and returns a Database instance. Create tables on init:\n  - `accounts`: `id INTEGER PRIMARY KEY, email TEXT UNIQUE NOT NULL, did TEXT UNIQUE, handle TEXT, created_at TEXT DEFAULT CURRENT_TIMESTAMP`\n  - `otp_tokens`: `id INTEGER PRIMARY KEY, email TEXT NOT NULL, token_hash TEXT NOT NULL, attempts INTEGER DEFAULT 0, max_attempts INTEGER DEFAULT 5, expires_at TEXT NOT NULL, used INTEGER DEFAULT 0, created_at TEXT DEFAULT CURRENT_TIMESTAMP`\n  - `rate_limits`: `id INTEGER PRIMARY KEY, key TEXT NOT NULL, action TEXT NOT NULL, count INTEGER DEFAULT 1, window_start TEXT NOT NULL`\n- **`types.ts`**: Shared TypeScript types (`Account`, `OTPToken`, `RateLimitEntry`)\n- **`logger.ts`**: Pino logger instance with pretty-print in dev\n\n### `packages/pds-sidecar/packages/auth-service`\nThe Express auth service (skeleton only in this task):\n- `src/index.ts`: Create Express app, add JSON body parser, add a health check route `GET /health` that returns `{ status: 'ok' }`. Listen on `process.env.AUTH_PORT || 3001`.\n- Dependencies: express, cors, cookie-parser\n\n### `packages/pds-sidecar/packages/pds-core`\nThe PDS wrapper (skeleton only in this task):\n- `src/index.ts`: Import `@atproto/pds` and create a minimal PDS startup script. For now, just log 'PDS core starting...' and export a placeholder `startPDS()` function.\n- Dependencies: @atproto/pds\n\n### TypeScript config\n- Root `tsconfig.json` with project references\n- Each package has its own `tsconfig.json` extending root\n- Target: ES2022, module: Node16, strict: true\n\n### IMPORTANT: Do not modify the root scaffold package.json\nThe sidecar has its own independent package.json and node_modules. Run `npm install` from within `packages/pds-sidecar/`, not from the repo root.\n\n## Don't\n- Don't modify any files outside `packages/pds-sidecar/`\n- Don't implement any auth logic (that's later tasks)\n- Don't implement the OAuth metadata override (that's later)\n- Don't set up Docker yet (that's the deployment epic)\n- Don't install nodemailer yet (that's the OTP task)\n- Don't modify the root package.json or any scaffold files","acceptance_criteria":"1. `npm install` succeeds at the root\n2. `npm run build` compiles all three packages without errors\n3. Running `packages/auth-service` starts Express on port 3001 and `GET /health` returns `{ status: 'ok' }`\n4. SQLite database is created with the three tables when `createDatabase()` is called\n5. All TypeScript compiles with strict mode enabled\n6. `.gitignore` excludes node_modules, dist, *.sqlite","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-17T18:13:53.671557+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:38:19.085359+08:00","closed_at":"2026-02-17T18:38:19.085359+08:00","close_reason":"4a06158 Initialize pds-sidecar monorepo with shared, auth-service, pds-core packages","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-qc3.1","depends_on_id":"hypercerts-qc3","type":"parent-child","created_at":"2026-02-17T18:13:53.672463+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-qc3.2","title":"Implement OTP generation, hashing, and verification service","description":"## Files\n- packages/shared/src/otp-service.ts (create)\n- packages/shared/src/otp-service.test.ts (create)\n\n## What to do\nImplement the OTP token service in the shared package. This handles generating, storing (hashed), and verifying one-time passcodes.\n\n### `otp-service.ts`\n\nExport a class `OTPService` that takes a Database instance (from `db.ts`) in its constructor.\n\n**Methods:**\n\n#### `async generateOTP(email: string): Promise\u003c{ code: string; expiresAt: Date }\u003e`\n1. Generate an 8-digit random numeric code using `crypto.randomInt(10000000, 99999999)`\n2. Hash the code with SHA-256: `crypto.createHash('sha256').update(code).digest('hex')`\n3. Calculate expiry: `new Date(Date.now() + 15 * 60 * 1000)` (15 minutes)\n4. Mark any existing unused tokens for this email as used (prevent token accumulation)\n5. Insert into `otp_tokens` table: `{ email, token_hash, attempts: 0, max_attempts: 5, expires_at, used: 0 }`\n6. Return `{ code, expiresAt }` (the plaintext code — caller sends it via email)\n\n#### `async verifyOTP(email: string, code: string): Promise\u003c{ valid: boolean; error?: string }\u003e`\n1. Hash the provided code with SHA-256\n2. Find the most recent unused, non-expired token for this email: `SELECT * FROM otp_tokens WHERE email = ? AND used = 0 AND expires_at \u003e datetime('now') ORDER BY created_at DESC LIMIT 1`\n3. If no token found: return `{ valid: false, error: 'No valid code found. Please request a new one.' }`\n4. Increment the `attempts` counter on the token\n5. If `attempts \u003e= max_attempts`: mark token as used, return `{ valid: false, error: 'Too many attempts. Please request a new code.' }`\n6. Compare hashes using `crypto.timingSafeEqual(Buffer.from(storedHash, 'hex'), Buffer.from(providedHash, 'hex'))`\n7. If match: mark token as used, return `{ valid: true }`\n8. If no match: return `{ valid: false, error: 'Invalid code. Please try again.' }`\n\n#### `async cleanupExpired(): Promise\u003cnumber\u003e`\nDelete all tokens where `expires_at \u003c datetime('now')` or `used = 1`. Return count of deleted rows. This should be called periodically (e.g., every 5 minutes via setInterval).\n\n### Test file: `otp-service.test.ts`\nWrite vitest tests covering:\n1. `generateOTP` returns an 8-digit numeric string\n2. `verifyOTP` succeeds with correct code\n3. `verifyOTP` fails with wrong code\n4. `verifyOTP` fails after code expires (mock time or use short expiry)\n5. `verifyOTP` fails after max attempts exceeded\n6. `verifyOTP` fails when no token exists\n7. Generating a new OTP invalidates the previous one for the same email\n8. `cleanupExpired` removes old tokens\n9. Timing-safe comparison is used (verify by checking the code path, not timing)\n\nUse an in-memory SQLite database for tests (`createDatabase(':memory:')`).\n\n## Don't\n- Don't implement rate limiting here (that's a separate service)\n- Don't implement email sending here (that's a separate task)\n- Don't store plaintext codes in the database\n- Don't use Math.random() — use crypto.randomInt() for cryptographic randomness","acceptance_criteria":"1. `npm test` passes all 9+ test cases\n2. OTP codes are exactly 8 digits (numeric only)\n3. Codes are stored as SHA-256 hashes, never plaintext\n4. Verification uses `crypto.timingSafeEqual`\n5. Tokens are single-use (marked used after successful verification)\n6. Tokens expire after 15 minutes\n7. Max 5 verification attempts per token\n8. Generating a new OTP for the same email invalidates previous unused tokens","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-17T18:14:15.505739+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:40:13.952341+08:00","closed_at":"2026-02-17T18:40:13.952341+08:00","close_reason":"00d3e19 Implement OTP generation, hashing, and verification service","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-qc3.2","depends_on_id":"hypercerts-qc3","type":"parent-child","created_at":"2026-02-17T18:14:15.506563+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.2","depends_on_id":"hypercerts-qc3.1","type":"blocks","created_at":"2026-02-17T18:14:15.507565+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-qc3.3","title":"Implement rate limiting service","description":"## Files\n- packages/shared/src/rate-limiter.ts (create)\n- packages/shared/src/rate-limiter.test.ts (create)\n\n## What to do\nImplement a rate limiting service that enforces per-email and per-IP limits for OTP requests. Uses the `rate_limits` table from the shared database.\n\n### `rate-limiter.ts`\n\nExport a class `RateLimiter` that takes a Database instance in its constructor.\n\n**Methods:**\n\n#### `async checkLimit(key: string, action: string, maxCount: number, windowMinutes: number): Promise\u003c{ allowed: boolean; retryAfterSeconds?: number }\u003e`\n1. Calculate window start: `new Date(Date.now() - windowMinutes * 60 * 1000)`\n2. Query: `SELECT SUM(count) as total FROM rate_limits WHERE key = ? AND action = ? AND window_start \u003e ?`\n3. If `total \u003e= maxCount`: return `{ allowed: false, retryAfterSeconds: \u003cseconds until oldest entry in window expires\u003e }`\n4. Otherwise: insert or update the rate limit entry for the current minute window, return `{ allowed: true }`\n\n#### `async recordAction(key: string, action: string): Promise\u003cvoid\u003e`\nInsert a new rate limit entry or increment the count for the current minute window.\n\n#### `async cleanupOld(): Promise\u003cnumber\u003e`\nDelete entries older than 1 hour. Return count deleted.\n\n### Predefined limit configurations (export as constants):\n\n```typescript\nexport const RATE_LIMITS = {\n  OTP_PER_EMAIL: { action: 'otp_send', maxCount: 5, windowMinutes: 60 },\n  OTP_PER_EMAIL_BURST: { action: 'otp_send', maxCount: 3, windowMinutes: 15 },\n  OTP_PER_IP: { action: 'otp_send_ip', maxCount: 10, windowMinutes: 15 },\n  VERIFY_PER_IP: { action: 'otp_verify_ip', maxCount: 20, windowMinutes: 15 },\n} as const;\n```\n\n### Express middleware factory (export):\n```typescript\nexport function rateLimitMiddleware(\n  rateLimiter: RateLimiter,\n  keyExtractor: (req: Request) =\u003e string,\n  config: { action: string; maxCount: number; windowMinutes: number }\n): RequestHandler\n```\n- Extract key from request using `keyExtractor`\n- Call `checkLimit`\n- If not allowed: respond with 429 and `Retry-After` header\n- If allowed: call `recordAction` and `next()`\n\n### Tests\n1. Allows requests under the limit\n2. Blocks requests over the limit\n3. Returns correct `retryAfterSeconds`\n4. Different keys are tracked independently\n5. Different actions are tracked independently\n6. Cleanup removes old entries\n7. Middleware returns 429 when rate limited\n\nUse in-memory SQLite for tests.\n\n## Don't\n- Don't use in-memory-only rate limiting (must survive process restart via SQLite)\n- Don't implement Redis-based rate limiting (SQLite is sufficient for single-server)\n- Don't add Express as a dependency to the shared package — the middleware factory should accept generic types or be in a separate file that auth-service imports","acceptance_criteria":"1. `npm test` passes all 7+ test cases\n2. Rate limiter correctly blocks after maxCount requests within windowMinutes\n3. Rate limiter allows requests after the window expires\n4. Different keys and actions are tracked independently\n5. Middleware returns HTTP 429 with Retry-After header when rate limited\n6. Cleanup removes entries older than 1 hour","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":40,"created_at":"2026-02-17T18:14:34.643111+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:40:20.358772+08:00","closed_at":"2026-02-17T18:40:20.358772+08:00","close_reason":"614da36 Implement rate limiting service","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-qc3.3","depends_on_id":"hypercerts-qc3","type":"parent-child","created_at":"2026-02-17T18:14:34.644336+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.3","depends_on_id":"hypercerts-qc3.1","type":"blocks","created_at":"2026-02-17T18:14:34.645479+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-qc3.4","title":"Implement HMAC-signed callback between sidecar and PDS","description":"## Files\n- packages/shared/src/callback-signer.ts (create)\n- packages/shared/src/callback-signer.test.ts (create)\n\n## What to do\nImplement the cryptographic signing and verification for the callback between the sidecar auth service and the PDS. This is the **critical security fix** over the magic-pds reference implementation, which uses unsigned callbacks (enabling account takeover).\n\n### Background\nAfter the sidecar verifies a user's OTP, it needs to tell the PDS 'this user is authenticated, issue an auth code.' In magic-pds, this is done via a plain redirect with query parameters (`?email=user@example.com\u0026approved=1`). Anyone who can reach the PDS's callback endpoint can forge this. Our implementation signs the callback with HMAC-SHA256 using a shared secret.\n\n### `callback-signer.ts`\n\nExport a class `CallbackSigner` that takes a `secret: string` in its constructor.\n\n**Methods:**\n\n#### `sign(params: CallbackParams): string`\n```typescript\ninterface CallbackParams {\n  requestUri: string;   // The PAR request URI (urn:ietf:params:oauth:request_uri:...)\n  email: string;        // The authenticated user's email\n  approved: boolean;    // Whether the user approved the request\n  newAccount: boolean;  // Whether this is a new account creation\n  timestamp: number;    // Unix timestamp in seconds (Date.now() / 1000)\n}\n```\n1. Serialize params deterministically: `${requestUri}|${email}|${approved}|${newAccount}|${timestamp}`\n2. Compute HMAC-SHA256: `crypto.createHmac('sha256', this.secret).update(serialized).digest('hex')`\n3. Return the hex signature\n\n#### `verify(params: CallbackParams, signature: string, maxAgeSeconds: number = 300): { valid: boolean; error?: string }`\n1. Check timestamp is within `maxAgeSeconds` of current time (prevents replay attacks). Return `{ valid: false, error: 'Callback expired' }` if too old.\n2. Recompute the expected signature using `sign(params)`\n3. Compare using `crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expected, 'hex'))`\n4. Return `{ valid: true }` or `{ valid: false, error: 'Invalid signature' }`\n\n#### `buildCallbackUrl(baseUrl: string, params: CallbackParams): string`\nBuild the full callback URL with all params as query parameters plus the signature:\n```\n{baseUrl}/oauth/magic-callback?request_uri={requestUri}\u0026email={email}\u0026approved={approved}\u0026new_account={newAccount}\u0026timestamp={timestamp}\u0026sig={signature}\n```\n\n#### `static parseCallbackUrl(url: URL): { params: CallbackParams; signature: string }`\nParse query parameters back into `CallbackParams` and extract the signature.\n\n### Tests\n1. `sign` produces a consistent signature for the same inputs\n2. `sign` produces different signatures for different inputs\n3. `verify` succeeds with a valid signature\n4. `verify` fails with a tampered email\n5. `verify` fails with a tampered approved flag\n6. `verify` fails with a wrong secret\n7. `verify` fails when timestamp is too old (expired)\n8. `verify` fails when timestamp is in the future (clock skew \u003e maxAge)\n9. `buildCallbackUrl` produces a valid URL with all params\n10. `parseCallbackUrl` round-trips with `buildCallbackUrl`\n11. Timing-safe comparison is used\n\n## Don't\n- Don't use JWT for this (HMAC is simpler and sufficient for server-to-server within the same deployment)\n- Don't use asymmetric keys (shared secret is fine since both services are co-deployed)\n- Don't hardcode the secret — it's passed to the constructor","acceptance_criteria":"1. `npm test` passes all 11 test cases\n2. Signatures are HMAC-SHA256 hex strings\n3. Verification uses `crypto.timingSafeEqual`\n4. Expired callbacks (\u003e5 min by default) are rejected\n5. Tampered parameters are rejected\n6. `buildCallbackUrl` and `parseCallbackUrl` round-trip correctly","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":40,"created_at":"2026-02-17T18:14:57.2573+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:39:54.935494+08:00","closed_at":"2026-02-17T18:39:54.935494+08:00","close_reason":"ca63038 Implement HMAC-signed callback signer with 11 tests","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-qc3.4","depends_on_id":"hypercerts-qc3","type":"parent-child","created_at":"2026-02-17T18:14:57.258125+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.4","depends_on_id":"hypercerts-qc3.1","type":"blocks","created_at":"2026-02-17T18:14:57.259258+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-qc3.5","title":"Implement OTP email sending service","description":"## Files\n- packages/shared/src/mailer.ts (create)\n- packages/shared/src/mailer.test.ts (create)\n\n## What to do\nImplement the email sending service for OTP codes. Uses nodemailer with SMTP transport.\n\n### `mailer.ts`\n\nExport a class `Mailer` with constructor:\n```typescript\nconstructor(config: {\n  host: string;\n  port: number;\n  secure: boolean;\n  auth: { user: string; pass: string };\n  from: string;  // e.g., 'Hypercerts \u003cnoreply@certified.app\u003e'\n})\n```\n\n**Methods:**\n\n#### `async sendOTP(to: string, code: string, options?: { appName?: string }): Promise\u003cvoid\u003e`\nSend an email with the OTP code. The email should be:\n- **Subject:** `Your sign-in code: ${code}` (include code in subject for quick access on mobile)\n- **From:** The configured `from` address\n- **HTML body:** Clean, minimal HTML email:\n  - App name heading (defaults to 'Hypercerts Scaffold')\n  - 'Your sign-in code is:' text\n  - The 8-digit code displayed large and monospaced (easy to read/copy)\n  - 'This code expires in 15 minutes.' subtext\n  - 'If you didn't request this code, you can safely ignore this email.' footer\n- **Text body:** Plain text fallback with the same content\n\n#### `async verifyConnection(): Promise\u003cboolean\u003e`\nCall `transporter.verify()` to check SMTP connectivity. Return true/false. Log errors but don't throw.\n\n### Test file\n- Mock nodemailer's `createTransport` to capture sent emails\n- Test that `sendOTP` calls `sendMail` with correct to, from, subject, html, text\n- Test that the code appears in both HTML and text bodies\n- Test that `verifyConnection` returns false when SMTP is unreachable\n- Test custom `appName` appears in the email\n\n## Don't\n- Don't implement custom email templates per OAuth client (that's a future enhancement)\n- Don't implement email template fetching from URLs (SSRF risk — magic-pds had this issue)\n- Don't send emails in tests — mock the transport","acceptance_criteria":"1. `npm test` passes all test cases\n2. `sendOTP` sends an email with the code in subject, HTML body, and text body\n3. Email has both HTML and plain text versions\n4. Code is displayed prominently in the HTML (large, monospaced)\n5. `verifyConnection` returns true/false without throwing\n6. No real emails are sent during tests (transport is mocked)","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":30,"created_at":"2026-02-17T18:15:14.469648+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:40:31.949481+08:00","closed_at":"2026-02-17T18:40:31.949481+08:00","close_reason":"d5ae3b7 Implement OTP email sending service","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-qc3.5","depends_on_id":"hypercerts-qc3","type":"parent-child","created_at":"2026-02-17T18:15:14.470511+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.5","depends_on_id":"hypercerts-qc3.1","type":"blocks","created_at":"2026-02-17T18:15:14.471624+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-qc3.6","title":"Implement auth service routes: send-code, verify-code, authorize","description":"## Files\n- packages/auth-service/src/routes/authorize.ts (create)\n- packages/auth-service/src/routes/send-code.ts (create)\n- packages/auth-service/src/routes/verify-code.ts (create)\n- packages/auth-service/src/middleware/security.ts (create)\n- packages/auth-service/src/middleware/csrf.ts (create)\n- packages/auth-service/src/index.ts (modify)\n\n## What to do\nImplement the three core auth service routes that handle the email OTP flow. These are the routes that the user's browser interacts with after being redirected from the PDS.\n\n### Flow overview\n1. PDS redirects user to sidecar: `GET /oauth/authorize?request_uri=urn:...\u0026client_id=...\u0026login_hint=user@example.com`\n2. Sidecar shows email form (or auto-sends OTP if `login_hint` is present)\n3. User submits email → `POST /auth/send-code` → sidecar sends OTP email\n4. User enters code → `POST /auth/verify-code` → sidecar verifies OTP\n5. On success: sidecar builds HMAC-signed callback URL and redirects to PDS\n\n### `middleware/security.ts`\nAdd security headers to all responses:\n- `Strict-Transport-Security: max-age=31536000; includeSubDomains`\n- `X-Content-Type-Options: nosniff`\n- `X-Frame-Options: DENY`\n- `Content-Security-Policy: default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:`\n\n### `middleware/csrf.ts`\nImplement double-submit cookie CSRF protection:\n- On GET requests: generate a random CSRF token, set it as a cookie (`csrf-token`, HttpOnly=false so JS can read it, Secure in production, SameSite=Lax`)\n- On POST requests: compare the `csrf-token` cookie with the `x-csrf-token` header using `crypto.timingSafeEqual`\n- Reject with 403 if they don't match\n\n### `routes/authorize.ts` — `GET /oauth/authorize`\nThis is the entry point — the PDS redirects here after PAR.\n\n**Query params:** `request_uri`, `client_id`, `login_hint` (optional)\n\n**Logic:**\n1. Validate `request_uri` is present (required)\n2. Store `request_uri` and `client_id` in a session cookie (encrypted or signed) so they survive the send-code/verify-code round-trip\n3. If `login_hint` is present and looks like an email (contains `@`):\n   - Auto-trigger OTP send (call OTPService.generateOTP + Mailer.sendOTP)\n   - Render the OTP verification page directly (skip email input)\n4. If no `login_hint` or it's not an email:\n   - Render the email input page\n\n**Pages:** Server-rendered HTML (use a simple template function, no React needed):\n- Email input page: form with email input, 'Continue' button\n- OTP verification page: form with 8-digit code input, 'Verify' button, 'Resend code' link, masked email display (e.g., 'u***@example.com')\n\n### `routes/send-code.ts` — `POST /auth/send-code`\n**Body:** `{ email: string }`\n\n**Logic:**\n1. Validate CSRF token\n2. Check rate limits (per-email burst + hourly, per-IP)\n3. Normalize email (lowercase, trim)\n4. Generate OTP via OTPService\n5. Send OTP via Mailer\n6. **Anti-enumeration:** Always respond with success, even if the email doesn't exist in the system. The OTP is generated regardless — if the email is new, the account will be created after verification.\n7. Store email in session cookie for the verify step\n8. Respond with redirect to OTP verification page (or JSON `{ success: true }` if called via fetch)\n\n### `routes/verify-code.ts` — `POST /auth/verify-code`\n**Body:** `{ code: string }`\n\n**Logic:**\n1. Validate CSRF token\n2. Check rate limits (per-IP verify limit)\n3. Retrieve email from session cookie\n4. Verify OTP via OTPService\n5. If invalid: re-render OTP page with error message\n6. If valid:\n   a. Check if email exists in the accounts table\n   b. If new email: set `newAccount = true`\n   c. Build HMAC-signed callback URL using CallbackSigner\n   d. Redirect to PDS callback: `{pdsUrl}/oauth/magic-callback?request_uri=...\u0026email=...\u0026approved=1\u0026new_account=...\u0026timestamp=...\u0026sig=...`\n\n### Session cookies\nUse a signed cookie (using the HMAC secret) to store the OAuth flow state across requests:\n```typescript\ninterface AuthFlowSession {\n  requestUri: string;\n  clientId: string;\n  email?: string;\n}\n```\nSign with HMAC-SHA256 using the same shared secret. Set HttpOnly, Secure (in production), SameSite=Lax, Max-Age=600 (10 minutes).\n\n## Don't\n- Don't use React or any frontend framework for the HTML pages — use template literals\n- Don't implement the PDS-side callback handler (that's a separate task in pds-core)\n- Don't implement consent screens (that's a future task)\n- Don't fetch OAuth client metadata for branding (future enhancement)","acceptance_criteria":"1. GET /oauth/authorize with `request_uri` renders an email input page\n2. GET /oauth/authorize with `request_uri` and `login_hint=user@example.com` auto-sends OTP and renders OTP verification page\n3. POST /auth/send-code sends an OTP email and redirects to verification page\n4. POST /auth/send-code returns success even for unknown emails (anti-enumeration)\n5. POST /auth/verify-code with correct code redirects to PDS callback with HMAC signature\n6. POST /auth/verify-code with wrong code re-renders OTP page with error\n7. CSRF protection rejects POST requests without valid token\n8. Rate limiting returns 429 when limits exceeded\n9. Security headers are present on all responses\n10. Session state survives across the authorize → send-code → verify-code flow","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-17T18:15:49.998905+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:46:19.914818+08:00","closed_at":"2026-02-17T18:46:19.914818+08:00","close_reason":"5bdd18a Implement auth service routes: send-code, verify-code, authorize","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-qc3.6","depends_on_id":"hypercerts-qc3","type":"parent-child","created_at":"2026-02-17T18:15:50.001457+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.6","depends_on_id":"hypercerts-qc3.2","type":"blocks","created_at":"2026-02-17T18:15:50.003149+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.6","depends_on_id":"hypercerts-qc3.3","type":"blocks","created_at":"2026-02-17T18:15:50.00393+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.6","depends_on_id":"hypercerts-qc3.4","type":"blocks","created_at":"2026-02-17T18:15:50.004741+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.6","depends_on_id":"hypercerts-qc3.5","type":"blocks","created_at":"2026-02-17T18:15:50.005499+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-qc3.7","title":"Implement PDS core wrapper with OAuth metadata override and magic-callback endpoint","description":"## Files\n- packages/pds-core/src/index.ts (modify)\n- packages/pds-core/src/metadata-override.ts (create)\n- packages/pds-core/src/magic-callback.ts (create)\n- packages/pds-core/src/account-creator.ts (create)\n\n## What to do\nImplement the PDS wrapper that starts a stock `@atproto/pds` instance with two additions: (1) an Express middleware that overrides the OAuth authorization server metadata to point to the sidecar, and (2) a `/oauth/magic-callback` endpoint that accepts HMAC-signed callbacks from the sidecar and issues OAuth authorization codes.\n\n### Background\nThe stock PDS serves `GET /.well-known/oauth-authorization-server` which returns metadata including `authorization_endpoint` pointing to itself. We intercept this and rewrite `authorization_endpoint` to point to the sidecar auth service. All other OAuth endpoints (PAR, token, JWKS) remain on the PDS.\n\nAfter the sidecar verifies the user's OTP, it redirects the user's browser to `/oauth/magic-callback` on the PDS with HMAC-signed parameters. The PDS verifies the signature, then uses its internal `OAuthProvider` to issue an authorization code and redirect the user back to the client app.\n\n### `metadata-override.ts`\nExport a function `createMetadataOverride(authServiceUrl: string): RequestHandler` that:\n1. Intercepts `GET /.well-known/oauth-authorization-server`\n2. Calls `next()` to let the stock PDS generate the response\n3. Captures the response body (use response interception — override `res.json` or use a response-capture middleware pattern)\n4. Replaces `authorization_endpoint` with `${authServiceUrl}/oauth/authorize`\n5. Sends the modified response\n\n**Important:** This middleware must be mounted BEFORE the PDS middleware in the Express stack so it can intercept the response.\n\n### `magic-callback.ts`\nExport a function `createMagicCallback(pds: PDS, callbackSigner: CallbackSigner): RequestHandler` that handles `GET /oauth/magic-callback`:\n\n1. Parse query parameters using `CallbackSigner.parseCallbackUrl`\n2. Verify the HMAC signature using `callbackSigner.verify()`\n3. If invalid: return 403 with error\n4. If `approved !== true`: return 403 'Request not approved'\n5. If `newAccount === true`:\n   - Call `accountCreator.createAccount(email)` to create a new ATProto account\n6. Look up the user's DID from the email (query the sidecar's accounts table or the PDS's internal account manager)\n7. Use the PDS's internal `OAuthProvider` to:\n   a. Load the pending PAR request using `requestUri`\n   b. Create or load a device session for the user\n   c. Mark the request as authorized for the user's DID\n   d. Generate an authorization code\n   e. Build the redirect URL back to the client app\n8. Redirect the user's browser to the client app with the authorization code\n\n**Accessing PDS internals:** The PDS instance exposes `pds.ctx.oauthProvider` (accessed via `as any` cast since it's not part of the public API). Key internal APIs:\n- `pds.ctx.oauthProvider.deviceManager` — manage device sessions\n- `pds.ctx.oauthProvider.requestManager` — load PAR requests\n- `pds.ctx.accountManager` — look up accounts by email\n\n**Note:** These are internal APIs that may change between `@atproto/pds` versions. Document each access point with a comment noting the PDS version it was tested against.\n\n### `account-creator.ts`\nExport a class `AccountCreator` that creates new ATProto accounts on the PDS:\n\n```typescript\nasync createAccount(email: string): Promise\u003c{ did: string; handle: string }\u003e\n```\n\n1. Generate a random handle: `${randomBase36(6)}.${pdsDomain}` (e.g., `a3x9kf.pds.certs.network`)\n2. Generate a random throwaway password: `crypto.randomBytes(64).toString('hex')`\n3. Call the PDS's internal account creation (via `pds.ctx.accountManager` or the XRPC endpoint `com.atproto.server.createAccount`)\n4. Store the email→DID mapping in the sidecar's accounts table\n5. Return `{ did, handle }`\n\n### `index.ts` — PDS startup\n1. Import and configure `@atproto/pds`\n2. Create the PDS instance with environment-based config\n3. Mount the metadata override middleware BEFORE PDS middleware\n4. Mount the magic-callback endpoint\n5. Start the server\n\n**Environment variables needed:**\n- `PDS_HOSTNAME` — e.g., `pds.certs.network`\n- `PDS_DATA_DIRECTORY` — path to PDS data\n- `PDS_BLOBSTORE_DISK_LOCATION` — blob storage path\n- `PDS_DID_PLC_URL` — PLC directory URL\n- `PDS_ADMIN_PASSWORD` — PDS admin password\n- `AUTH_SERVICE_URL` — sidecar URL (e.g., `https://auth.pds.certs.network`)\n- `CALLBACK_SECRET` — shared HMAC secret for signed callbacks\n\n## Don't\n- Don't fork or modify `@atproto/pds` source code — use it as a dependency\n- Don't implement the auth service routes (those are in the auth-service package)\n- Don't implement email sending (that's in the auth-service via shared mailer)\n- Don't disable stock login endpoints yet (that's a separate hardening task)\n- Don't implement consent screens","acceptance_criteria":"1. PDS starts and serves `/.well-known/oauth-authorization-server` with the sidecar's `authorization_endpoint`\n2. All other OAuth metadata fields (PAR, token, JWKS endpoints) still point to the PDS\n3. `GET /oauth/magic-callback` with valid HMAC signature issues an auth code and redirects to client\n4. `GET /oauth/magic-callback` with invalid signature returns 403\n5. `GET /oauth/magic-callback` with expired timestamp returns 403\n6. New account creation generates a random handle and stores email→DID mapping\n7. The stock PDS OAuth endpoints (PAR, token exchange) still work normally","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-17T18:16:25.5113+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:45:14.654387+08:00","closed_at":"2026-02-17T18:45:14.654387+08:00","close_reason":"79a6915 Implement PDS core wrapper with OAuth metadata override and magic-callback endpoint","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-qc3.7","depends_on_id":"hypercerts-qc3","type":"parent-child","created_at":"2026-02-17T18:16:25.512781+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-qc3.7","depends_on_id":"hypercerts-qc3.4","type":"blocks","created_at":"2026-02-17T18:16:25.514074+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-ril","title":"Fix: vitest missing from auth-service devDependencies (from hypercerts-qc3.6)","description":"Review of hypercerts-qc3.6 found: auth-service/package.json has a 'test': 'vitest run' script and auth.test.ts uses vitest, but vitest is not listed in devDependencies. The test suite will fail to run in CI or a fresh install because vitest is only available transitively via @certified/shared. Evidence: packages/auth-service/package.json devDependencies has no vitest entry; packages/shared/package.json has vitest ^1.4.0 in devDependencies. Fix: add vitest to auth-service devDependencies.","status":"closed","priority":1,"issue_type":"bug","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:52:56.283264+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.66292+08:00","closed_at":"2026-02-17T18:56:11.662923+08:00","dependencies":[{"issue_id":"hypercerts-ril","depends_on_id":"hypercerts-qc3.6","type":"discovered-from","created_at":"2026-02-17T18:52:56.366227+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-08v","title":"Epic: OTP Service Backend (certified.app reverse proxy)","description":"## Goal\nBuild the standalone OTP service that provides passwordless email login for all Certified apps. Deployed at certified.app as a reverse proxy in front of the stock PDS.\n\n## Architecture\nThe OTP service is a standalone Node.js backend (separate repo) that:\n1. Acts as a reverse proxy in front of the stock PDS at certified.app\n2. Intercepts the PDS OAuth authorize endpoint to show an email/OTP login UI\n3. Manages email → account mapping, OTP generation/validation, and hidden password storage\n4. After OTP verification, authenticates against the PDS same-origin (through the proxy) and sets the device session cookie naturally\n5. Proxies all other PDS traffic transparently\n\n### Reverse Proxy Model\nThe OTP service is the public-facing server at certified.app. The PDS runs internally (e.g., localhost:2583). The proxy intercepts GET /oauth/authorize to show the OTP login flow, and forwards everything else to the PDS unchanged. Since both are on the same origin, the PDS sign-in API same-origin checks pass naturally, and device cookies are set on certified.app without any cross-domain issues.\n\n### Traffic Routing\n```\nBrowser → certified.app (OTP service / reverse proxy)\n              │\n              ├── GET /oauth/authorize     → INTERCEPTED: OTP service shows email/OTP UI\n              ├── POST /api/v1/sign-in     → INTERCEPTED: OTP service authenticates with stored password\n              ├── POST /oauth/par          → Proxied to PDS\n              ├── POST /oauth/token        → Proxied to PDS\n              ├── GET /.well-known/*       → Proxied to PDS\n              ├── GET /xrpc/*              → Proxied to PDS\n              └── everything else          → Proxied to PDS\n```\n\n### Responsibilities\n- Reverse proxy: forward all non-intercepted traffic to PDS_INTERNAL_URL\n- Email → account lookup (maintains an email → DID mapping in PostgreSQL)\n- OTP generation, email delivery, and validation\n- Auto-generated password management (create, store AES-256-GCM encrypted, use for PDS auth)\n- Account creation on first login (calls com.atproto.server.createAccount XRPC)\n- Handle auto-assignment ({localpart}.certified.app, numeric suffix for collisions)\n\n## Data Stored\n- accounts table: email (unique), did, encrypted_password, handle, pds_url, created_at\n- otp_codes table: email, code (hashed), expires_at, used, attempts\n- rate_limits table: key (email or IP), window_start, count\n\n## Security Requirements\n- OTP codes: 6 digits, 5-10 min expiry, single-use, invalidated after 3 failed attempts\n- Rate limiting: max 5 OTP requests/email/hour, max 20/IP/hour\n- Passwords: AES-256-GCM encrypted at rest, never logged, never sent to client\n- HTTPS only, no sensitive data in query params\n\n## Hard Constraints\n- NO PDS fork — stock PDS only\n- Separate repository, independently deployable\n\n## Reference\nSee docs/certified-implementation-spec.md in hypercerts-scaffold repo.","status":"open","priority":1,"issue_type":"epic","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:09:55.678086+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T17:59:59.609878+08:00","labels":["needs-integration-review"]}
{"id":"hypercerts-scaffold-08v.1","title":"Initialize OTP service project","description":"## What to Do\nInitialize a new standalone Node.js/TypeScript project for the OTP service. This service acts as a reverse proxy in front of the PDS and intercepts OAuth routes to provide email/OTP login. It will eventually live in its own repository but can be scaffolded locally first.\n\n### Project Setup\n- Initialize with: TypeScript, ESM modules, Node.js 20+\n- Framework: Hono (lightweight, fast, good TypeScript support) or Express\n- Package manager: pnpm\n- Structure:\n  ```\n  otp-service/\n  ├── src/\n  │   ├── index.ts              # Entry point, server setup\n  │   ├── config.ts             # Environment configuration\n  │   ├── routes/               # HTTP route handlers (intercepted routes)\n  │   ├── proxy/                # Reverse proxy logic\n  │   │   ├── proxy.ts          # Proxy middleware setup (forwards to PDS_INTERNAL_URL)\n  │   │   └── intercepts.ts     # Route interception rules\n  │   ├── services/             # Business logic\n  │   ├── db/                   # Database schema, migrations, queries\n  │   └── lib/                  # Utilities (encryption, email, etc.)\n  ├── Dockerfile\n  ├── package.json\n  ├── tsconfig.json\n  └── .env.example\n  ```\n- Health check endpoint: GET /health → { status: 'ok' }\n- Default behaviour: all requests (except /health) are proxied to PDS_INTERNAL_URL\n- Request logging middleware\n- Error handling middleware with typed error responses\n- Graceful shutdown handling\n\n### Dependencies\n- hono (or express)\n- http-proxy-middleware (or hono built-in proxy)\n- drizzle-orm + drizzle-kit (for DB)\n- postgres (pg driver)\n- nodemailer\n- @atproto/api (for PDS XRPC calls)\n- dotenv\n- zod (for validation)\n\n### Environment Variables (.env.example)\n```\nPORT=3000\nPDS_INTERNAL_URL=http://localhost:2583\nDATABASE_URL=postgresql://...\nCREDENTIAL_ENCRYPTION_KEY=\u003c64 hex chars\u003e\nSMTP_URL=smtps://...\nFROM_EMAIL=noreply@certified.app\n```\n\n### Don't\n- Don't add business logic yet — just the skeleton with proxy passthrough\n- Don't deploy yet — local development only\n- Don't use a monorepo setup — standalone project\n- Don't intercept any routes yet — just proxy everything to PDS_INTERNAL_URL\n\n## Acceptance Criteria\n1. Project initializes and compiles with TypeScript\n2. Server starts and responds to GET /health\n3. All requests (except /health) are proxied to PDS_INTERNAL_URL\n4. Proxy correctly forwards headers (Host, X-Forwarded-For, etc.)\n5. All listed dependencies are in package.json\n6. Dockerfile builds successfully\n7. .env.example has all required env var placeholders","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:12:51.943307+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:50:04.334361+08:00","closed_at":"2026-02-18T18:50:04.334361+08:00","close_reason":"29f5539 Initialize OTP service project","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.1","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:12:51.945532+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.2","title":"Database schema and migrations","description":"## What to Do\nSet up the PostgreSQL database schema for the OTP service using Drizzle ORM.\n\n### Schema\nDefine three tables:\n\n#### accounts\n| Column | Type | Constraints |\n|--------|------|-------------|\n| id | uuid | PK, default gen_random_uuid() |\n| email | varchar(255) | UNIQUE, NOT NULL, indexed |\n| did | varchar(255) | UNIQUE, NOT NULL, indexed |\n| handle | varchar(255) | UNIQUE, NOT NULL |\n| encrypted_password | text | NOT NULL |\n| pds_url | varchar(255) | NOT NULL, default 'https://certified.app' |\n| created_at | timestamp | NOT NULL, default now() |\n| updated_at | timestamp | NOT NULL, default now() |\n\n#### otp_codes\n| Column | Type | Constraints |\n|--------|------|-------------|\n| id | uuid | PK, default gen_random_uuid() |\n| email | varchar(255) | NOT NULL, indexed |\n| code_hash | varchar(255) | NOT NULL |\n| expires_at | timestamp | NOT NULL |\n| used | boolean | NOT NULL, default false |\n| attempts | integer | NOT NULL, default 0 |\n| created_at | timestamp | NOT NULL, default now() |\n\n#### rate_limits\n| Column | Type | Constraints |\n|--------|------|-------------|\n| id | uuid | PK, default gen_random_uuid() |\n| key | varchar(255) | NOT NULL, indexed (email or IP address) |\n| type | varchar(50) | NOT NULL ('email_otp' or 'ip_otp') |\n| window_start | timestamp | NOT NULL |\n| count | integer | NOT NULL, default 1 |\n\n### Migrations\n- Use Drizzle Kit for migration generation\n- Create initial migration with all three tables\n- Add a migration script to package.json: 'db:migrate', 'db:push', 'db:studio'\n\n### Connection\n- Connection string from DATABASE_URL env var\n- Connection pooling (max 10 connections)\n- Export a db instance from src/db/index.ts\n\n### Don't\n- Don't add any business logic or queries — just schema and connection\n- Don't use Redis for this (the old approach) — use PostgreSQL\n- Don't forget the pds_url column (future multi-PDS extensibility)\n\n## Acceptance Criteria\n1. All three tables defined with correct columns and constraints\n2. Drizzle migration runs successfully against a local PostgreSQL\n3. db:migrate, db:push, db:studio scripts work\n4. DATABASE_URL env var is validated on startup\n5. Connection pooling is configured\n6. TypeScript types are generated from the schema","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:13:05.827589+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:52:04.366334+08:00","closed_at":"2026-02-18T18:52:04.366334+08:00","close_reason":"e5a7a07 feat: add Drizzle ORM schema and database connection","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.2","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:13:05.831194+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.2","depends_on_id":"hypercerts-scaffold-08v.1","type":"blocks","created_at":"2026-02-18T17:16:40.136064+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.3","title":"Encryption utilities and password management","description":"## What to Do\nBuild encryption utilities for storing auto-generated PDS passwords securely.\n\n### src/lib/encryption.ts\n- Use Node.js built-in crypto module (no external libraries)\n- AES-256-GCM encryption/decryption\n- Encryption key from env var CREDENTIAL_ENCRYPTION_KEY (32-byte hex string = 64 hex chars)\n\nExport functions:\n- `encrypt(plaintext: string): string` — returns `iv:authTag:ciphertext` (all base64-encoded)\n- `decrypt(encrypted: string): string` — parses the format and decrypts\n- `generatePassword(length?: number): string` — generates a cryptographically random password, default 64 chars, using crypto.randomBytes. Use alphanumeric + special chars for maximum entropy.\n- `hashOTP(code: string): string` — SHA-256 hash of OTP code for storage (OTP codes are hashed, not encrypted, since we only need to verify them)\n\n### Validation\n- CREDENTIAL_ENCRYPTION_KEY must be exactly 64 hex characters (32 bytes)\n- Throw descriptive error on startup if missing or invalid\n- Never log the encryption key or any passwords\n\n### Don't\n- Don't use external encryption libraries\n- Don't store passwords or OTP codes in plaintext\n- Don't use ECB mode or any insecure cipher mode\n- Don't use the same key for encryption and hashing\n\n## Acceptance Criteria\n1. encrypt() + decrypt() roundtrip preserves the original plaintext\n2. generatePassword() returns a high-entropy string of the specified length\n3. hashOTP() produces consistent hashes for the same input\n4. CREDENTIAL_ENCRYPTION_KEY is validated on import (64 hex chars)\n5. All functions are typed with TypeScript\n6. No external crypto dependencies","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:13:17.886291+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:51:47.597495+08:00","closed_at":"2026-02-18T18:51:47.597495+08:00","close_reason":"5ab901f feat: add AES-256-GCM encryption utilities","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.3","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:13:17.88768+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.3","depends_on_id":"hypercerts-scaffold-08v.1","type":"blocks","created_at":"2026-02-18T17:16:40.25438+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.4","title":"Account management service (PDS XRPC integration)","description":"## What to Do\nBuild the service that manages Certified accounts — creating them on the PDS and storing credentials locally.\n\n### src/services/account-service.ts\nUses @atproto/api (AtpAgent) to call PDS XRPC endpoints. The OTP service communicates with the PDS via its internal address (PDS_INTERNAL_URL), since the OTP service sits in front of the PDS as a reverse proxy.\n\n#### createAccount(email: string)\n1. Generate handle from email: extract local part (before @), sanitize to alphanumeric + hyphens only, lowercase. Format: {localpart}.certified.app (e.g., alice@example.com → alice.certified.app)\n2. Generate random password via generatePassword() (64 chars)\n3. Call com.atproto.server.createAccount on PDS with { handle, email, password }\n4. If handle collision (HandleNotAvailable error): append random 2-4 digit suffix, retry (max 3 retries)\n5. Encrypt password via encrypt()\n6. Store in accounts table: { email, did, handle, encrypted_password, pds_url }\n7. Return { did, handle }\n\n#### getAccountByEmail(email: string)\n- Query accounts table by email\n- Return account record or null\n\n#### getAccountByDid(did: string)\n- Query accounts table by DID\n- Return account record or null\n\n#### getDecryptedPassword(email: string)\n- Get account by email\n- Decrypt the stored password via decrypt()\n- Return the plaintext password (NEVER log this)\n\n#### accountExists(email: string)\n- Check if email exists in accounts table\n- Return boolean\n\n### Error Handling\n- Define PdsAccountError class with { code, message, status }\n- Handle specific XRPC errors: HandleNotAvailable, InvalidHandle, InvalidEmail, AccountTakedown, network errors\n- Log errors with context but NEVER log passwords\n\n### Configuration\n- PDS internal URL from PDS_INTERNAL_URL env var (e.g., http://localhost:2583). This is the internal address the OTP service uses to talk to the PDS behind the reverse proxy. Do NOT use the public certified.app URL for server-to-server calls.\n- Create AtpAgent instance pointed at PDS_INTERNAL_URL\n\n### Don't\n- Don't cache sessions — each createAccount/createSession is a fresh call\n- Don't use PDS admin endpoints — only public XRPC\n- Don't hardcode the PDS URL\n- Don't log passwords or encrypted passwords\n- Don't use the public URL (certified.app) for server-to-server PDS calls — use PDS_INTERNAL_URL\n\n## Acceptance Criteria\n1. createAccount() calls com.atproto.server.createAccount and stores credentials\n2. Handle generation sanitizes email local part correctly (format: {localpart}.certified.app)\n3. Handle collision retry works (appends suffix, max 3 retries)\n4. getAccountByEmail() returns null for unknown emails, correct data for known\n5. getDecryptedPassword() returns the original plaintext password\n6. Passwords are never logged\n7. PDS URL comes from PDS_INTERNAL_URL config, not hardcoded\n8. XRPC errors are wrapped in PdsAccountError","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:13:34.174272+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:54:29.499569+08:00","closed_at":"2026-02-18T18:54:29.499569+08:00","close_reason":"6a31d8c feat: add account management service with PDS XRPC integration","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.4","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:13:34.175173+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.4","depends_on_id":"hypercerts-scaffold-08v.2","type":"blocks","created_at":"2026-02-18T17:16:40.344472+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.4","depends_on_id":"hypercerts-scaffold-08v.3","type":"blocks","created_at":"2026-02-18T17:16:40.436309+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.5","title":"OTP generation, validation, and rate limiting","description":"## What to Do\nBuild the OTP service that generates codes, validates them, and enforces rate limits.\n\n### src/services/otp-service.ts\n\n#### generateOTP(email: string, ipAddress: string): Promise\u003c{ success: boolean, code?: string, error?: string }\u003e\n1. Check rate limits:\n   - Query rate_limits table for email key with type 'email_otp' in the last hour\n   - If count \u003e= 5, return { success: false, error: 'Too many requests. Try again later.' }\n   - Query rate_limits table for IP key with type 'ip_otp' in the last hour\n   - If count \u003e= 20, return { success: false, error: 'Too many requests. Try again later.' }\n2. Invalidate any existing OTP for this email (delete from otp_codes)\n3. Generate 6-digit code: crypto.randomInt(0, 999999).toString().padStart(6, '0')\n4. Hash the code via hashOTP()\n5. Store in otp_codes table: { email, code_hash, expires_at: now + 10 minutes, used: false, attempts: 0 }\n6. Increment rate limit counters (upsert into rate_limits)\n7. Return { success: true, code } — return the PLAINTEXT code so the caller (auth-orchestrator) can pass it to emailService.sendOTPEmail(). The code is NEVER stored in plaintext — only the hash is persisted.\n\n#### validateOTP(email: string, code: string): Promise\u003c{ valid: boolean, error?: string }\u003e\n1. Find the latest OTP record for this email where used = false\n2. If not found: return { valid: false, error: 'No verification code found. Please request a new one.' }\n3. If expires_at \u003c now: delete the record, return { valid: false, error: 'Code expired. Please request a new one.' }\n4. If attempts \u003e= 3: delete the record, return { valid: false, error: 'Too many failed attempts. Please request a new code.' }\n5. Hash the submitted code and compare with stored code_hash\n6. If no match: increment attempts, return { valid: false, error: 'Invalid code. Please try again.' }\n7. If match: mark as used (set used = true), return { valid: true }\n\n#### invalidateOTP(email: string): Promise\u003cvoid\u003e\n- Delete all OTP records for this email\n\n### Cleanup\n- Add a scheduled job or startup task that deletes expired OTP codes (expires_at \u003c now) and old rate limit entries (window_start \u003c 2 hours ago)\n- This can be a simple setInterval or a separate script\n\n### Imports\n- Import db from src/db/index.ts (set up in task 08v.2)\n- Import { hashOTP } from src/lib/encryption.ts (set up in task 08v.3)\n- Import { otpCodes, rateLimits } from src/db/schema.ts (set up in task 08v.2)\n- Use drizzle query builder for all DB operations\n\n### Don't\n- Don't store OTP codes in plaintext — hash them before storing\n- Don't allow unlimited attempts\n- Don't skip rate limiting\n- Don't log OTP codes (even in development, only log that a code was generated for a given email)\n- Don't use a fixed/predictable OTP generation method\n- Don't call emailService from here — return the plaintext code and let the orchestrator handle email delivery\n\n## Acceptance Criteria\n1. generateOTP() creates a 6-digit code, hashes it, stores in DB with correct expiry\n2. generateOTP() returns { success: true, code: '\u003cplaintext\u003e' } on success\n3. validateOTP() returns valid:true for correct code within expiry and attempt limit\n4. validateOTP() returns valid:false with appropriate error messages for each failure case\n5. validateOTP() increments attempt counter on failure\n6. validateOTP() marks code as used on success\n7. Rate limiting blocks more than 5 requests/email/hour and 20/IP/hour\n8. Expired codes and old rate limits are cleaned up\n9. OTP codes are never logged","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:13:51.388718+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:54:48.961617+08:00","closed_at":"2026-02-18T18:54:48.961617+08:00","close_reason":"7d84c53 feat: add OTP generation, validation, and rate limiting","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.5","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:13:51.389686+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.5","depends_on_id":"hypercerts-scaffold-08v.2","type":"blocks","created_at":"2026-02-18T17:16:40.537816+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.5","depends_on_id":"hypercerts-scaffold-08v.3","type":"blocks","created_at":"2026-02-18T17:16:40.628626+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.6","title":"Email delivery service (OTP emails)","description":"## What to Do\nBuild the email sending service for OTP delivery.\n\n### src/services/email-service.ts\n- Use Nodemailer to send OTP emails\n- Configure via SMTP_URL env var (standard Nodemailer connection string, e.g., smtps://user:pass@smtp.resend.com)\n- FROM_EMAIL env var for sender address (default: noreply@certified.app)\n\n#### sendOTPEmail(to: string, code: string): Promise\u003cvoid\u003e\n- Send an HTML email with the OTP code prominently displayed\n- Subject: 'Your Certified login code'\n- Body: Clean HTML template with:\n  - Certified branding (simple, not over-designed)\n  - The 6-digit code in large, monospace font\n  - Text: 'Your verification code is: {code}'\n  - Text: 'This code expires in 10 minutes.'\n  - Text: 'If you didn't request this code, you can safely ignore this email.'\n- Plain text fallback with the same content\n- Log successful sends (to address, timestamp) but NEVER log the code\n\n### Configuration\n- Validate SMTP_URL on startup (throw if missing)\n- Test SMTP connection on startup (optional, log warning if fails)\n\n### Don't\n- Don't use any email template library — inline HTML is fine for a simple OTP email\n- Don't log the OTP code\n- Don't send emails without rate limiting (the OTP service handles rate limiting)\n- Don't include sensitive data in email headers\n\n## Acceptance Criteria\n1. sendOTPEmail() sends an email via SMTP with the code in the body\n2. Email has both HTML and plain text versions\n3. Subject line is 'Your Certified login code'\n4. SMTP_URL env var is validated on startup\n5. Successful sends are logged (without the code)\n6. nodemailer is in package.json dependencies","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:14:03.67858+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:51:28.281983+08:00","closed_at":"2026-02-18T18:51:28.281983+08:00","close_reason":"1243a37 Add email delivery service for OTP emails","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.6","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:14:03.679519+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.6","depends_on_id":"hypercerts-scaffold-08v.1","type":"blocks","created_at":"2026-02-18T17:16:40.7141+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.7","title":"Auth orchestrator (unified sign-up + sign-in flow)","description":"## What to Do\nCreate the orchestrator that ties together the OTP service, account service, and email service into the unified auth flow. Sign-up and sign-in are identical from the user's perspective.\n\n### src/services/auth-orchestrator.ts\nThis is the main entry point for the auth flow. It coordinates all other services.\n\nConstructor takes dependencies:\n```typescript\nconstructor(\n  private accountService: AccountService,  // from src/services/account-service.ts (task 08v.4)\n  private otpService: OTPService,          // from src/services/otp-service.ts (task 08v.5)\n  private emailService: EmailService,      // from src/services/email-service.ts (task 08v.6)\n)\n```\n\n#### requestOTP(email: string, ipAddress: string): Promise\u003c{ success: boolean, isNewUser: boolean, error?: string }\u003e\n1. Validate email format (basic regex: contains @ and a . after @)\n2. Normalize email: lowercase, trim whitespace\n3. Check if user exists via accountService.accountExists(email)\n4. Call otpService.generateOTP(email, ipAddress) — returns { success, code?, error? }\n5. If rate limited (success: false), return { success: false, isNewUser: false, error }\n6. Call emailService.sendOTPEmail(email, code) — the plaintext code comes from generateOTP's return value\n7. Return { success: true, isNewUser: !userExists }\n\n#### verifyOTPAndAuthenticate(email: string, code: string): Promise\u003c{ success: boolean, did?: string, handle?: string, error?: string }\u003e\n1. Call otpService.validateOTP(email, code)\n2. If invalid, return { success: false, error }\n3. If valid:\n   - **Existing user**: accountService.getAccountByEmail(email) → get DID and handle\n   - **New user**: accountService.createAccount(email) → calls PDS createAccount XRPC, stores credentials, returns DID and handle\n4. Verify PDS access: call com.atproto.server.createSession on PDS (via PDS_INTERNAL_URL) using stored credentials to confirm the account is still accessible. If createSession fails (e.g., password changed on PDS), return { success: false, error: 'Account credentials are out of sync. Please contact support.' }\n5. Return { success: true, did, handle }\n\n#### createPdsSession(email: string): Promise\u003c{ accessJwt: string, refreshJwt: string, did: string, handle: string }\u003e\n- Get decrypted password from accountService.getDecryptedPassword(email)\n- Create an AtpAgent pointed at config.pdsInternalUrl (PDS_INTERNAL_URL env var)\n- Call agent.login({ identifier: handle, password }) — this calls com.atproto.server.createSession\n- Return { accessJwt, refreshJwt, did, handle } from the response\n\n### Don't\n- Don't build a custom OAuth provider\n- Don't modify the PDS\n- Don't skip email validation\n- Don't allow OTP verification without a prior OTP request\n- Don't log passwords or OTP codes\n- Don't call emailService from otpService — the orchestrator is the coordinator\n\n## Acceptance Criteria\n1. requestOTP() validates email format and normalizes to lowercase\n2. requestOTP() calls otpService.generateOTP() and passes the returned plaintext code to emailService.sendOTPEmail()\n3. requestOTP() returns isNewUser correctly\n4. requestOTP() returns rate limit errors from OTP service\n5. verifyOTPAndAuthenticate() creates a new PDS account for unknown emails\n6. verifyOTPAndAuthenticate() retrieves stored credentials for known emails\n7. verifyOTPAndAuthenticate() returns error on invalid OTP\n8. createPdsSession() returns valid PDS session tokens\n9. All error cases are handled gracefully","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:14:22.481357+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:56:44.365198+08:00","closed_at":"2026-02-18T18:56:44.365198+08:00","close_reason":"8b605ec feat: add auth orchestrator for unified sign-up/sign-in flow","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.7","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:14:22.482974+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.7","depends_on_id":"hypercerts-scaffold-08v.4","type":"blocks","created_at":"2026-02-18T17:16:40.787936+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.7","depends_on_id":"hypercerts-scaffold-08v.5","type":"blocks","created_at":"2026-02-18T17:16:40.869551+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.7","depends_on_id":"hypercerts-scaffold-08v.6","type":"blocks","created_at":"2026-02-18T17:16:40.943473+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.8","title":"OTP service HTTP API endpoints","description":"## What to Do\nCreate the HTTP API endpoints that the OTP service's login UI will call. Since the OTP service serves both the login UI and the API at certified.app (same origin), no CORS configuration is needed for these endpoints.\n\n### Routes (src/routes/)\n\n#### POST /api/otp/request\nRequest body: { email: string }\nResponse 200: { success: true, isNewUser: boolean }\nResponse 400: { error: 'Invalid email format' }\nResponse 429: { error: 'Too many requests. Try again later.' }\nResponse 500: { error: 'Failed to send verification code' }\n\nImplementation:\n1. Parse and validate request body with Zod: z.object({ email: z.string().email() })\n2. Extract IP address from request (X-Forwarded-For header or socket remoteAddress)\n3. Call authOrchestrator.requestOTP(email, ipAddress)\n4. Return appropriate response based on result\n\n#### POST /api/otp/verify\nRequest body: { email: string, code: string }\nResponse 200: { success: true, did: string, handle: string, sessionToken: string }\nResponse 400: { error: 'Invalid or expired code' } or { error: 'Too many attempts' }\nResponse 500: { error: 'Authentication failed' }\n\nImplementation:\n1. Parse and validate request body with Zod: z.object({ email: z.string().email(), code: z.string().length(6).regex(/^\\d{6}$/) })\n2. Call authOrchestrator.verifyOTPAndAuthenticate(email, code)\n3. If success: generate a one-time session token (UUID v4), store it in an in-memory Map\u003cstring, { email: string, expiresAt: Date }\u003e with 5-minute TTL. Return { success: true, did, handle, sessionToken }.\n4. The login UI (task 08v.9) will use this sessionToken when calling /api/otp/create-session.\n\n#### POST /api/otp/create-session\nRequest body: { email: string }\nRequest header: X-Internal-Session-Token: \u003ctoken from /verify response\u003e\nResponse 200: { accessJwt: string, refreshJwt: string, did: string, handle: string }\nResponse 401: { error: 'Invalid or expired session token' }\nResponse 500: { error: 'Session creation failed' }\n\nImplementation:\n1. Read X-Internal-Session-Token header\n2. Look up the token in the in-memory Map\n3. If not found or expired: return 401\n4. If found: verify the email in the token matches the email in the body\n5. Delete the token from the Map (one-time use)\n6. Call authOrchestrator.createPdsSession(email)\n7. Return session tokens\n\n**Security**: The session token is:\n- UUID v4 (unguessable)\n- 5-minute TTL (short-lived)\n- One-time use (deleted after use)\n- Bound to the email that completed OTP verification\n- Only issued after successful OTP verification\n\n#### GET /health\nResponse 200: { status: 'ok', timestamp: ISO string }\n\n### Session Token Store\n```typescript\n// src/lib/session-token-store.ts\nconst pendingSessions = new Map\u003cstring, { email: string, expiresAt: Date }\u003e()\n\nexport function createSessionToken(email: string): string {\n  const token = crypto.randomUUID()\n  pendingSessions.set(token, { email, expiresAt: new Date(Date.now() + 5 * 60 * 1000) })\n  return token\n}\n\nexport function validateAndConsumeToken(token: string, email: string): boolean {\n  const entry = pendingSessions.get(token)\n  if (!entry) return false\n  pendingSessions.delete(token) // one-time use\n  if (entry.expiresAt \u003c new Date()) return false\n  if (entry.email !== email) return false\n  return true\n}\n\n// Cleanup expired tokens every minute\nsetInterval(() =\u003e {\n  const now = new Date()\n  for (const [token, entry] of pendingSessions) {\n    if (entry.expiresAt \u003c now) pendingSessions.delete(token)\n  }\n}, 60_000)\n```\n\n### Shared Concerns\n- All routes use JSON request/response\n- Input validation with Zod schemas\n- Error responses follow consistent format: { error: string }\n- Log errors server-side but don't expose internal details to client\n- Same-origin only — no CORS headers needed\n\n### Don't\n- Don't expose create-session without the session token\n- Don't return internal error details to the client\n- Don't use GET for state-mutating operations\n- Don't duplicate business logic — call the orchestrator\n- Don't persist session tokens to the database — in-memory Map is sufficient (they're short-lived and the service is single-instance)\n\n## Acceptance Criteria\n1. POST /api/otp/request accepts {email} and returns {success, isNewUser}\n2. POST /api/otp/request returns 400 for invalid email\n3. POST /api/otp/request returns 429 when rate limited\n4. POST /api/otp/verify accepts {email, code} and returns {success, did, handle, sessionToken}\n5. POST /api/otp/verify returns 400 for invalid/expired code\n6. POST /api/otp/create-session requires X-Internal-Session-Token header\n7. POST /api/otp/create-session returns 401 for invalid/expired/reused token\n8. POST /api/otp/create-session returns PDS session tokens on success\n9. GET /health returns status ok\n10. All routes follow consistent error format\n11. TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:14:38.642596+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:59:08.306067+08:00","closed_at":"2026-02-18T18:59:08.306067+08:00","close_reason":"58ea896 feat: add OTP HTTP API endpoints with session token store","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.8","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:14:38.64361+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.8","depends_on_id":"hypercerts-scaffold-08v.7","type":"blocks","created_at":"2026-02-18T17:16:41.019229+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-08v.9","title":"OTP service login UI and OAuth flow completion","description":"## What to Do\nBuild the login UI that the OTP service serves when intercepting the PDS OAuth authorize endpoint, and the logic that completes the OAuth flow after OTP verification by calling the PDS sign-in API same-origin through the reverse proxy.\n\n### Route Interception: GET /oauth/authorize\nWhen a user arrives at certified.app/oauth/authorize?request_uri=...\u0026client_id=..., the OTP service checks for PDS device session cookies:\n\n**If `dev-id` cookie exists** (along with `ses-id`): Proxy the request through to the PDS. The PDS sees the authenticated session and shows the consent screen. No OTP needed.\n\n**If no `dev-id` cookie**: Intercept and show the OTP login UI.\n\n### Login UI\nServed at /oauth/authorize when intercepted. Two states:\n\n**State 1: Email entry**\n- Input field: 'Enter your email to sign in'\n- Submit button: 'Continue'\n- Below: link 'Sign in with an ATProto handle instead' (passes the request through to the PDS login form for users who have a password)\n- Clean, minimal design\n- When submitted: POST /api/otp/request → if success, transition to State 2\n\n**State 2: OTP code entry**\n- Text: 'We sent a code to {email}'\n- 6-digit code input (inputMode=numeric, maxLength=6, autoFocus)\n- Submit button: 'Verify'\n- 'Resend code' link (disabled for 30s after send, rate limited)\n- 'Use a different email' link (returns to State 1)\n- Error display for invalid code, expired code, too many attempts\n- When submitted: POST /api/otp/verify → if success (returns { did, handle, sessionToken }), proceed to OAuth completion\n\n### OAuth Completion (after successful OTP verification)\nAfter OTP verification succeeds the OTP service has the user's DID, handle, and a sessionToken from /api/otp/verify. Steps:\n\n#### Step 1: Obtain CSRF token from PDS\nMake a server-side GET request to PDS_INTERNAL_URL/oauth/authorize?request_uri=... (the same URL the user originally visited). The PDS response will include a `Set-Cookie: csrf-token=\u003chex\u003e` header. Extract the csrf-token value. This cookie is NOT httpOnly (it's designed to be readable by the PDS's own JS frontend).\n\n#### Step 2: Call PDS sign-in API\nPOST to `PDS_INTERNAL_URL/@atproto/oauth-provider/~api/sign-in` with:\n- Headers:\n  - `Content-Type: application/json`\n  - `x-csrf-token: \u003ccsrf-token value from step 1\u003e`\n  - `Cookie: csrf-token=\u003csame value\u003e; dev-id=\u003cif exists\u003e; ses-id=\u003cif exists\u003e`\n  - `Sec-Fetch-Site: same-origin`\n  - `Sec-Fetch-Mode: same-origin`\n  - `Referer: https://certified.app/oauth/authorize?request_uri=...`\n- Body:\n  ```json\n  {\n    \"locale\": \"en\",\n    \"username\": \"\u003chandle from account service\u003e\",\n    \"password\": \"\u003cdecrypted password from account service\u003e\",\n    \"remember\": true\n  }\n  ```\n- **CRITICAL**: `remember: true` makes the PDS set `dev-id` and `ses-id` device session cookies. Without it, the PDS returns an ephemeral JWT instead and no cookies are set.\n\n#### Step 3: Forward cookies to browser\nThe PDS sign-in response includes `Set-Cookie` headers for:\n- `dev-id` — device ID (httpOnly, path /, SameSite lax)\n- `ses-id` — session ID (httpOnly, path /, SameSite lax)\n- `dev-id:hash` — signature (if Keygrip configured)\n- `ses-id:hash` — signature (if Keygrip configured)\n- `csrf-token` — refreshed CSRF token\n\nCapture ALL `Set-Cookie` headers from the PDS response and forward them to the browser.\n\n#### Step 4: Redirect\nSend a 302 redirect to the browser pointing to `/oauth/authorize?request_uri=...\u0026client_id=...` (the original URL, preserved in the OTP flow session).\n\nOn this second visit, the `dev-id` cookie is now present → the OTP service proxies the request to the PDS → PDS sees authenticated user → shows consent screen → user approves → PDS redirects to app callback.\n\n### Session State During OTP Flow\n- On first intercept of GET /oauth/authorize, store `request_uri` and `client_id` in a short-lived httpOnly cookie named `otp-flow` (HMAC-signed with a server secret, 10 min TTL)\n- Read these values back after OTP verification to reconstruct the redirect URL\n- Clear the `otp-flow` cookie after OAuth completion\n\n### Tech Stack for UI\n- Simple HTML + vanilla JS (no framework needed for two states)\n- Tailwind CSS for styling (consistent with Scaffold)\n- Server-side rendered initial page for fast load\n\n### Don't\n- Don't expose the stored password to the client/browser\n- Don't set `remember: false` — that returns an ephemeral JWT instead of setting device cookies\n- Don't bypass the PDS consent screen\n- Don't over-engineer the UI\n- Don't forget to forward ALL Set-Cookie headers from the PDS sign-in response\n\n## Acceptance Criteria\n1. GET /oauth/authorize shows OTP login UI when no `dev-id` cookie exists\n2. GET /oauth/authorize proxies to PDS when `dev-id` cookie exists\n3. Login UI has two states: email entry and OTP code entry\n4. Email submission calls POST /api/otp/request\n5. Code submission calls POST /api/otp/verify\n6. After verification, CSRF token is obtained from PDS via server-side GET\n7. PDS sign-in called at `/@atproto/oauth-provider/~api/sign-in` with `remember: true`\n8. All Set-Cookie headers from PDS sign-in response forwarded to browser\n9. User is redirected to /oauth/authorize and sees PDS consent screen (not login form)\n10. request_uri and client_id preserved in signed `otp-flow` cookie\n11. Error states display correctly\n12. 'Resend code' works with cooldown\n13. 'Use a different email' returns to State 1","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:15:08.189436+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T19:05:27.539113+08:00","closed_at":"2026-02-18T19:05:27.539113+08:00","close_reason":"668699b OTP login UI and OAuth flow completion","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-08v.9","depends_on_id":"hypercerts-scaffold-08v","type":"parent-child","created_at":"2026-02-18T17:15:08.19072+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-08v.9","depends_on_id":"hypercerts-scaffold-08v.8","type":"blocks","created_at":"2026-02-18T17:16:41.103315+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-0go","title":"Simplify JWK key generation with script","status":"in_progress","priority":2,"issue_type":"feature","owner":"adam@hypercerts.org","created_at":"2026-01-28T17:13:26.340137246+13:00","created_by":"Adam Spiers","updated_at":"2026-01-28T17:13:32.702507218+13:00"}
{"id":"hypercerts-scaffold-0yp","title":"Epic: PDS Deployment \u0026 End-to-End Integration","description":"## Goal\nDeploy the PDS sidecar auth service alongside the Certified PDS at `pds-eu-west4.test.certified.app`, configure the PDS to work with the sidecar, and verify the complete email-first passwordless login flow end-to-end from the scaffold app through the sidecar to the PDS and back.\n\n## Context\nWe are the Certified team and control the PDS deployment. The PDS currently runs stock `@atproto/pds` in standalone mode (it is its own authorization server). We need to:\n1. Co-deploy the sidecar auth service with the PDS\n2. Configure the PDS so the sidecar can override its OAuth authorization server metadata\n3. Set up Docker Compose with Caddy for TLS (sidecar on auth subdomain, PDS on main domain)\n4. Configure SMTP for OTP email delivery\n5. Test the complete flow: scaffold → PDS (PAR) → sidecar (email + OTP) → PDS (auth code) → scaffold (callback)\n6. Handle existing users who have password-based accounts\n\n## Architecture\n```\nInternet\n  │\n  ▼\nCaddy (TLS termination, routing)\n  ├── pds.certs.network      → PDS Core (port 3000)\n  ├── auth.pds.certs.network → Sidecar Auth Service (port 3001)\n  └── *.pds.certs.network    → PDS Core (handle resolution)\n```\n\nBoth PDS and sidecar run in the same Docker Compose stack, sharing:\n- A Docker network (sidecar can reach PDS internally)\n- A shared HMAC secret for signed callbacks\n- The sidecar has access to the PDS's `OAuthProvider` instance (same process or via internal API)\n\n## Key Concerns\n- **Existing users:** Users who created accounts with passwords can still log in — the sidecar should check if an email exists in the PDS and authenticate accordingly. Password reset flow (`com.atproto.server.resetPassword`) must remain available as a recovery path.\n- **DNS:** Need wildcard DNS for handle resolution (`*.pds.certs.network`) plus the auth subdomain\n- **TLS:** Caddy handles automatic TLS via Let's Encrypt. Need DNS challenge for wildcard certs.\n- **Email deliverability:** SPF/DKIM/DMARC records on the sending domain. Use a reputable SMTP provider.\n- **Monitoring:** Health checks, structured logging (pino), basic metrics endpoint\n\n## Success Criteria\n- Docker Compose stack starts cleanly with PDS + sidecar + Caddy\n- OAuth metadata at `/.well-known/oauth-authorization-server` shows sidecar's `authorization_endpoint`\n- Complete login flow works from scaffold app to PDS and back\n- OTP emails are delivered reliably\n- Existing password-based users can still authenticate\n- TLS works on all endpoints\n- Health checks pass for all services","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-17T18:12:26.180448+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.582864+08:00","closed_at":"2026-02-18T15:50:27.582867+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-0yp.1","title":"Create Docker Compose stack with Caddy, PDS, and sidecar","description":"## Files\n- docker-compose.yml (create)\n- Dockerfile.pds (create)\n- Dockerfile.auth (create)\n- Caddyfile (create)\n- .env.example (create)\n\n## What to do\nCreate the Docker Compose deployment configuration for the complete PDS + sidecar stack.\n\n### `docker-compose.yml`\nThree services:\n\n#### `caddy`\n- Image: `caddy:2-alpine`\n- Ports: 80, 443\n- Volumes: `./Caddyfile:/etc/caddy/Caddyfile`, `caddy_data:/data`, `caddy_config:/config`\n- Depends on: pds, auth\n\n#### `pds`\n- Build: `Dockerfile.pds`\n- Port: 3000 (internal only, not exposed to host)\n- Volumes: `pds_data:/data` (for SQLite + blobs)\n- Environment: all PDS env vars from .env\n- Health check: `curl -f http://localhost:3000/xrpc/_health`\n\n#### `auth`\n- Build: `Dockerfile.auth`\n- Port: 3001 (internal only)\n- Volumes: `auth_data:/data` (for sidecar SQLite)\n- Environment: auth service env vars from .env\n- Health check: `curl -f http://localhost:3001/health`\n- Depends on: pds\n\n### `Caddyfile`\n```\npds.certs.network {\n    reverse_proxy pds:3000\n}\n\nauth.pds.certs.network {\n    reverse_proxy auth:3001\n}\n\n*.pds.certs.network {\n    reverse_proxy pds:3000\n}\n```\nUse on-demand TLS or DNS challenge for wildcard certs (configure via env var for the DNS provider).\n\n### Dockerfiles\nBoth should be multi-stage builds:\n1. Stage 1: `node:20-alpine` — install deps, build TypeScript\n2. Stage 2: `node:20-alpine` — copy built files, run with `node dist/index.js`\n\n### `.env.example`\nDocument all required environment variables with comments:\n- PDS config (hostname, admin password, PLC URL, etc.)\n- Auth service config (SMTP host/port/user/pass, from address)\n- Shared config (CALLBACK_SECRET)\n- Caddy config (DNS provider API key for wildcard certs)\n\n## Don't\n- Don't include actual secrets in any committed file\n- Don't expose PDS or auth ports directly to the host (only through Caddy)\n- Don't use `latest` tags for base images — pin versions","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-17T18:16:43.769223+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:50:24.136962+08:00","closed_at":"2026-02-17T18:50:24.136962+08:00","close_reason":"3471b74 Add Docker Compose stack with Caddy, PDS, and sidecar","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-0yp.1","depends_on_id":"hypercerts-scaffold-0yp","type":"parent-child","created_at":"2026-02-17T18:16:43.77054+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-0yp.1","depends_on_id":"hypercerts-scaffold-qc3.6","type":"blocks","created_at":"2026-02-17T18:16:43.77197+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-0yp.1","depends_on_id":"hypercerts-scaffold-qc3.7","type":"blocks","created_at":"2026-02-17T18:16:43.772825+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-1t8","title":"Epic: Integration Testing \u0026 Production Docs","description":"## Goal\nVerify the complete email→OTP→session flow works end-to-end and create the documentation needed for production deployment and partner app integration.\n\n## Context\nOnce the sidecar (Epic: Sidecar Auth Service) and scaffold UI (Epic: Scaffold Email-First Login UI) are built, we need to:\n1. Test the full flow locally: scaffold → PDS → sidecar → OTP → PDS → scaffold\n2. Document how to deploy to production (certified.app)\n3. Document how partner apps (GainForest, Silvi) integrate\n\n## What Has to Be Built\n1. Playwright E2E test suite against local dev stack\n2. Manual test checklist for security edge cases\n3. Production deployment guide (DNS, TLS, SMTP, secrets)\n4. Partner app integration guide (BFF pattern)\n\n## Local Dev Stack\n- Scaffold: http://127.0.0.1:3000\n- PDS: http://localhost:2583\n- Auth service (sidecar): http://localhost:2584\n- MailHog: SMTP on :1025, web UI on http://localhost:8025","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T15:49:41.127646+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.914415+08:00","closed_at":"2026-02-18T15:54:58.914417+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-1t8.1","title":"Create Playwright E2E tests for email-first auth flow","description":"## Files\n- e2e/auth-flow.spec.ts (create)\n- e2e/helpers/mailhog.ts (create)\n- e2e/playwright.config.ts (create)\n- package.json (modify — add @playwright/test devDependency)\n\n## What to do\nCreate Playwright E2E tests that exercise the full email→OTP→session flow against the local dev stack (must be running).\n\n### MailHog helper (e2e/helpers/mailhog.ts)\n- getLatestOTP(email): polls MailHog API at http://localhost:8025/api/v2/search, extracts 8-digit code from email body. Retries 10x with 1s delay.\n- clearMailbox(): DELETE http://localhost:8025/api/v1/messages\n\n### Test cases (e2e/auth-flow.spec.ts)\n1. **New user sign-up**: navigate to /login → enter unique email → click Continue → wait for redirect to sidecar → get OTP from MailHog → enter code → wait for redirect back → verify logged in\n2. **Existing user sign-in**: use email from test 1 → same flow → verify logged in\n3. **Invalid OTP retry**: enter wrong code → see error → enter correct code → success\n4. **Handle-based login**: enter handle in secondary section → verify redirect to PDS\n\n### Playwright config\n- baseURL: http://127.0.0.1:3000\n- timeout: 30000\n- retries: 0\n- reporter: html\n\n## Don't\n- Start the dev stack from tests (assume running)\n- Use real email addresses\n- Hard-code OTP codes\n- Skip MailHog cleanup between tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:49:56.315579+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.844507+08:00","closed_at":"2026-02-18T15:54:58.844509+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-1t8.1","depends_on_id":"hypercerts-scaffold-1t8","type":"parent-child","created_at":"2026-02-18T15:49:56.316946+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-1t8.1","depends_on_id":"hypercerts-scaffold-mws.5","type":"blocks","created_at":"2026-02-18T15:49:56.3187+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-1t8.1","depends_on_id":"hypercerts-scaffold-y9g.1","type":"blocks","created_at":"2026-02-18T15:49:56.319788+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-1t8.2","title":"Create production deployment guide and partner integration docs","description":"## Files\n- docs/production-deployment.md (create)\n- docs/certified-oauth-integration.md (create)\n- docs/manual-test-checklist.md (create)\n\n## What to do\n\n### production-deployment.md\nStep-by-step guide to deploy the full stack at certified.app:\n1. Prerequisites (Docker, domain, SMTP provider)\n2. DNS setup (A records for certified.app, auth.certified.app, *.certified.app)\n3. Email deliverability (SPF/DKIM/DMARC record examples)\n4. Secrets generation (openssl commands for every secret)\n5. Docker Compose deployment (reference docker-compose.yml)\n6. Health checks (curl commands to verify each service)\n7. Backup strategy (SQLite backup for PDS + sidecar data)\n8. Monitoring (what to alert on)\n\n### certified-oauth-integration.md\nGuide for GainForest/Silvi to add 'Sign in with Certified':\n1. Overview of the flow\n2. Prerequisites (Node.js, Redis, SDK)\n3. Environment setup (NEXT_PUBLIC_PDS_URL=https://certified.app, JWK generation)\n4. OAuth client metadata routes (copy from scaffold)\n5. Email-login API route (copy from scaffold)\n6. Frontend email input form\n7. Session management\n8. Troubleshooting\n\nAll code examples copied from actual scaffold source files with file path references.\n\n### manual-test-checklist.md\n18+ test cases with ID, steps, expected result, pass/fail checkbox:\n- Rate limiting (3 cases)\n- OTP security (4 cases: wrong code, expiry, replay, invalidation)\n- Session management (4 cases: persist, logout, multi-browser, cookie clear)\n- Error handling (3 cases: invalid email, PDS down, sidecar down)\n- OAuth (3 cases: deny consent, multi-app, token revocation)\n- Handle fallback (1 case)\n\n## Don't\n- Include actual secrets or API keys\n- Invent code examples (copy from scaffold)\n- Skip SPF/DKIM/DMARC (critical for email delivery)\n- Assume reader knows ATProto internals","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:50:14.860548+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.76936+08:00","closed_at":"2026-02-18T15:54:58.769365+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-1t8.2","depends_on_id":"hypercerts-scaffold-1t8","type":"parent-child","created_at":"2026-02-18T15:50:14.861731+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-1t8.2","depends_on_id":"hypercerts-scaffold-mws.5","type":"blocks","created_at":"2026-02-18T15:50:14.863154+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-1t8.2","depends_on_id":"hypercerts-scaffold-y9g.1","type":"blocks","created_at":"2026-02-18T15:50:14.864255+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-25h","title":"Fix: /auth/resend-code endpoint referenced in template but not implemented (from hypercerts-scaffold-qc3.6)","description":"Review of hypercerts-scaffold-qc3.6 found: templates.ts renderOTPPage() includes a 'Resend code' link that POSTs to /auth/resend-code, but no route handler for POST /auth/resend-code exists in the auth-service routes (only send-code.ts, verify-code.ts, authorize.ts). Clicking 'Resend code' will return a 404. Evidence: packages/auth-service/src/templates.ts line 109 fetches '/auth/resend-code'; no route file handles this path. Fix: either implement POST /auth/resend-code (which re-sends the OTP for the current session email) or remove the resend link from the template.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-17T18:53:02.649149+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.752727+08:00","closed_at":"2026-02-17T18:56:11.752733+08:00","dependencies":[{"issue_id":"hypercerts-scaffold-25h","depends_on_id":"hypercerts-scaffold-qc3.6","type":"discovered-from","created_at":"2026-02-17T18:53:02.765007+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-2bf","title":"Epic: Scaffold Email-First Auth UI","description":"## Goal\nBuild a new email-first login page at `/login` in the hypercerts-scaffold Next.js app. This page replaces the handle-based login flow with an email input that initiates ATProto OAuth with the user's email passed as `login_hint`. The old handle-based login (`LoginDialog` component, `SignedInProvider` gate) remains untouched — both flows coexist so we can test the new flow independently.\n\n## Context\nThe scaffold app currently requires users to enter their ATProto handle (e.g., `alice.certified.app`) to log in. This is confusing for non-technical users. We're building email-first passwordless login where users enter their email, receive a 6-digit OTP code, and are authenticated — no handles, no passwords.\n\nThe scaffold's role is the **client side** of this flow. A separate PDS sidecar service (different repo) handles the server-side OTP generation/verification. The scaffold just needs to:\n1. Collect the user's email\n2. Pass it as `login_hint` in the ATProto OAuth authorization URL\n3. Handle the standard OAuth callback (unchanged)\n\nThe PDS sidecar intercepts the OAuth authorization endpoint and uses the `login_hint` to send an OTP email immediately, so the user sees an OTP input (not a password form) at the PDS.\n\n## Technical Background\n- **Framework:** Next.js 16 with App Router\n- **Current auth flow:** User enters handle → POST `/api/auth/login` → `sdk.authorize(handle)` → redirect to PDS → password form → callback → session cookie\n- **New auth flow:** User enters email → POST `/api/auth/login` with email + `login_hint` → `sdk.authorize(pdsUrl, { login_hint: email })` → redirect to PDS sidecar → OTP form → callback → session cookie\n- **Key files:** `components/login-dialog.tsx`, `app/api/auth/login/route.ts`, `lib/config.ts`, `lib/hypercerts-sdk.ts`, `providers/SignedInProvider.tsx`\n- **UI components available:** shadcn/ui (Button, Input, Card, InputGroup, Spinner, etc.), Tailwind CSS, fonts: Syne (headings), Outfit (body)\n- **SDK:** `@hypercerts-org/sdk-core` wraps `@atproto/oauth-client-node`. The `sdk.authorize()` method accepts a handle, DID, or PDS URL.\n\n## Success Criteria\n- New `/login` page exists with email input and unified sign-in/sign-up flow\n- Email is passed as `login_hint` through the OAuth flow\n- Old handle-based login still works at the root (SignedInProvider + LoginDialog unchanged)\n- OAuth callback handles both flows identically\n- No new environment variables required (uses existing `NEXT_PUBLIC_PDS_URL`)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-17T18:11:29.861164+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.406478+08:00","closed_at":"2026-02-18T15:50:27.406482+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-2bf.1","title":"Create /login page with email input form","description":"## Files\n- app/login/page.tsx (create)\n- components/email-login-form.tsx (create)\n\n## What to do\nCreate a new Next.js App Router page at `/login` with an email-first login form. This page exists alongside the old handle-based login (which remains at the root via `SignedInProvider`).\n\n### Page: `app/login/page.tsx`\n- Server component that checks for an existing session (same pattern as `SignedInProvider`)\n- If already authenticated, redirect to `/` using `redirect()` from `next/navigation`\n- If not authenticated, render the `EmailLoginForm` component centered on screen\n- Include the `Navbar` with `isSignedIn={false}` (same pattern as SignedInProvider's unauthenticated state)\n\n### Component: `components/email-login-form.tsx`\n- Client component (`'use client'`)\n- Single form with one email input field and a submit button\n- Heading: 'Sign In' (font: Syne, bold)\n- Subheading: 'Enter your email to continue' (font: Outfit, muted)\n- Email input: standard `\u003cInput\u003e` from `components/ui/input.tsx`, type='email', placeholder='you@example.com', required\n- Submit button: 'Continue' text, full width, uses `bg-create-accent` styling (same as existing LoginDialog)\n- Loading state: show `\u003cSpinner\u003e` in button when submitting, disable button\n- On submit: call `useEmailLoginMutation` (created in a separate task) which POSTs to `/api/auth/email-login`\n- Error state: show error message below the form if mutation fails (use `text-destructive` class)\n- Match the visual style of the existing `LoginDialog` component (same fonts, colors, spacing, `animate-fade-in-up` animations)\n\n### Layout\n- The form should be centered vertically and horizontally, max-width `sm` (same as LoginDialog)\n- Wrap in a `\u003cdiv className='flex grow flex-col items-center justify-center'\u003e` (same pattern as SignedInProvider)\n\n## Don't\n- Don't modify `SignedInProvider`, `LoginDialog`, or any existing auth components\n- Don't add any new environment variables\n- Don't implement the API route or mutation hook (those are separate tasks)\n- Don't add OTP verification UI (that's handled by the PDS sidecar, not the scaffold)\n- Don't add a layout.tsx for /login — use the root layout","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:12:49.415659+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:39:42.193719+08:00","closed_at":"2026-02-17T18:39:42.193719+08:00","close_reason":"062b00d Create /login page with email input form","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-2bf.1","depends_on_id":"hypercerts-scaffold-2bf","type":"parent-child","created_at":"2026-02-17T18:12:49.416938+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-2bf.1","depends_on_id":"hypercerts-scaffold-2bf.2","type":"blocks","created_at":"2026-02-17T18:13:31.992691+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-2bf.2","title":"Create useEmailLoginMutation hook and API client function","description":"## Files\n- queries/auth/use-email-login-mutation.ts (create)\n- queries/auth/index.ts (modify)\n- lib/api/auth.ts (modify)\n- lib/api/types.ts (modify)\n\n## What to do\nCreate the client-side mutation hook and API function for the email-first login flow. This follows the exact same pattern as the existing `useLoginMutation` / `login()` but accepts an email instead of a handle.\n\n### `lib/api/types.ts` — Add types\nAdd alongside existing types:\n```typescript\nexport interface EmailLoginRequest {\n  email: string;\n}\n\nexport interface EmailLoginResponse {\n  authUrl: string;\n}\n```\n\n### `lib/api/auth.ts` — Add API function\nAdd a new function alongside the existing `login()`:\n```typescript\nexport async function emailLogin(email: string): Promise\u003cEmailLoginResponse\u003e {\n  return apiClient.post\u003cEmailLoginResponse\u003e('/api/auth/email-login', { email });\n}\n```\nThe existing `login()` and `logout()` functions must remain unchanged.\n\n### `queries/auth/use-email-login-mutation.ts` — Create mutation hook\nFollow the exact pattern of `use-login-mutation.ts`:\n- Import `emailLogin` from `@/lib/api/auth`\n- Use `useMutation` from `@tanstack/react-query`\n- `mutationFn`: calls `emailLogin(email)`\n- `onSuccess`: calls `router.push(data.authUrl)` to redirect to the PDS/sidecar authorization page (same as useLoginMutation)\n- `onError`: log error to console (same as useLoginMutation)\n- Export as `useEmailLoginMutation`\n\n### `queries/auth/index.ts` — Re-export\nAdd `export { useEmailLoginMutation } from './use-email-login-mutation'` alongside existing exports.\n\n## Don't\n- Don't modify the existing `useLoginMutation` or `login()` function\n- Don't implement the server-side API route (that's a separate task)\n- Don't add error handling beyond what the existing hooks do","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:13:03.438072+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:35:38.217518+08:00","closed_at":"2026-02-17T18:35:38.217518+08:00","close_reason":"0ce88fd Add useEmailLoginMutation hook and emailLogin API function","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-2bf.2","depends_on_id":"hypercerts-scaffold-2bf","type":"parent-child","created_at":"2026-02-17T18:13:03.43898+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-2bf.3","title":"Create /api/auth/email-login API route with login_hint passthrough","description":"## Files\n- app/api/auth/email-login/route.ts (create)\n\n## What to do\nCreate a new Next.js API route that accepts an email address and initiates the ATProto OAuth flow with the email passed as `login_hint`. This is the server-side counterpart to the `useEmailLoginMutation` hook.\n\n### Route: `POST /api/auth/email-login`\n\n**Request body:**\n```json\n{ \"email\": \"user@example.com\" }\n```\n\n**Logic:**\n1. Parse the request body and extract `email`\n2. Validate that `email` is present and is a valid email format (basic regex or just check for `@`)\n3. Call `sdk.authorize()` to initiate the OAuth flow. The key difference from the existing `/api/auth/login` route is:\n   - Pass the **PDS URL** (from `config.pdsUrl`, i.e., `process.env.NEXT_PUBLIC_PDS_URL`) as the first argument — NOT the email. The PDS URL tells the SDK which authorization server to use.\n   - Pass the email as `login_hint` in the authorization URL. The `@atproto/oauth-client-node` SDK's `authorize()` method may not directly support `login_hint` as a parameter. If it doesn't, you need to:\n     a. First try: check if `sdk.authorize(pdsUrl, { login_hint: email })` works (check the SDK types)\n     b. If not: get the authorization URL from `sdk.authorize(pdsUrl)` and append `\u0026login_hint=${encodeURIComponent(email)}` to the URL before returning it\n4. Return `{ authUrl: \u003cthe authorization URL\u003e }` as JSON\n\n**Response (success):**\n```json\n{ \"authUrl\": \"https://pds.certs.network/oauth/authorize?...\u0026login_hint=user%40example.com\" }\n```\n\n**Response (error):**\n```json\n{ \"error\": \"Email is required\" }  // 400\n{ \"error\": \"Failed to initiate login process\" }  // 500\n```\n\n### Important: Understanding `sdk.authorize()`\nThe existing login route calls `sdk.authorize(handle)` where `handle` is a user's ATProto handle (e.g., `alice.bsky.social`). The SDK resolves the handle to find the user's PDS/authorization server.\n\nFor email login, we don't have a handle — we have an email. We know the PDS URL (`NEXT_PUBLIC_PDS_URL`), so we pass that directly. The SDK will use it to find the authorization server. The `login_hint` parameter is an OAuth standard parameter that the authorization server (our sidecar) will use to pre-fill the email and send the OTP immediately.\n\n### Reference: Existing login route\n```typescript\n// app/api/auth/login/route.ts (DO NOT MODIFY)\nimport sdk from '@/lib/hypercerts-sdk';\nexport async function POST(request: Request) {\n  const body = await request.json();\n  const handle = body.handle;\n  try {\n    const authUrl = await sdk.authorize(handle);\n    return NextResponse.json({ authUrl });\n  } catch (e) {\n    console.error('Failed to initiate login process', e);\n    return Response.json({ error: 'Failed to initiate login process' }, { status: 500 });\n  }\n}\n```\n\n## Don't\n- Don't modify the existing `/api/auth/login` route\n- Don't modify the existing `/api/auth/callback` route (the callback is the same for both flows)\n- Don't add new environment variables\n- Don't try to resolve email→handle or email→DID on the scaffold side (that's the sidecar's job)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:13:26.675271+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:35:41.084402+08:00","closed_at":"2026-02-17T18:35:41.084402+08:00","close_reason":"c42b281 Create /api/auth/email-login route with login_hint passthrough","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-2bf.3","depends_on_id":"hypercerts-scaffold-2bf","type":"parent-child","created_at":"2026-02-17T18:13:26.675986+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-67k","title":"Epic: End-to-End Integration Testing","description":"## Goal\nVerify the complete email-first passwordless auth flow works end-to-end, from the scaffold app through the sidecar to the PDS and back. Cover both new user sign-up and existing user sign-in paths.\n\n## Context\nWe have three components that need to work together:\n1. **Scaffold app** (Next.js) — /login page with email input, /api/auth/email-login route, /api/auth/callback route\n2. **Sidecar auth service** (Express) — /oauth/authorize, /auth/send-code, /auth/verify-code\n3. **PDS** (stock @atproto/pds) — OAuth PAR, magic-callback, token exchange, account creation\n\nThe local dev setup exists (Epic: Local Test PDS — hypercerts-scaffold-mhp) with:\n- PDS at http://localhost:2583\n- Sidecar at http://localhost:2584\n- MailHog at http://localhost:8025 (fake SMTP)\n- Scaffold at http://127.0.0.1:3000\n\nBut the full flow has never been tested end-to-end. Task hypercerts-scaffold-mhp.2 (verify full OTP flow) is still in progress.\n\n## Test Scenarios\n1. **New user sign-up**: Enter email → receive OTP → enter code → account created → session established → redirected to app\n2. **Existing user sign-in**: Enter email → receive OTP → enter code → session established → redirected to app\n3. **Invalid OTP**: Enter wrong code → error shown → can retry\n4. **Expired OTP**: Wait 15 minutes → code rejected → can request new code\n5. **Rate limiting**: Send too many OTP requests → rate limited → Retry-After header\n6. **OAuth consent**: User sees consent screen → approves → tokens issued\n7. **Session persistence**: After login, refresh page → still logged in\n8. **Logout**: Click logout → session cleared → redirected to login\n\n## Hard Constraints\n- Tests must run against the local dev stack (no production PDS)\n- Use MailHog to capture OTP emails (no real email sending)\n- Tests should be automated where possible (Playwright or similar)\n- Manual test checklist for flows that can't be easily automated\n\n## Success Looks Like\n- All 8 test scenarios pass\n- Automated E2E test suite exists (at least for scenarios 1-3)\n- Manual test checklist documented for remaining scenarios\n- Known issues documented with workarounds","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T14:10:31.581006+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.347542+08:00","closed_at":"2026-02-18T15:44:51.347544+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-67k.1","title":"Create E2E test suite for email-first auth flow using Playwright","description":"## Files\n- e2e/auth-flow.spec.ts (create)\n- e2e/helpers/mailhog.ts (create)\n- e2e/playwright.config.ts (create)\n- package.json (modify — add playwright dev dependency)\n\n## What to do\nCreate a Playwright E2E test suite that tests the complete email→OTP→session flow against the local dev stack.\n\n### Prerequisites\nThe local dev stack must be running:\n- Scaffold at http://127.0.0.1:3000\n- PDS at http://localhost:2583\n- Sidecar at http://localhost:2584\n- MailHog at http://localhost:8025\n\n### MailHog helper\n```typescript\n// e2e/helpers/mailhog.ts\nexport async function getLatestOTP(email: string): Promise\u003cstring\u003e {\n  // 1. Poll MailHog API at http://localhost:8025/api/v2/search?kind=to\u0026query=\u003cemail\u003e\n  // 2. Parse the latest email body to extract the 8-digit OTP code\n  // 3. Return the code\n  // Retry up to 10 times with 1s delay (email delivery can be slow)\n}\n\nexport async function clearMailbox(): Promise\u003cvoid\u003e {\n  // DELETE http://localhost:8025/api/v1/messages\n}\n```\n\n### Test scenarios\n```typescript\ntest.describe('Email-first auth flow', () =\u003e {\n  test.beforeEach(async () =\u003e {\n    await clearMailbox()\n  })\n\n  test('new user can sign up with email and OTP', async ({ page }) =\u003e {\n    // 1. Navigate to http://127.0.0.1:3000/login\n    // 2. Enter a unique email (e.g., test-{timestamp}@example.com)\n    // 3. Click Continue\n    // 4. Wait for redirect to sidecar OTP page\n    // 5. Get OTP from MailHog\n    // 6. Enter OTP code\n    // 7. Wait for redirect back to scaffold\n    // 8. Verify user is logged in (check for user avatar or DID display)\n  })\n\n  test('existing user can sign in with email and OTP', async ({ page }) =\u003e {\n    // Same as above but with an email that already has an account\n    // (create account first, then test sign-in)\n  })\n\n  test('invalid OTP shows error and allows retry', async ({ page }) =\u003e {\n    // 1. Go through email entry\n    // 2. Enter wrong OTP code\n    // 3. Verify error message is shown\n    // 4. Enter correct OTP code\n    // 5. Verify login succeeds\n  })\n})\n```\n\n### Playwright config\n- baseURL: http://127.0.0.1:3000\n- timeout: 30000 (OTP email delivery can be slow)\n- retries: 0 (tests should be deterministic)\n- reporter: html\n\n## Don't\n- Start the dev stack from within the tests (assume it's already running)\n- Use real email addresses\n- Hard-code OTP codes (always extract from MailHog)\n- Skip cleanup between tests (clear MailHog mailbox)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:10:50.702736+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.438125+08:00","closed_at":"2026-02-18T15:44:51.438128+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-67k.1","depends_on_id":"hypercerts-scaffold-67k","type":"parent-child","created_at":"2026-02-18T14:10:50.703968+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-67k.1","depends_on_id":"hypercerts-scaffold-mhp","type":"blocks","created_at":"2026-02-18T14:11:52.624363+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-67k.1","depends_on_id":"hypercerts-scaffold-hpb.1","type":"blocks","created_at":"2026-02-18T14:11:52.733178+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-67k.2","title":"Create manual test checklist for auth edge cases and security scenarios","description":"## Files\n- docs/manual-test-checklist.md (create)\n\n## What to do\nCreate a comprehensive manual test checklist for auth scenarios that are difficult to automate.\n\n### Checklist format\nEach test case should have:\n- Test ID (e.g., AUTH-001)\n- Description\n- Preconditions\n- Steps (numbered)\n- Expected result\n- Pass/Fail checkbox\n- Notes field\n\n### Test cases to include\n\n**Rate Limiting (AUTH-001 to AUTH-003)**\n- AUTH-001: Send 4 OTP requests for same email within 15 minutes → 4th should be rate limited\n- AUTH-002: Send 6 OTP requests for same email within 1 hour → 6th should be rate limited\n- AUTH-003: Send 11 OTP requests from same IP within 15 minutes → 11th should be rate limited\n\n**OTP Security (AUTH-004 to AUTH-007)**\n- AUTH-004: Enter wrong OTP 5 times → code invalidated, must request new one\n- AUTH-005: Wait 16 minutes after receiving OTP → code expired\n- AUTH-006: Use same OTP code twice → second use rejected (replay protection)\n- AUTH-007: Request new OTP → old OTP invalidated\n\n**Session Management (AUTH-008 to AUTH-011)**\n- AUTH-008: Login → close browser → reopen → still logged in (session persists in Redis)\n- AUTH-009: Login → click logout → try to access protected page → redirected to login\n- AUTH-010: Login on two different browsers → both sessions active\n- AUTH-011: Clear cookies → session lost → must re-authenticate\n\n**Error Handling (AUTH-012 to AUTH-014)**\n- AUTH-012: Enter invalid email format → validation error shown\n- AUTH-013: PDS is down → graceful error message (not stack trace)\n- AUTH-014: Sidecar is down → graceful error message\n\n**OAuth (AUTH-015 to AUTH-017)**\n- AUTH-015: Deny OAuth consent → redirected back to app without session\n- AUTH-016: Login from two different Certified apps → each gets independent session\n- AUTH-017: Revoke OAuth token → app loses access\n\n**Handle-based fallback (AUTH-018)**\n- AUTH-018: Enter ATProto handle instead of email → handle-based login works\n\n## Don't\n- Include automated test cases (those are in the Playwright suite)\n- Skip the rate limiting tests (they're critical for production)\n- Assume the tester knows ATProto internals (explain each step clearly)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:11:08.621568+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.528484+08:00","closed_at":"2026-02-18T15:44:51.528488+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-67k.2","depends_on_id":"hypercerts-scaffold-67k","type":"parent-child","created_at":"2026-02-18T14:11:08.622733+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-6oz","title":"Fix: useEmailLoginMutation missing toast.error on failure vs useLoginMutation pattern (from hypercerts-scaffold-2bf.2)","description":"Review of hypercerts-scaffold-2bf.2 found: useEmailLoginMutation onError only calls console.error, while the existing useLoginMutation (the pattern it was asked to follow) also calls toast.error('An error occurred while logging in.'). The spec says 'follow the exact pattern of use-login-mutation.ts'. The email-login form does show an inline error via emailLoginMutation.isError, but the toast notification is missing. This is a minor UX inconsistency. Evidence: queries/auth/use-login-mutation.ts line 18 calls toast.error; queries/auth/use-email-login-mutation.ts line 16 only calls console.error. Fix: add toast.error call in onError, or explicitly document the intentional deviation.","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-02-17T18:53:27.29766+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:27.992137+08:00","closed_at":"2026-02-17T18:56:27.992141+08:00","dependencies":[{"issue_id":"hypercerts-scaffold-6oz","depends_on_id":"hypercerts-scaffold-2bf.2","type":"discovered-from","created_at":"2026-02-17T18:53:27.432906+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-8mu","title":"Epic: OTP Service Layer Hardening \u0026 Credential Management","description":"## Goal\nHarden the existing OTP service layer in packages/pds-sidecar/ to be production-ready. Add encrypted auto-generated password storage, improve OTP security, and ensure the service can handle the Ma Earth grants round traffic.\n\n## Context\nThe pds-sidecar already has a working OTP service (packages/pds-sidecar/packages/shared/dist/otp-service.js) with:\n- 8-digit OTP generation with SHA-256 hashing\n- 15-minute expiry, 5 max attempts\n- Timing-safe comparison\n- SQLite storage\n\nWhat's MISSING for production (per the architecture doc):\n1. **Encrypted password storage**: Auto-generated passwords for PDS accounts are stored but not encrypted at rest. Need AES-256-GCM encryption with key from env var or secrets manager.\n2. **OTP replay protection**: Current implementation marks codes as used, but needs explicit single-use enforcement and cleanup.\n3. **Password rotation**: No mechanism to rotate auto-generated passwords if compromised.\n4. **Audit logging**: No structured logging of auth events (OTP sent, verified, failed, account created).\n5. **OTP code cleanup cron**: cleanupExpired() exists but isn't called on a schedule.\n\n## Architecture\nThe sidecar is a monorepo at packages/pds-sidecar/ with three sub-packages:\n- packages/shared/ — DB, OTP service, rate limiter, HMAC signer, mailer (source in TypeScript, compiled to dist/)\n- packages/auth-service/ — Express auth service\n- packages/pds-core/ — PDS wrapper\n\nAll source code needs to be written in TypeScript. The compiled dist/ files exist but source .ts files may need to be created if they don't exist (check the beads/plan-passwordless-login branch for source).\n\n## Hard Constraints\n- No PDS fork — all logic in the sidecar\n- Stock @atproto/pds as npm dependency only\n- SQLite for sidecar data (accounts, OTP tokens)\n- Must work with the existing HMAC callback flow\n\n## Success Looks Like\n- Auto-generated passwords encrypted at rest with AES-256-GCM\n- OTP cleanup runs on a configurable interval\n- Structured audit logging for all auth events\n- Password rotation endpoint exists\n- All changes have unit tests","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T14:03:07.91474+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.840312+08:00","closed_at":"2026-02-18T15:44:48.840315+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-8mu.1","title":"Add AES-256-GCM encrypted storage for auto-generated PDS passwords","description":"## Files\n- packages/pds-sidecar/packages/shared/src/credential-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/credential-store.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add credentials table migration)\n\n## What to do\nCreate a CredentialStore class that encrypts/decrypts auto-generated PDS passwords using AES-256-GCM.\n\n### CredentialStore class\n```typescript\nexport class CredentialStore {\n  constructor(db: BetterSqlite3.Database, encryptionKey: Buffer) // 32-byte key from env\n  encrypt(plaintext: string): { ciphertext: string, iv: string, tag: string }\n  decrypt(ciphertext: string, iv: string, tag: string): string\n  storePassword(did: string, password: string): void  // encrypts then stores\n  getPassword(did: string): string | null  // retrieves and decrypts\n  rotatePassword(did: string, newPassword: string): void  // re-encrypts with new password\n  deletePassword(did: string): void\n}\n```\n\n### DB migration\nAdd a `credentials` table to the SQLite schema:\n```sql\nCREATE TABLE IF NOT EXISTS credentials (\n  did TEXT PRIMARY KEY,\n  encrypted_password TEXT NOT NULL,\n  iv TEXT NOT NULL,\n  auth_tag TEXT NOT NULL,\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n### Encryption details\n- Algorithm: AES-256-GCM (node:crypto)\n- Key: 32-byte Buffer from `CREDENTIAL_ENCRYPTION_KEY` env var (hex-encoded)\n- IV: 12 random bytes per encryption (crypto.randomBytes(12))\n- Auth tag: 16 bytes (default for GCM)\n- Store ciphertext, IV, and auth tag as hex strings in SQLite\n\n### Tests\n- Encrypt then decrypt returns original plaintext\n- Different IVs produce different ciphertexts for same plaintext\n- Tampered ciphertext throws on decrypt\n- Tampered auth tag throws on decrypt\n- storePassword + getPassword roundtrip works\n- rotatePassword updates the stored value\n- getPassword for non-existent DID returns null\n\n## Don't\n- Use any encryption library other than node:crypto\n- Store the encryption key in the database\n- Use CBC mode (must be GCM for authenticated encryption)\n- Use a fixed IV (must be random per encryption)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:03:23.859328+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.937724+08:00","closed_at":"2026-02-18T15:44:48.937728+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-8mu.1","depends_on_id":"hypercerts-scaffold-8mu","type":"parent-child","created_at":"2026-02-18T14:03:23.860319+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-8mu.2","title":"Add structured audit logging for all auth events","description":"## Files\n- packages/pds-sidecar/packages/shared/src/audit-logger.ts (create)\n- packages/pds-sidecar/packages/shared/src/audit-logger.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add audit_log table)\n\n## What to do\nCreate an AuditLogger class that records all auth events to SQLite with structured JSON.\n\n### AuditLogger class\n```typescript\nexport enum AuthEvent {\n  OTP_REQUESTED = 'otp_requested',\n  OTP_SENT = 'otp_sent',\n  OTP_SEND_FAILED = 'otp_send_failed',\n  OTP_VERIFIED = 'otp_verified',\n  OTP_FAILED = 'otp_failed',\n  OTP_EXPIRED = 'otp_expired',\n  OTP_MAX_ATTEMPTS = 'otp_max_attempts',\n  ACCOUNT_CREATED = 'account_created',\n  ACCOUNT_LOGIN = 'account_login',\n  RATE_LIMITED = 'rate_limited',\n  CALLBACK_SIGNED = 'callback_signed',\n  CALLBACK_VERIFIED = 'callback_verified',\n  CALLBACK_REJECTED = 'callback_rejected',\n}\n\nexport class AuditLogger {\n  constructor(db: BetterSqlite3.Database)\n  log(event: AuthEvent, metadata: Record\u003cstring, unknown\u003e): void\n  query(filters: { event?: AuthEvent, email?: string, ip?: string, since?: Date, limit?: number }): AuditEntry[]\n}\n```\n\n### DB table\n```sql\nCREATE TABLE IF NOT EXISTS audit_log (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  event TEXT NOT NULL,\n  email TEXT,\n  ip TEXT,\n  metadata TEXT, -- JSON string\n  created_at TEXT DEFAULT (datetime('now'))\n);\nCREATE INDEX IF NOT EXISTS idx_audit_event ON audit_log(event);\nCREATE INDEX IF NOT EXISTS idx_audit_email ON audit_log(email);\nCREATE INDEX IF NOT EXISTS idx_audit_created ON audit_log(created_at);\n```\n\n### Metadata conventions\n- Always include `ip` when available\n- Always include `email` (masked in logs: a***@example.com)\n- Include `did` for account events\n- Include `reason` for failures\n- Include `requestUri` for OAuth flow events\n\n## Don't\n- Log plaintext passwords or OTP codes (log hashed versions or omit)\n- Log full email addresses in the metadata JSON (mask them)\n- Use console.log — use the existing pino logger from packages/shared/dist/logger.js\n- Block the auth flow on logging failures (fire-and-forget)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:03:39.341591+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.038973+08:00","closed_at":"2026-02-18T15:44:49.038976+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-8mu.2","depends_on_id":"hypercerts-scaffold-8mu","type":"parent-child","created_at":"2026-02-18T14:03:39.343034+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-8mu.3","title":"Add OTP cleanup scheduler and password rotation endpoint","description":"## Files\n- packages/pds-sidecar/packages/shared/src/cleanup-scheduler.ts (create)\n- packages/pds-sidecar/packages/shared/src/cleanup-scheduler.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/admin.ts (create)\n\n## What to do\n\n### 1. Cleanup Scheduler\nCreate a CleanupScheduler that periodically purges expired OTP tokens and old audit logs.\n\n```typescript\nexport class CleanupScheduler {\n  constructor(otpService: OTPService, auditLogger: AuditLogger, intervalMs?: number)\n  start(): void  // starts setInterval\n  stop(): void   // clears interval\n  runOnce(): Promise\u003c{ otpTokensCleaned: number, auditLogsCleaned: number }\u003e\n}\n```\n\n- Default interval: 1 hour (3600000ms)\n- OTP cleanup: delete expired + used tokens (already implemented in OTPService.cleanupExpired())\n- Audit log cleanup: delete entries older than 90 days\n- Log cleanup results via pino logger\n\n### 2. Admin Password Rotation Endpoint\nAdd a POST /admin/rotate-password endpoint to the auth service:\n\n```\nPOST /admin/rotate-password\nAuthorization: Bearer \u003cADMIN_API_KEY\u003e\nBody: { \"did\": \"did:plc:xxx\" }\nResponse: { \"success\": true, \"did\": \"did:plc:xxx\" }\n```\n\nThis endpoint:\n1. Generates a new random 128-char hex password\n2. Calls `com.atproto.server.resetPassword` on the PDS (or uses internal API) to update the PDS account password\n3. Updates the encrypted password in CredentialStore\n4. Logs an ACCOUNT_PASSWORD_ROTATED audit event\n\nProtected by a static API key from `ADMIN_API_KEY` env var (timing-safe comparison).\n\n## Don't\n- Expose the admin endpoint without authentication\n- Use setTimeout recursion (use setInterval)\n- Delete audit logs younger than 90 days\n- Block the main event loop during cleanup","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:03:55.292488+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.131397+08:00","closed_at":"2026-02-18T15:44:49.1314+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-8mu.3","depends_on_id":"hypercerts-scaffold-8mu","type":"parent-child","created_at":"2026-02-18T14:03:55.293729+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-8mu.3","depends_on_id":"hypercerts-scaffold-8mu.1","type":"blocks","created_at":"2026-02-18T14:03:55.295217+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-8mu.3","depends_on_id":"hypercerts-scaffold-8mu.2","type":"blocks","created_at":"2026-02-18T14:03:55.296224+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-97q","title":"Epic: Email-First Passwordless Login UI","description":"## Goal\nReplace the handle-centric login UX with an email-first, passwordless experience that:\n- Collects email (not handle) as the primary identifier\n- Works seamlessly when the PDS supports email OTP (Phase 2, separate repo)\n- Degrades gracefully to handle-based OAuth when the PDS still requires passwords\n- Moves auth from inline dialogs/popovers to dedicated /auth/* pages\n- Supports the cross-app Certified identity model (email as the user-facing identity)\n\n## Context\nThe product spec requires email-first passwordless login for Ma Earth's grants round and the broader Certified ecosystem. The PDS at pds-eu-west4.test.certified.app will be modified separately (see holkexyz/atproto magic-pds for reference implementation). This epic covers only the scaffold-side changes — building the UI, adapting the OAuth flow entry point, and restructuring auth state management.\n\n## Scope\n- IN: New /auth/* pages (signin, verify), auth layout, entryway client, modified login API route, refactored SignedInProvider, updated navbar, cleanup of old login components, config changes\n- OUT: PDS modifications, entryway service, email sending infrastructure, OTP generation/validation (all PDS-side), TOTP/passkey support (future epic)\n\n## Key Constraints\n- The ATProto OAuth flow (PKCE + DPoP) MUST remain functional — it is the only way to get PDS write tokens\n- Redis session/state stores MUST NOT be removed — the ATProto SDK requires them\n- The app/client-metadata.json and app/jwks.json routes MUST NOT be deleted — they are required for ATProto OAuth even with email-first UI\n- Feature flag (NEXT_PUBLIC_ENTRYWAY_URL) controls whether email resolution is attempted; when absent, falls back to handle input\n- All new pages use existing shadcn/ui components and Tailwind CSS v4\n- No new runtime dependencies except the entryway HTTP client (plain fetch)","status":"tombstone","priority":1,"issue_type":"epic","created_at":"2026-02-17T15:38:46.019886+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T15:39:18.298716+08:00","labels":["scope:medium"],"deleted_at":"2026-02-17T15:39:18.298716+08:00","deleted_by":"daemon","delete_reason":"delete","original_type":"epic"}
{"id":"hypercerts-scaffold-9rb","title":"Migrate OAuth scopes from transitional to granular permissions","description":"Code is using transitional OAuth scopes (transition:generic). Should migrate to granular permissions like repo:* or use ScopePresets.FULL_ACCESS from @hypercerts-org/sdk-core.","status":"open","priority":3,"issue_type":"task","owner":"adam@hypercerts.org","created_at":"2026-01-29T00:00:26.475561542+13:00","created_by":"Adam Spiers","updated_at":"2026-01-29T00:00:26.475561542+13:00"}
{"id":"hypercerts-scaffold-aou","title":"Epic: Scaffold Frontend - Email-First Login UX","description":"## Goal\nUpdate the Scaffold app's login experience to show a simple 'Sign in' button as the primary action, replacing the handle-entry form. The actual email/OTP UI lives on the OTP service at certified.app (the reverse proxy), not in Scaffold.\n\n## Architecture\nThe login flow from Scaffold's perspective:\n1. User clicks 'Sign in' on Scaffold\n2. Scaffold BFF initiates PAR to certified.app → proxied to PDS → gets request_uri\n3. Scaffold redirects user to certified.app/oauth/authorize?request_uri=...\u0026client_id=...\n4. OTP service (reverse proxy) intercepts /oauth/authorize → shows email/OTP login UI\n5. User enters email → OTP → verifies\n6. OTP service authenticates against PDS same-origin, device session cookie set on certified.app\n7. OTP service redirects to /oauth/authorize → PDS sees authenticated session → shows consent\n8. Scaffold BFF exchanges authorization code for DPoP-bound tokens\n9. User is logged into Scaffold\n\n## Frontend Changes\n- Primary button: 'Sign in' (no branding) → calls sdk.authorize('https://certified.app')\n- Secondary link: 'Use an ATProto handle instead' → shows existing handle input for ecosystem interop\n- The existing handle-based login remains as a fallback for users with their own PDS\n- No email/OTP UI in Scaffold — that all lives on the OTP service at certified.app\n\n## Files to Modify\n- components/login-dialog.tsx — replace current layout with two-button design\n- queries/auth/use-login-mutation.ts — support 'certified' mode (no handle needed)\n- app/api/auth/login/route.ts — support initiating OAuth against certified.app directly\n- providers/SignedInProvider.tsx — may need minor adjustments for the new flow\n\n## Reference\nSee 'Frontend UX' section in docs/certified-implementation-spec.md","status":"open","priority":1,"issue_type":"epic","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:10:06.639923+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:00:10.504348+08:00"}
{"id":"hypercerts-scaffold-aou.1","title":"Add email-first sign-in button to login dialog","description":"## What to Do\nRefactor the existing login-dialog.tsx to show a simple 'Sign in' button as the primary action, with ATProto handle login as a secondary option. The primary button triggers the Certified OAuth flow which redirects to certified.app where the OTP service's email/OTP UI is served.\n\n### Current State (components/login-dialog.tsx)\nThe current login dialog has:\n- A handle input field (e.g., 'kzoeps.bsky.social')\n- A 'Sign In' button that calls useLoginMutation with the handle\n- A 'Create an account' button that calls loginMutation.mutate(process.env.NEXT_PUBLIC_PDS_URL)\n\n### New Design\nReplace with a two-state layout:\n\n**State 1 (default): Primary sign-in**\n- Large button: 'Sign in' (just 'Sign in' — no branding, no 'with Certified')\n- Styled with bg-create-accent (existing brand color)\n- On click: calls the login mutation in 'certified' mode (no handle needed)\n- This triggers sdk.authorize('https://certified.app') which redirects to certified.app/oauth/authorize\n- The OTP service (reverse proxy at certified.app) intercepts and shows the email/OTP UI\n- Below the button: smaller text link 'Use an ATProto handle instead'\n\n**State 2: ATProto handle expanded**\n- On clicking 'Use an ATProto handle instead': show the existing handle input below\n- The handle input + Sign In button works exactly as before\n- Add a 'Back' link to return to State 1\n\n### Layout Structure\n```\nState 1 (default):\n┌─────────────────────────────────┐\n│          Sign In                │\n│  Sign in to your account       │\n│                                │\n│  [        Sign in           ]  │  ← primary, full-width\n│                                │\n│  Use an ATProto handle instead │  ← secondary text link\n└─────────────────────────────────┘\n\nState 2 (ATProto expanded):\n┌─────────────────────────────────┐\n│   Sign in with ATProto         │\n│   Enter your handle            │\n│                                │\n│   [@] kzoeps.bsky.social       │  ← existing handle input\n│   [        Sign In          ]  │  ← existing submit button\n│                                │\n│   ← Back                       │\n└─────────────────────────────────┘\n```\n\n### Files to Modify\n- components/login-dialog.tsx — main changes here\n- lib/config.ts — add CERTIFIED_PDS_URL config value (or reuse NEXT_PUBLIC_PDS_URL)\n\n### Styling\n- Match existing visual style: glass-panel, create-accent colors, font-outfit, font-syne, animate-fade-in-up\n- Keep the existing Shadcn/ui components (Button, InputGroup, etc.)\n- The 'Sign in' button should feel like the obvious primary action\n- The ATProto link should feel like a secondary/advanced option\n\n### Don't\n- Don't remove the existing handle-based login — keep it as a fallback\n- Don't add email/OTP inputs here — that UI lives on the OTP service at certified.app\n- Don't change the OAuth callback flow\n- Don't add new UI libraries\n- Don't use 'Sign in with Certified' — just 'Sign in'\n\n## Acceptance Criteria\n1. Default view shows 'Sign in' as the primary button\n2. Clicking 'Sign in' triggers OAuth flow against certified.app\n3. 'Use an ATProto handle instead' expands the existing handle input\n4. Handle-based login still works exactly as before\n5. 'Back' link returns to the default view\n6. Visual style matches existing login dialog\n7. TypeScript compiles without errors","status":"in_progress","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:13:38.95266+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T19:21:35.945587+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-aou.1","depends_on_id":"hypercerts-scaffold-aou","type":"parent-child","created_at":"2026-02-18T17:13:38.953475+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-aou.1","depends_on_id":"hypercerts-scaffold-aou.2","type":"blocks","created_at":"2026-02-18T17:16:40.646316+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-aou.2","title":"Update BFF login route for Certified auth mode","description":"## What to Do\nUpdate the /api/auth/login route to support a 'certified' mode where no handle is needed.\n\n### Current State (app/api/auth/login/route.ts)\nCurrently takes a 'handle' from the request body and calls sdk.authorize(handle).\n\n### New Behavior\nAccept either:\n- { handle: string } — existing behavior, authorize against the handle's PDS\n- { mode: 'certified' } — authorize against certified.app directly\n\nWhen mode is 'certified':\n1. Call sdk.authorize(config.certifiedPdsUrl) where certifiedPdsUrl is 'https://certified.app' (from config)\n2. This skips handle resolution and goes directly to certified.app\n3. The OTP service (reverse proxy at certified.app) intercepts /oauth/authorize and shows the email/OTP UI\n4. Return { authUrl } as before\n\n### Config Changes\nAdd to lib/config.ts:\n- certifiedPdsUrl: process.env.CERTIFIED_PDS_URL || process.env.NEXT_PUBLIC_PDS_URL || 'https://certified.app'\n- Add CERTIFIED_PDS_URL to .env.example with a comment\n\n### Files to Modify\n- app/api/auth/login/route.ts — add mode support\n- lib/config.ts — add certifiedPdsUrl\n- .env.example — add CERTIFIED_PDS_URL\n- queries/auth/use-login-mutation.ts — may need to support calling without a handle\n- lib/api/auth.ts — update the login API client function\n\n### Don't\n- Don't break the existing handle-based login\n- Don't remove the handle parameter support\n- Don't hardcode the PDS URL in the route handler\n- Don't reference pds.certified.app or auth.certified.app — the URL is just certified.app\n\n## Acceptance Criteria\n1. POST /api/auth/login with { mode: 'certified' } initiates OAuth against certified.app\n2. POST /api/auth/login with { handle: '...' } still works as before\n3. certifiedPdsUrl is configurable via CERTIFIED_PDS_URL env var\n4. CERTIFIED_PDS_URL is documented in .env.example\n5. TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:13:45.371308+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T19:17:23.647684+08:00","closed_at":"2026-02-18T19:17:23.647684+08:00","close_reason":"44d021e feat: support certified mode in BFF login route","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-aou.2","depends_on_id":"hypercerts-scaffold-aou","type":"parent-child","created_at":"2026-02-18T17:13:45.37247+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-aou.3","title":"Verify OAuth callback works with Certified PDS","description":"## What to Do\nVerify and test that the existing OAuth callback (/api/auth/callback) works correctly when the OAuth flow comes from certified.app (the OTP service reverse proxy in front of the PDS) rather than from a user-entered handle's PDS.\n\n### Current State (app/api/auth/callback/route.ts)\nThe callback handler:\n1. Receives search params from the PDS redirect\n2. Calls sdk.callback(searchParams) to exchange the authorization code for a session\n3. Sets the 'user-did' cookie with the session DID\n4. Redirects to the return_to path or '/'\n\n### What to Verify\n1. sdk.callback() can handle responses from certified.app\n2. The redirect_uri matches what was registered in the PAR request\n3. DPoP proof validation works with certified.app\n4. The session is stored correctly in Redis via the session store\n5. The user-did cookie is set correctly\n\n### Expected: No Code Changes Needed\nThe callback handler is generic — it doesn't care which PDS the OAuth flow came from. The SDK handles all the protocol details. This task is primarily about:\n- Testing the flow end-to-end (or documenting what to test)\n- Identifying any edge cases or config issues\n- Confirming the client-metadata.json and JWKS endpoints are compatible with certified.app\n\n### If Changes Are Needed\nDocument what needs to change and update accordingly. Possible issues:\n- The client_id (client-metadata.json URL) must be fetchable from certified.app (through the reverse proxy to the PDS)\n- The redirect_uri must match exactly\n- PKCE and DPoP must work with the Certified PDS's OAuth provider version\n\n### Don't\n- Don't modify the callback handler unless there's a genuine compatibility issue\n- Don't add Certified-specific logic to the callback — it should remain generic\n\n## Acceptance Criteria\n1. Document that the callback handler is compatible with certified.app (or list required changes)\n2. If changes are needed, implement them\n3. client-metadata.json is accessible from certified.app\n4. TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:13:53.038711+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T19:16:51.067248+08:00","closed_at":"2026-02-18T19:16:51.067248+08:00","close_reason":"bd68ac9 docs: verify OAuth callback compatible with certified.app — no code changes needed, handler is generic and works with any ATProto OAuth provider including certified.app","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-aou.3","depends_on_id":"hypercerts-scaffold-aou","type":"parent-child","created_at":"2026-02-18T17:13:53.040251+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-aou.4","title":"Update SignedInProvider for Certified auth flow","description":"## What to Do\nVerify and update the SignedInProvider server component if needed for the Certified auth flow.\n\n### Current State (providers/SignedInProvider.tsx)\n- Checks for a session via getSession() (reads user-did cookie, restores from Redis)\n- If no session: renders LoginDialog\n- If session: renders Navbar + children\n\n### What to Verify\n1. Session restoration works when the session was created via certified.app\n2. The repo.profile.getCertifiedProfile() call works for accounts created on certified.app\n3. The avatar and handle display correctly for Certified accounts\n\n### Potential Issues\n- New Certified accounts may not have a profile set up yet (getCertifiedProfile might return null)\n- The handle format (alice.certified.app) should display cleanly in the Navbar\n- The Navbar should work correctly with both Certified and non-Certified accounts\n\n### Don't\n- Don't add Certified-specific branching unless absolutely necessary\n- Don't modify the session management logic (it's generic by design)\n- Don't change the layout structure\n\n## Acceptance Criteria\n1. SignedInProvider works with sessions from certified.app\n2. Handle display works for *.certified.app handles\n3. Profile fallbacks work when no profile is set (new users)\n4. TypeScript compiles without errors","status":"closed","priority":1,"issue_type":"task","assignee":"Sharfy Adamantine","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:14:03.318598+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T19:20:32.355492+08:00","closed_at":"2026-02-18T19:20:32.355492+08:00","close_reason":"c3062a2 verify: SignedInProvider works with certified.app sessions — no logic changes needed, removed unused import, all 4 ACs satisfied","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-aou.4","depends_on_id":"hypercerts-scaffold-aou","type":"parent-child","created_at":"2026-02-18T17:14:03.320029+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-ay4","title":"Epic: ATProto/Bluesky Ecosystem Interop","description":"## Goal\nAdd a 'Sign in with ATProto/Bluesky' button alongside the email-first flow, so users with existing Bluesky or ATProto identities can log in using their handle. This provides ecosystem interoperability without compromising the email-first UX for new users.\n\n## Context\nThe architecture doc's execution plan for Day 3 includes: 'Add Sign in with ATProto/Bluesky button for ecosystem interop.'\n\nThe scaffold already has handle-based login (LoginDialog component at components/login-dialog.tsx, /api/auth/login route). This epic adds a clean UX that presents both options:\n1. Primary: 'Sign in with Certified' (email-first, for new/Certified users)\n2. Secondary: 'Sign in with Bluesky/ATProto' (handle-based, for existing ATProto users)\n\nWhen a user signs in with their Bluesky handle, the standard ATProto OAuth flow resolves their handle → DID → PDS and authenticates against their own PDS (e.g., bsky.social). They get a session in our app but their data lives on their own PDS.\n\n## What Has to Be Built\n1. A dual-option login page that presents both auth methods\n2. Handle-based login that resolves to the user's own PDS (not certified.app)\n3. Clear UX distinction between Certified accounts and external ATProto accounts\n4. Session handling that works for both account types\n\n## Hard Constraints\n- Email-first MUST be the primary/default option (larger button, top position)\n- Handle-based login MUST NOT require the user to know their PDS URL\n- Both login methods use the same OAuth callback (/api/auth/callback)\n- External ATProto users don't get OTP — they authenticate on their own PDS\n\n## Success Looks Like\n- Login page shows both options clearly\n- Bluesky users can log in with their handle (e.g., alice.bsky.social)\n- Certified users can log in with email\n- Both get valid sessions in the scaffold app\n- The UX makes it obvious which option to choose","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-02-18T14:11:26.060217+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.628769+08:00","closed_at":"2026-02-18T15:44:51.628787+08:00","labels":["scope:small"]}
{"id":"hypercerts-scaffold-ay4.1","title":"Update /login page with dual-option UI: email-first + ATProto handle fallback","description":"## Files\n- app/login/page.tsx (modify)\n- components/handle-login-section.tsx (create)\n\n## What to do\nUpdate the /login page to present two auth options with email-first as the primary.\n\n### Layout\n```\n┌─────────────────────────────────┐\n│     Sign in to Certified        │\n│                                 │\n│  ┌───────────────────────────┐  │\n│  │  📧 Email address         │  │\n│  │  [alice@example.com    ]  │  │\n│  │  [    Continue →         ]│  │\n│  └───────────────────────────┘  │\n│                                 │\n│  ─── or ────────────────────── │\n│                                 │\n│  Already have a Bluesky or     │\n│  ATProto account?              │\n│  ┌───────────────────────────┐  │\n│  │  🦋 Handle                │  │\n│  │  [alice.bsky.social    ]  │  │\n│  │  [  Sign in with handle ]│  │\n│  └───────────────────────────┘  │\n│                                 │\n└─────────────────────────────────┘\n```\n\n### Behavior\n1. Email section (top, primary):\n   - Uses the existing useEmailLoginMutation hook\n   - Calls /api/auth/email-login with the email\n   - This is the default/highlighted option\n2. Handle section (bottom, secondary):\n   - Uses the existing useLoginMutation hook (from queries/mutations/)\n   - Calls /api/auth/login with the handle\n   - Styled as secondary/muted to indicate it's the alternative\n3. Both sections share the same loading state (disable both while either is in progress)\n4. Error handling: show toast for both (using sonner)\n\n### HandleLoginSection component\n```typescript\nexport function HandleLoginSection(): JSX.Element\n// Renders handle input + submit button\n// Uses existing useLoginMutation\n// Styled as secondary option\n```\n\n### Styling\n- Email section: full-width card with primary button styling\n- Divider: 'or' text with horizontal lines on each side\n- Handle section: smaller, muted styling (outline button, lighter text)\n- Use existing shadcn components (Card, Input, Button, Separator)\n\n## Don't\n- Remove the email-first flow\n- Make the handle option equally prominent (email MUST be primary)\n- Create a new auth flow for handles (reuse existing useLoginMutation)\n- Break the existing /api/auth/login route\n- Add new dependencies","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:11:46.384929+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.714627+08:00","closed_at":"2026-02-18T15:44:51.71463+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-ay4.1","depends_on_id":"hypercerts-scaffold-ay4","type":"parent-child","created_at":"2026-02-18T14:11:46.386522+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-ay4.1","depends_on_id":"hypercerts-scaffold-hpb.1","type":"blocks","created_at":"2026-02-18T14:11:46.388024+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-cw2","title":"Add lock mechanism for ATProto credentials","description":"ATProto SDK warning: No lock mechanism provided. Credentials might get revoked. Need to implement a lock mechanism to prevent credential revocation.","status":"open","priority":3,"issue_type":"task","owner":"adam@hypercerts.org","created_at":"2026-01-29T00:00:28.611778943+13:00","created_by":"Adam Spiers","updated_at":"2026-01-29T00:00:28.611778943+13:00"}
{"id":"hypercerts-scaffold-dpt","title":"Epic: Org Repo Management with Server-Side Signing","description":"## Goal\nEnable organizations to have their own ATProto repos on the PDS, with signing keys held server-side. Our backend mediates all writes to org repos based on RBAC permissions.\n\n## Context\nIn ATProto, every repo has exactly one signing key. For personal repos, the user holds the key. For org repos, our backend holds the key and writes on behalf of authorized users.\n\nThe architecture doc references the PdsAdminService + PdsRecordService pattern from MIGRATION.md. This pattern:\n1. Creates a PDS account for the org (with a server-held signing key)\n2. Stores the org's credentials encrypted (using CredentialStore from Epic: OTP Hardening)\n3. Provides an API for authorized users to create/update/delete records in the org's repo\n4. The backend authenticates to the PDS as the org account and performs the write\n\n### How it works\n```\nUser (authenticated) → Scaffold API → Check RBAC (OrgStore) → PdsRecordService → PDS (as org account)\n```\n\nThe PdsRecordService uses the org's stored credentials to authenticate to the PDS via `com.atproto.server.createSession` and then calls XRPC methods (com.atproto.repo.createRecord, etc.) on behalf of the org.\n\n## Hard Constraints\n- Org signing keys MUST be encrypted at rest (use CredentialStore)\n- All writes MUST check RBAC permissions first\n- The PDS sees org writes as coming from the org's own account (not the user's)\n- Must work with stock @atproto/pds — no fork\n- Org accounts are created via com.atproto.server.createAccount (same as user accounts)\n\n## Dependencies\n- Epic: OTP Hardening (CredentialStore for encrypted password storage)\n- Epic: Org Membership \u0026 RBAC (OrgStore for permission checks)\n\n## Success Looks Like\n- Org PDS accounts can be created programmatically\n- Org credentials stored encrypted\n- PdsRecordService can create/read/update/delete records in org repos\n- All writes are RBAC-gated\n- Works with any ATProto Lexicon (hypercerts, profiles, etc.)","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-02-18T14:08:49.023193+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.796324+08:00","closed_at":"2026-02-18T15:44:50.796327+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-dpt.1","title":"Create PdsAdminService for org account lifecycle management","description":"## Files\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.test.ts (create)\n\n## What to do\nCreate a PdsAdminService that manages org PDS account creation and credential storage.\n\n### PdsAdminService class\n```typescript\nexport class PdsAdminService {\n  constructor(\n    pdsUrl: string,           // e.g., 'https://certified.app'\n    pdsDomain: string,        // e.g., 'certified.app'\n    credentialStore: CredentialStore,\n    orgStore: OrgStore,\n    auditLogger: AuditLogger\n  )\n\n  // Create a new PDS account for an organization\n  // 1. Generate random handle: org-{randomBase36(6)}.certified.app\n  // 2. Generate random password (128 hex chars)\n  // 3. Call com.atproto.server.createAccount via XRPC\n  // 4. Store encrypted password in CredentialStore\n  // 5. Create org record in OrgStore with the returned DID\n  // 6. Add the creating user as admin\n  // 7. Log ACCOUNT_CREATED audit event\n  async createOrgAccount(orgName: string, creatorDid: string): Promise\u003c{ orgId: string, did: string, handle: string }\u003e\n\n  // Delete an org's PDS account (admin only)\n  // 1. Verify caller is admin via OrgStore\n  // 2. Call com.atproto.server.deleteAccount via XRPC (using stored credentials)\n  // 3. Remove from CredentialStore\n  // 4. Remove from OrgStore\n  async deleteOrgAccount(orgId: string, callerDid: string): Promise\u003cvoid\u003e\n\n  // Get a session for an org account (for making writes)\n  // 1. Retrieve encrypted password from CredentialStore\n  // 2. Call com.atproto.server.createSession with org's credentials\n  // 3. Return the session (accessJwt, refreshJwt, did, handle)\n  async getOrgSession(orgId: string): Promise\u003cAtpSessionData\u003e\n}\n```\n\n### XRPC calls\nUse @atproto/api's AtpAgent for XRPC calls:\n```typescript\nimport { AtpAgent } from '@atproto/api'\nconst agent = new AtpAgent({ service: pdsUrl })\nawait agent.createAccount({ handle, email: `org-${orgId}@certified.app`, password })\n```\n\n### Handle format for orgs\n`org-{randomBase36(6)}.certified.app` — prefixed with 'org-' to distinguish from user handles.\n\n## Don't\n- Expose org credentials to the caller\n- Skip RBAC checks on delete\n- Use PDS internal APIs (use XRPC only — this is the external API)\n- Create real email addresses for orgs (use synthetic emails like org-{id}@certified.app)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:09:09.325187+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.89047+08:00","closed_at":"2026-02-18T15:44:50.890472+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-dpt.1","depends_on_id":"hypercerts-scaffold-dpt","type":"parent-child","created_at":"2026-02-18T14:09:09.326241+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-dpt.1","depends_on_id":"hypercerts-scaffold-8mu.1","type":"blocks","created_at":"2026-02-18T14:09:09.327966+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-dpt.1","depends_on_id":"hypercerts-scaffold-xpo.1","type":"blocks","created_at":"2026-02-18T14:09:09.328955+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-dpt.2","title":"Create PdsRecordService for RBAC-gated writes to org repos","description":"## Files\n- packages/pds-sidecar/packages/shared/src/pds-record-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-record-service.test.ts (create)\n\n## What to do\nCreate a PdsRecordService that performs RBAC-gated CRUD operations on org repos.\n\n### PdsRecordService class\n```typescript\nexport class PdsRecordService {\n  constructor(\n    pdsAdminService: PdsAdminService,\n    orgStore: OrgStore,\n    auditLogger: AuditLogger\n  )\n\n  // Create a record in an org's repo\n  // 1. Check RBAC: caller must have 'contributor' or 'admin' role\n  // 2. Get org session via PdsAdminService\n  // 3. Call com.atproto.repo.createRecord via XRPC as the org account\n  // 4. Log audit event\n  async createRecord(orgId: string, callerDid: string, params: {\n    collection: string,  // e.g., 'org.certified.hypercert'\n    record: unknown,     // the record data (any Lexicon)\n    rkey?: string        // optional record key\n  }): Promise\u003c{ uri: string, cid: string }\u003e\n\n  // Get a record from an org's repo (no RBAC needed — ATProto repos are public)\n  async getRecord(orgDid: string, collection: string, rkey: string): Promise\u003cunknown\u003e\n\n  // Update a record in an org's repo\n  // 1. Check RBAC: caller must have 'contributor' or 'admin' role\n  // 2. Get org session\n  // 3. Call com.atproto.repo.putRecord\n  async putRecord(orgId: string, callerDid: string, params: {\n    collection: string,\n    rkey: string,\n    record: unknown,\n    swapRecord?: string  // CID for optimistic concurrency\n  }): Promise\u003c{ uri: string, cid: string }\u003e\n\n  // Delete a record from an org's repo\n  // 1. Check RBAC: caller must have 'admin' role (only admins can delete)\n  // 2. Get org session\n  // 3. Call com.atproto.repo.deleteRecord\n  async deleteRecord(orgId: string, callerDid: string, params: {\n    collection: string,\n    rkey: string,\n    swapRecord?: string\n  }): Promise\u003cvoid\u003e\n\n  // List records in an org's repo (no RBAC needed — public)\n  async listRecords(orgDid: string, collection: string, opts?: {\n    limit?: number,\n    cursor?: string,\n    reverse?: boolean\n  }): Promise\u003c{ records: unknown[], cursor?: string }\u003e\n}\n```\n\n### XRPC calls\nUse @atproto/api's AtpAgent, authenticated with the org's session:\n```typescript\nconst agent = new AtpAgent({ service: pdsUrl })\nagent.session = await pdsAdminService.getOrgSession(orgId)\nawait agent.com.atproto.repo.createRecord({ repo: orgDid, collection, record })\n```\n\n## Don't\n- Skip RBAC checks on any write operation\n- Allow viewers to create/update/delete records\n- Allow contributors to delete records (admin only)\n- Cache org sessions indefinitely (sessions expire — refresh as needed)\n- Expose the org's credentials or session tokens to the caller","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:09:26.251834+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.980108+08:00","closed_at":"2026-02-18T15:44:50.98011+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-dpt.2","depends_on_id":"hypercerts-scaffold-dpt","type":"parent-child","created_at":"2026-02-18T14:09:26.253178+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-dpt.2","depends_on_id":"hypercerts-scaffold-dpt.1","type":"blocks","created_at":"2026-02-18T14:09:26.255023+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-f9e","title":"Epic: Production Security Hardening","description":"## Goal\nHarden the entire auth stack (sidecar + PDS + scaffold) for production use during the Ma Earth grants round. Cover secrets management, email deliverability, rate limiting verification, HTTPS enforcement, and security headers.\n\n## Context\nThe architecture doc identifies these risks:\n- Auto-generated passwords stored server-side (mitigated by CredentialStore encryption in Epic: OTP Hardening)\n- Single PDS = single point of failure\n- Two auth layers to keep in sync\n\nProduction hardening needs:\n1. **Secrets management**: All sensitive env vars (HMAC secret, encryption key, admin API key, SMTP credentials) stored securely, not in .env files in production\n2. **Email deliverability**: SPF/DKIM/DMARC records for certified.app domain, use reputable SMTP provider (Resend, SES, Postmark)\n3. **Rate limiting verification**: Confirm the existing rate limiter (per-email 3/15min 5/hr, per-IP 10/15min) works correctly under load\n4. **HTTPS enforcement**: All production endpoints must be HTTPS only\n5. **Security headers**: HSTS, CSP, X-Frame-Options, X-Content-Type-Options on all sidecar responses\n6. **CORS configuration**: Sidecar must only accept requests from known origins\n7. **Error handling**: No stack traces or internal details leaked in production error responses\n\n## Existing State\n- The sidecar has rate limiting (packages/pds-sidecar/packages/shared/dist/rate-limiter.js)\n- The sidecar has CSRF protection (double-submit cookie)\n- Docker Compose with Caddy exists (packages/pds-sidecar/docker-compose.yml) — Caddy handles TLS\n- Security headers are mentioned in the epic description but implementation status is unknown\n\n## Success Looks Like\n- All secrets stored in env vars (documented) with no defaults\n- Email deliverability tested (SPF/DKIM/DMARC check passes)\n- Rate limiting verified under simulated load\n- All endpoints HTTPS in production\n- Security headers present on all sidecar responses\n- No internal details in error responses","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T14:06:26.593184+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.941251+08:00","closed_at":"2026-02-18T15:44:49.941253+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-f9e.1","title":"Add security headers middleware to sidecar auth service","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/middleware/security-headers.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/security-headers.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/app.ts (modify — add middleware)\n\n## What to do\nCreate an Express middleware that adds security headers to all sidecar responses.\n\n### Headers to set\n```\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\nContent-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; frame-ancestors 'none'\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nX-XSS-Protection: 0\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: camera=(), microphone=(), geolocation=()\nCache-Control: no-store, no-cache, must-revalidate (for auth endpoints only)\n```\n\n### Middleware implementation\n```typescript\nexport function securityHeaders(): RequestHandler {\n  return (req, res, next) =\u003e {\n    // Set all headers listed above\n    // For /auth/* and /oauth/* routes, also set Cache-Control: no-store\n    next()\n  }\n}\n```\n\n### Integration\nAdd the middleware to the Express app in app.ts BEFORE any route handlers:\n```typescript\napp.use(securityHeaders())\n```\n\n### Tests\n- Verify each header is present on a response\n- Verify Cache-Control: no-store is set on /auth/send-code\n- Verify Cache-Control: no-store is set on /oauth/authorize\n- Verify headers are NOT set on health check endpoint (optional — health checks can have headers)\n\n## Don't\n- Use helmet.js or any external dependency (implement manually for transparency)\n- Set CSP that blocks the OTP form's inline styles (the form uses inline styles for the email input)\n- Set HSTS in development (check NODE_ENV)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:06:41.18835+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.041793+08:00","closed_at":"2026-02-18T15:44:50.041797+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-f9e.1","depends_on_id":"hypercerts-scaffold-f9e","type":"parent-child","created_at":"2026-02-18T14:06:41.189421+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-f9e.2","title":"Add production error handler that strips internal details","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/middleware/error-handler.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/error-handler.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/app.ts (modify — add error handler)\n\n## What to do\nCreate an Express error-handling middleware that catches all unhandled errors and returns safe responses.\n\n### Error handler behavior\n```typescript\nexport function errorHandler(): ErrorRequestHandler {\n  return (err, req, res, next) =\u003e {\n    // 1. Log the full error (stack trace, details) via pino logger\n    // 2. In production (NODE_ENV=production):\n    //    - Return { error: 'Internal Server Error' } with status 500\n    //    - Never include stack traces, file paths, or internal details\n    //    - For known error types (ValidationError, RateLimitError), return appropriate status codes\n    // 3. In development:\n    //    - Return { error: err.message, stack: err.stack } for debugging\n  }\n}\n```\n\n### Known error types to handle\n- ValidationError (400) — missing/invalid request params\n- RateLimitError (429) — rate limit exceeded (include Retry-After header)\n- AuthenticationError (401) — invalid OTP, expired session\n- ForbiddenError (403) — invalid HMAC signature\n- NotFoundError (404) — unknown route\n- All others (500) — generic internal error\n\n### Custom error classes\nCreate simple error classes:\n```typescript\nexport class AppError extends Error {\n  constructor(message: string, public statusCode: number, public isOperational: boolean = true) {\n    super(message)\n  }\n}\nexport class ValidationError extends AppError { constructor(msg: string) { super(msg, 400) } }\nexport class RateLimitError extends AppError { constructor(retryAfter: number) { super('Too Many Requests', 429); this.retryAfter = retryAfter } }\nexport class AuthenticationError extends AppError { constructor(msg: string) { super(msg, 401) } }\n```\n\n## Don't\n- Expose stack traces in production\n- Expose file paths in production\n- Expose database error details in production\n- Swallow errors without logging them\n- Use console.log (use pino logger)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:06:56.706777+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.139317+08:00","closed_at":"2026-02-18T15:44:50.13932+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-f9e.2","depends_on_id":"hypercerts-scaffold-f9e","type":"parent-child","created_at":"2026-02-18T14:06:56.707926+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-f9e.3","title":"Create production environment configuration and secrets documentation","description":"## Files\n- docs/production-deployment.md (create)\n- packages/pds-sidecar/.env.production.example (create)\n\n## What to do\nDocument all environment variables needed for production deployment and create an example .env file.\n\n### .env.production.example contents\nList every env var with description, required/optional, and example value:\n\n```bash\n# === PDS Configuration ===\nPDS_HOSTNAME=certified.app          # Required. The PDS domain name\nPDS_DATA_DIRECTORY=/pds/data         # Required. Where PDS stores SQLite + blobs\nPDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=  # Required. secp256k1 private key (hex)\nPDS_JWT_SECRET=                      # Required. Random 32+ char string\nPDS_ADMIN_PASSWORD=                  # Required. PDS admin password\nPDS_EMAIL_SMTP_URL=smtps://...       # Required. SMTP connection string\nPDS_EMAIL_FROM_ADDRESS=noreply@certified.app\n\n# === Sidecar Configuration ===\nSIDECAR_PORT=3001                    # Default: 3001\nSIDECAR_SESSION_SECRET=              # Required. Random 64+ char string\nHMAC_SECRET=                         # Required. Shared secret between sidecar and PDS (64+ hex chars)\nCREDENTIAL_ENCRYPTION_KEY=           # Required. 32-byte hex key for AES-256-GCM\nADMIN_API_KEY=                       # Required. API key for admin endpoints\n\n# === SMTP (for sidecar OTP emails) ===\nSMTP_HOST=smtp.resend.com\nSMTP_PORT=465\nSMTP_USER=resend\nSMTP_PASS=                           # Required. SMTP password\nSMTP_FROM=auth@certified.app\n\n# === Auth Service ===\nAUTH_SERVICE_URL=https://auth.certified.app  # Required. Public URL of sidecar\nPDS_INTERNAL_URL=http://pds:3000     # Required. Internal Docker network URL\n\n# === Node ===\nNODE_ENV=production\n```\n\n### production-deployment.md contents\n1. **Prerequisites** — Docker, Docker Compose, domain with DNS access, SMTP provider account\n2. **DNS Setup** — A records, wildcard for handles, auth subdomain\n3. **Email Deliverability** — SPF, DKIM, DMARC record examples for certified.app\n4. **Secrets Generation** — Commands to generate each secret (openssl rand, etc.)\n5. **Docker Compose** — Reference the existing docker-compose.yml, explain each service\n6. **Caddy Configuration** — TLS, reverse proxy, wildcard certs\n7. **Health Checks** — Endpoints to monitor\n8. **Backup Strategy** — SQLite backup for PDS data and sidecar data\n9. **Monitoring** — What to alert on (auth failures, rate limit hits, PDS errors)\n\n## Don't\n- Include actual secrets or API keys\n- Skip the email deliverability section (SPF/DKIM/DMARC is critical)\n- Assume the reader knows Docker internals\n- Skip the backup strategy","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:07:16.74566+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.310573+08:00","closed_at":"2026-02-18T15:44:50.310578+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-f9e.3","depends_on_id":"hypercerts-scaffold-f9e","type":"parent-child","created_at":"2026-02-18T14:07:16.746925+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-hpb","title":"Epic: OAuth Client Integration for Certified Apps (BFF Pattern)","description":"## Goal\nImplement the OAuth client integration pattern that allows multiple Certified apps (Ma Earth, GainForest, Silvi) to authenticate users via the single Certified PDS using the Backend-for-Frontend (BFF) pattern. Each app gets independent OAuth tokens (DPoP-bound) for the same DID.\n\n## Context\nThe scaffold app (hypercerts-scaffold) already has a working OAuth flow:\n- POST /api/auth/login initiates OAuth via sdk.authorize(handle)\n- GET /api/auth/callback handles the OAuth callback\n- Session stored in Redis via @atproto/oauth-client-node\n- DPoP token binding is handled by the SDK\n\nThe key change for email-first auth: instead of `sdk.authorize(handle)`, apps call `sdk.authorize('https://certified.app')` with `login_hint=email`. This skips handle resolution entirely.\n\nThe /login page and /api/auth/email-login route were built on the beads/plan-passwordless-login branch (tasks hypercerts-scaffold-2bf.1, 2bf.2, 2bf.3 — all completed). These need to be merged to main and verified.\n\n### BFF Pattern\nEach Certified app runs its own backend that:\n1. Has its own OAuth client_id (derived from its public URL per ATProto spec)\n2. Stores its own session/state in Redis\n3. Calls sdk.authorize('https://certified.app', { login_hint: email })\n4. Handles its own /api/auth/callback\n5. Gets DPoP-bound tokens for the user's DID\n\nThe PDS sees each app as a separate OAuth client. The user consents once per app.\n\n## What Has to Be Built\n1. Verify the email-login flow works end-to-end with the sidecar (merge from beads branch)\n2. Document the BFF integration pattern for other Certified apps\n3. Create a minimal example/template that GainForest/Silvi can copy\n4. Add 'Sign in with Certified' button component that's reusable across apps\n\n## Hard Constraints\n- Each app MUST have its own OAuth client_id (no shared clients)\n- Each app MUST run its own backend (no shared sessions)\n- The PDS URL is hardcoded to 'https://certified.app' (or configured via env var)\n- login_hint MUST be passed as email for the sidecar to auto-send OTP\n\n## Success Looks Like\n- Scaffold app authenticates via email-first flow against the Certified PDS\n- Integration guide exists for other Certified apps\n- Reusable 'Sign in with Certified' button component exists\n- Example .env and route files for a new Certified app","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T14:05:23.165082+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.588829+08:00","closed_at":"2026-02-18T15:44:49.588832+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-hpb.1","title":"Merge email-login flow from beads branch and verify against local PDS","description":"## Files\n- app/login/page.tsx (from beads/plan-passwordless-login branch)\n- app/api/auth/email-login/route.ts (from beads/plan-passwordless-login branch)\n- queries/mutations/use-email-login-mutation.ts (from beads/plan-passwordless-login branch)\n- lib/api/auth.ts (modified on beads branch)\n\n## What to do\n1. Cherry-pick or merge the email-login commits from beads/plan-passwordless-login into the current branch\n2. Resolve any merge conflicts\n3. Verify the /login page renders correctly at http://127.0.0.1:3000/login\n4. Verify the /api/auth/email-login route accepts POST with { email } body\n5. Verify the route calls sdk.authorize() with the PDS URL and login_hint=email\n6. Run `pnpm build` to ensure no TypeScript errors\n7. Run `pnpm lint` to ensure no lint errors\n\n### Commits to cherry-pick (from beads/plan-passwordless-login)\n- 0ce88fd: Add useEmailLoginMutation hook and emailLogin API function\n- c354707: fix: address P1/P2 review findings\n- 062b00d: Create /login page with email input form\n- bd90c35: fix: allow /login page to bypass SignedInProvider auth gate\n\n## Don't\n- Modify the existing handle-based login flow (LoginDialog, /api/auth/login)\n- Change any environment variables\n- Modify the OAuth callback route (it handles both flows identically)\n- Cherry-pick unrelated commits from the beads branch","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:05:36.667168+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.676826+08:00","closed_at":"2026-02-18T15:44:49.676829+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-hpb.1","depends_on_id":"hypercerts-scaffold-hpb","type":"parent-child","created_at":"2026-02-18T14:05:36.668579+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-hpb.2","title":"Create Certified OAuth integration guide for partner apps","description":"## Files\n- docs/certified-oauth-integration.md (create)\n\n## What to do\nWrite a comprehensive integration guide that GainForest, Silvi, or any new Certified app can follow to add 'Sign in with Certified' to their app.\n\n### Guide structure\n1. **Overview** — What Certified auth is, how it works (email → OTP → OAuth), what the app needs\n2. **Prerequisites** — Node.js, Redis, @atproto/oauth-client-node or @hypercerts-org/sdk-core\n3. **Step 1: Environment setup** — Required env vars:\n   - NEXT_PUBLIC_PDS_URL=https://certified.app\n   - NEXT_PUBLIC_BASE_URL=https://your-app.com\n   - ATPROTO_JWK_PRIVATE (how to generate with `pnpm run generate-jwk`)\n   - REDIS_HOST, REDIS_PORT, REDIS_PASSWORD\n4. **Step 2: OAuth client metadata** — Explain how ATProto derives client_id from the app's public URL. Show the client-metadata.json and jwks.json route handlers (copy from scaffold).\n5. **Step 3: SDK initialization** — Show createATProtoSDK() setup with Redis session/state stores\n6. **Step 4: Login route** — Show the /api/auth/email-login route that calls sdk.authorize(pdsUrl, { login_hint: email })\n7. **Step 5: Callback route** — Show the /api/auth/callback route\n8. **Step 6: Frontend** — Show the email input form and useEmailLoginMutation hook\n9. **Step 7: Session management** — How to check if user is logged in, get their DID, make authenticated API calls\n10. **Troubleshooting** — Common errors (loopback client issues, CORS, Redis connection, DPoP errors)\n\n### Code examples\nAll code examples should be copied from the actual scaffold codebase (not invented). Reference specific files.\n\n## Don't\n- Include org/RBAC setup (that's a separate guide)\n- Include PDS deployment instructions (that's for the Certified infra team)\n- Invent code examples — copy from the scaffold\n- Skip the troubleshooting section","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:05:54.239742+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.772251+08:00","closed_at":"2026-02-18T15:44:49.772254+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-hpb.2","depends_on_id":"hypercerts-scaffold-hpb","type":"parent-child","created_at":"2026-02-18T14:05:54.241525+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-hpb.3","title":"Create reusable SignInWithCertified button component","description":"## Files\n- components/sign-in-with-certified.tsx (create)\n\n## What to do\nCreate a reusable React button component that initiates the Certified email-first auth flow.\n\n### Component API\n```typescript\ninterface SignInWithCertifiedProps {\n  variant?: 'default' | 'outline' | 'ghost'  // maps to shadcn Button variants\n  size?: 'default' | 'sm' | 'lg'\n  className?: string\n  redirectTo?: string  // where to redirect after login (default: '/')\n}\n\nexport function SignInWithCertified(props: SignInWithCertifiedProps): JSX.Element\n```\n\n### Behavior\n1. Renders a button with the Certified logo/icon and text 'Sign in with Certified'\n2. On click, redirects to /login page (or opens a modal with email input — match the existing LoginDialog pattern)\n3. Uses the existing useEmailLoginMutation hook for the auth flow\n4. Shows loading spinner during OAuth redirect\n5. Handles errors with toast notifications (using sonner, matching existing pattern)\n\n### Styling\n- Use shadcn Button component as base\n- Certified brand color: use the existing gradient/glassmorphism design system\n- Include a small shield/lock icon (from lucide-react) next to the text\n- Responsive: full-width on mobile, auto-width on desktop\n\n### Usage example\n```tsx\nimport { SignInWithCertified } from '@/components/sign-in-with-certified'\n\nexport default function LandingPage() {\n  return \u003cSignInWithCertified variant='default' size='lg' /\u003e\n}\n```\n\n## Don't\n- Add new dependencies (use existing shadcn, lucide-react, sonner)\n- Create a new auth flow — reuse the existing useEmailLoginMutation\n- Hard-code the PDS URL in the component (use NEXT_PUBLIC_PDS_URL from config)\n- Break the existing LoginDialog component","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:06:08.77502+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.857081+08:00","closed_at":"2026-02-18T15:44:49.857084+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-hpb.3","depends_on_id":"hypercerts-scaffold-hpb","type":"parent-child","created_at":"2026-02-18T14:06:08.776449+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-hpb.3","depends_on_id":"hypercerts-scaffold-hpb.1","type":"blocks","created_at":"2026-02-18T14:06:08.777668+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-i6a","title":"Epic: Prototype Evaluation \u0026 PDS Fork Assessment","description":"## Goal\nEvaluate Holke's existing prototype (maearth-demo + magic-pds + holkexyz/atproto fork) to determine what can be reused and what must be rebuilt for Option A (single stock PDS + application-layer passwordless OTP).\n\n## Context\nThree repos exist from Holke's prototype work:\n- `holkexyz/maearth-demo` — Next.js OAuth client at maearth-demo.vercel.app with passwordless email login against pds.certs.network\n- `holkexyz/magic-pds` — 'Passwordless AT Protocol PDS' auth service at auth.pds.certs.network\n- `holkexyz/atproto` — Fork of bluesky-social/atproto labeled 'HolkesPDS - a friendly fork'\n\nThe critical question: does magic-pds require the PDS fork, or does it work against a stock PDS? This determines whether we can reuse the prototype or must rebuild the auth layer.\n\nAdditionally, we already have a pds-sidecar built in this repo (packages/pds-sidecar/) with OTP service, rate limiter, HMAC callback signer, mailer, auth-service routes, and PDS core wrapper. We need to determine the overlap and best path forward.\n\n## Key Questions to Answer\n1. Is holkexyz/atproto actually deployed at pds.certs.network? How far has it diverged from upstream?\n2. How does magic-pds authenticate against the PDS? Hidden-password? Direct DB access? Fork-specific API?\n3. Is magic-pds modifying PDS internals or purely wrapping it?\n4. What hardening exists? Rate limiting, OTP expiry, error handling, email deliverability?\n5. Can we migrate to a stock PDS without breaking magic-pds?\n6. How does our existing pds-sidecar compare to magic-pds? What's the delta?\n\n## Success Looks Like\nA written assessment document (markdown) in docs/ that answers all 6 questions above with concrete evidence (code references, deployment configs, test results). Clear recommendation on whether to adopt magic-pds, adapt our pds-sidecar, or hybrid approach.\n\n## Scope\nResearch and documentation only. No code changes.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T14:02:15.064862+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:40.275429+08:00","closed_at":"2026-02-18T15:44:40.275432+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-i6a.1","title":"Audit holkexyz/magic-pds: determine auth mechanism and PDS fork dependency","description":"## Files\n- docs/prototype-assessment.md (create)\n\n## What to do\n1. Clone holkexyz/magic-pds and read the source code\n2. Determine how it authenticates against the PDS:\n   - Does it use hidden auto-generated passwords (Option A1 pattern)?\n   - Does it directly access the PDS database?\n   - Does it call fork-specific APIs not in stock @atproto/pds?\n   - Does it bypass PDS auth entirely and issue its own tokens?\n3. Check if magic-pds imports anything from holkexyz/atproto that doesn't exist in bluesky-social/atproto\n4. Document the auth flow step-by-step with code references\n5. Write findings in docs/prototype-assessment.md under a '## magic-pds Auth Mechanism' section\n\n## Don't\n- Modify any code in magic-pds or this repo\n- Make assumptions — cite specific code lines\n- Skip checking package.json dependencies for fork references","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:02:27.921641+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.551399+08:00","closed_at":"2026-02-18T15:44:48.551402+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-i6a.1","depends_on_id":"hypercerts-scaffold-i6a","type":"parent-child","created_at":"2026-02-18T14:02:27.923368+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-i6a.2","title":"Audit holkexyz/atproto fork: measure divergence from upstream bluesky-social/atproto","description":"## Files\n- docs/prototype-assessment.md (modify — append section)\n\n## What to do\n1. Clone holkexyz/atproto\n2. Identify the upstream commit it forked from (check git log for the fork point)\n3. Run `git diff \u003cfork-point\u003e..HEAD --stat` to measure total divergence\n4. List every modified file with a 1-line description of what changed\n5. Categorize changes: (a) PDS auth changes, (b) OAuth provider changes, (c) other\n6. Check if pds.certs.network is running this fork (inspect any deployment configs, Dockerfiles, or CI in the repo)\n7. Append findings to docs/prototype-assessment.md under '## Fork Divergence Analysis'\n\n## Don't\n- Modify the fork repo\n- Skip measuring the exact number of changed files and lines\n- Assume the fork is deployed without evidence","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:02:37.812386+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.646765+08:00","closed_at":"2026-02-18T15:44:48.646768+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-i6a.2","depends_on_id":"hypercerts-scaffold-i6a","type":"parent-child","created_at":"2026-02-18T14:02:37.81556+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-i6a.3","title":"Compare pds-sidecar vs magic-pds: feature matrix and recommendation","description":"## Files\n- docs/prototype-assessment.md (modify — append section)\n\n## What to do\n1. Read the existing pds-sidecar code in packages/pds-sidecar/ (compiled JS in dist/ dirs)\n2. Read the magic-pds source code (cloned in previous task)\n3. Create a feature comparison matrix covering:\n   - OTP generation and verification (code length, hashing, expiry, max attempts)\n   - Rate limiting (per-email, per-IP, windows)\n   - Email sending (SMTP integration, templates)\n   - Account creation (handle generation, password management)\n   - OAuth metadata override mechanism\n   - HMAC callback signing\n   - Session management\n   - CSRF protection\n   - Security headers\n   - Error handling and logging\n   - Test coverage\n4. Write a recommendation: adopt magic-pds, keep pds-sidecar, or hybrid\n5. Append to docs/prototype-assessment.md under '## Sidecar vs magic-pds Comparison'\n\n## Don't\n- Modify any code\n- Recommend without justifying each point\n- Skip any of the 10 comparison dimensions listed above","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:02:49.262643+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:48.74298+08:00","closed_at":"2026-02-18T15:44:48.742982+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-i6a.3","depends_on_id":"hypercerts-scaffold-i6a","type":"parent-child","created_at":"2026-02-18T14:02:49.264462+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-i6a.3","depends_on_id":"hypercerts-scaffold-i6a.1","type":"blocks","created_at":"2026-02-18T14:02:49.265724+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-iv0","title":"Epic: Domain Consolidation \u0026 Production Deployment to certified.app","description":"## Goal\nMigrate the entire stack from pds.certs.network to certified.app. Deploy the stock PDS + sidecar auth service under the certified.app domain so that `oauthClient.authorize('https://certified.app')` works in production.\n\n## Context\nCurrently the prototype runs on:\n- PDS: pds.certs.network\n- Auth: auth.pds.certs.network\n\nThe architecture doc recommends everything under certified.app:\n- PDS: certified.app (the PDS hostname)\n- Auth sidecar: auth.certified.app (or as a route on the same domain)\n- Handle resolution: *.certified.app (wildcard DNS for user handles like alice.certified.app)\n\nThis simplifies the `authorize('https://certified.app')` pattern and unifies the brand.\n\n## What Has to Be Done\n1. **DNS configuration**: A records for certified.app, auth.certified.app, and wildcard *.certified.app\n2. **TLS certificates**: Caddy with Let's Encrypt for all domains (DNS challenge for wildcard)\n3. **Docker Compose update**: Update the existing docker-compose.yml to use certified.app hostnames\n4. **PDS configuration**: Set PDS_HOSTNAME=certified.app, configure SMTP for @certified.app\n5. **Sidecar configuration**: Set AUTH_SERVICE_URL=https://auth.certified.app\n6. **Data migration**: If there are existing accounts on pds.certs.network, plan migration (or start fresh)\n7. **Smoke test**: Verify the full flow works with the new domain\n\n## Hard Constraints\n- Stock PDS only — no fork\n- Must support wildcard DNS for handle resolution\n- TLS on all endpoints (no HTTP in production)\n- The PDS at certified.app must serve OAuth authorization server metadata correctly\n- Sidecar must be reachable at auth.certified.app\n\n## Success Looks Like\n- certified.app resolves to the PDS\n- auth.certified.app resolves to the sidecar\n- *.certified.app resolves for handle verification\n- Full email→OTP→OAuth flow works against certified.app\n- OAuth metadata at certified.app/.well-known/oauth-authorization-server shows auth.certified.app as authorization_endpoint","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T14:09:43.125235+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.073705+08:00","closed_at":"2026-02-18T15:44:51.073708+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-iv0.1","title":"Update Docker Compose and Caddyfile for certified.app domain","description":"## Files\n- packages/pds-sidecar/docker-compose.yml (modify)\n- packages/pds-sidecar/Caddyfile (modify or create)\n- packages/pds-sidecar/.env.production.example (modify)\n\n## What to do\nUpdate the Docker Compose stack and Caddy configuration to use the certified.app domain.\n\n### Docker Compose changes\n1. Update PDS service environment:\n   - PDS_HOSTNAME=certified.app\n   - PDS_EMAIL_FROM_ADDRESS=noreply@certified.app\n2. Update sidecar service environment:\n   - AUTH_SERVICE_URL=https://auth.certified.app\n3. Update Caddy service configuration to route:\n   - certified.app → PDS (port 3000)\n   - auth.certified.app → sidecar auth service (port 3001)\n   - *.certified.app → PDS (for handle resolution)\n\n### Caddyfile\n```\ncertified.app {\n  reverse_proxy pds:3000\n}\n\nauth.certified.app {\n  reverse_proxy auth-service:3001\n}\n\n*.certified.app {\n  reverse_proxy pds:3000\n}\n```\n\nFor wildcard TLS, Caddy needs DNS challenge. Add the DNS provider plugin (e.g., cloudflare, route53) and configure via environment variables.\n\n### .env.production.example updates\nAdd/update:\n- CADDY_DNS_PROVIDER (e.g., cloudflare)\n- CADDY_DNS_API_TOKEN (for DNS challenge)\n- PDS_HOSTNAME=certified.app\n- AUTH_SERVICE_URL=https://auth.certified.app\n\n## Don't\n- Remove the existing pds.certs.network configuration (keep it as comments for reference)\n- Hard-code DNS provider credentials\n- Skip wildcard TLS (handles MUST resolve via HTTPS)\n- Change the Docker network topology (PDS and sidecar on same network)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:09:56.999471+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.170445+08:00","closed_at":"2026-02-18T15:44:51.170448+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-iv0.1","depends_on_id":"hypercerts-scaffold-iv0","type":"parent-child","created_at":"2026-02-18T14:09:57.00088+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-iv0.2","title":"Create DNS and email deliverability setup checklist for certified.app","description":"## Files\n- docs/dns-setup-checklist.md (create)\n\n## What to do\nCreate a step-by-step checklist for configuring DNS and email deliverability for the certified.app domain.\n\n### DNS Records Needed\n```\n# A records (replace with actual server IP)\ncertified.app          A    \u003cserver-ip\u003e\nauth.certified.app     A    \u003cserver-ip\u003e\n*.certified.app        A    \u003cserver-ip\u003e\n\n# SPF record (for email sending)\ncertified.app          TXT  \"v=spf1 include:amazonses.com include:resend.com ~all\"\n\n# DKIM record (provider-specific, e.g., Resend)\nresend._domainkey.certified.app  CNAME  \u003cresend-dkim-value\u003e\n\n# DMARC record\n_dmarc.certified.app   TXT  \"v=DMARC1; p=quarantine; rua=mailto:dmarc@certified.app\"\n\n# ATProto-specific: _atproto TXT record for handle verification\n_atproto.certified.app TXT  \"did=did:plc:\u003cpds-did\u003e\"\n```\n\n### Checklist format\nEach item should have:\n- [ ] checkbox\n- What to do\n- How to verify (dig command, curl command, or online tool)\n- Common mistakes to avoid\n\n### Sections\n1. **DNS A Records** — Point all domains to the server\n2. **Wildcard DNS** — Verify *.certified.app resolves\n3. **SPF Setup** — Configure for your SMTP provider\n4. **DKIM Setup** — Generate and add DKIM records\n5. **DMARC Setup** — Configure DMARC policy\n6. **ATProto Handle Verification** — _atproto TXT record\n7. **TLS Verification** — Confirm Caddy issues certs for all domains\n8. **Email Deliverability Test** — Send test email, check spam score\n\n### Verification commands\nInclude specific commands:\n```bash\ndig certified.app A\ndig auth.certified.app A\ndig *.certified.app A\ndig certified.app TXT\ndig _dmarc.certified.app TXT\ncurl -s https://certified.app/xrpc/_health\ncurl -s https://auth.certified.app/health\ncurl -s https://certified.app/.well-known/oauth-authorization-server | jq .authorization_endpoint\n```\n\n## Don't\n- Include actual IP addresses or API keys\n- Skip the verification commands\n- Assume a specific DNS provider (keep it generic)\n- Skip the ATProto-specific DNS records","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:10:13.99869+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:51.258845+08:00","closed_at":"2026-02-18T15:44:51.258848+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-iv0.2","depends_on_id":"hypercerts-scaffold-iv0","type":"parent-child","created_at":"2026-02-18T14:10:14.000213+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-jbx","title":"Fix: OTP generateOTP uses 8-digit range but spec says 6-digit (from hypercerts-scaffold-qc3.2)","description":"Review of hypercerts-scaffold-qc3.2 found: OTPService.generateOTP() uses crypto.randomInt(10000000, 99999999) which generates 8-digit codes, but the epic description (hypercerts-scaffold-qc3) says '6-digit OTP code'. The OTP page template (templates.ts) also uses maxlength='8' and pattern='[0-9]{8}', and the test expects /^\\d{8}$/. There is an internal inconsistency: the epic says 6-digit but the implementation is 8-digit throughout. The implementation is self-consistent (all 8-digit), but it contradicts the epic spec. This should be clarified and the spec or implementation aligned. Evidence: otp-service.ts line 13: randomInt(10000000, 99999999); epic description says '6-digit OTP code'.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-17T18:53:35.160737+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:54:37.717098+08:00","closed_at":"2026-02-17T18:54:37.717108+08:00","dependencies":[{"issue_id":"hypercerts-scaffold-jbx","depends_on_id":"hypercerts-scaffold-qc3.2","type":"discovered-from","created_at":"2026-02-17T18:53:35.355411+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-jw5","title":"Epic: Remove all SDS references and organization features","description":"Remove all Shared Data Server (SDS) infrastructure and organization-related features from the codebase. This includes environment configuration, type definitions, organization pages/components/queries, profile switching, and all related documentation. The application will only support PDS (Personal Data Server) going forward.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-13T10:57:19.625374856+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:08:54.570180551+06:00","closed_at":"2026-02-13T11:08:54.570180551+06:00","close_reason":"Completed: All SDS references and organization features removed"}
{"id":"hypercerts-scaffold-jw5.1","title":"Remove SDS from environment configuration","description":"Remove NEXT_PUBLIC_SDS_URL environment variable from .env.example and .env.local. Remove sdsUrl field and validation from lib/config.ts (lines 194, 210, 236). Files affected: .env.example (lines 52-53), .env.local (line 20), lib/config.ts (lines 194, 210, 236).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:57:25.0772292+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:01:21.906727001+06:00","closed_at":"2026-02-13T11:01:21.906727001+06:00","close_reason":"Completed: 970322f3161f84168f0130778997293b3c3cc853","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.1","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:57:25.078964487+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.10","title":"Remove profile switching dialog","description":"Delete components/profile-switch-dialog.tsx entirely. Remove this component from any layouts or pages that import it (likely in app/layout.tsx or similar). Remove the SignedInProvider usage from providers/SignedInProvider.tsx (line 27) that fetches organization data with getAuthenticatedRepo('sds'). This task depends on hypercerts-scaffold-jw5.3 (session management) because the provider uses serverOverride.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:58:14.830834235+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:06:47.965297704+06:00","closed_at":"2026-02-13T11:06:47.965297704+06:00","close_reason":"Completed: af38f1b","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.10","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:58:14.832712721+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.10","depends_on_id":"hypercerts-scaffold-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:36.962725875+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.11","title":"Update repo context to handle PDS only","description":"Simplify lib/repo-context.ts to only handle PDS. Remove the server determination logic at line 61 (targetDid === userDid ? 'pds' : 'sds'). Remove RepoServer type field from interfaces if no longer needed. This task depends on hypercerts-scaffold-jw5.2 (type definitions) and hypercerts-scaffold-jw5.3 (session management) because we need the core types and session logic updated first.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:58:20.278269871+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:06:32.355814639+06:00","closed_at":"2026-02-13T11:06:32.355814639+06:00","close_reason":"Completed: 024d9b8b1dfe9cd5b49a45aeb7cae96cc95e2667","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.11","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:58:20.279708313+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.11","depends_on_id":"hypercerts-scaffold-jw5.2","type":"blocks","created_at":"2026-02-13T10:58:37.013357307+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.11","depends_on_id":"hypercerts-scaffold-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:37.06325177+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.12","title":"Clean up organization query keys","description":"Remove organization-related query key definitions from lib/api/query-keys.ts (lines 41-48). This task depends on hypercerts-scaffold-jw5.7 (delete organization queries) because we need to ensure no queries are using these keys before removing them.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:58:24.864366819+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:05:14.468657802+06:00","closed_at":"2026-02-13T11:05:14.468657802+06:00","close_reason":"Completed: 2e96aef","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.12","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:58:24.866971645+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.12","depends_on_id":"hypercerts-scaffold-jw5.7","type":"blocks","created_at":"2026-02-13T10:58:37.11335342+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.13","title":"Update README to remove SDS documentation","description":"Remove all SDS references from README.md: line 10 (PDS/SDS account mention), line 45 (environment variable table entry), line 63 (test server URL example), lines 119-127 (architecture diagram and PDS vs SDS explanation), line 196 (organizations on SDS mention), line 254 (link to SDS GitHub repo). Update documentation to reflect PDS-only architecture. This task depends on all previous tasks (hypercerts-scaffold-jw5.1 through hypercerts-scaffold-jw5.12) because documentation should be updated last after all code changes are complete.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:58:31.437345428+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:08:36.620756909+06:00","closed_at":"2026-02-13T11:08:36.620756909+06:00","close_reason":"Completed: README already updated by previous commits","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:58:31.438988373+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.1","type":"blocks","created_at":"2026-02-13T10:58:42.980883411+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.2","type":"blocks","created_at":"2026-02-13T10:58:43.031383969+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:43.083619404+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.4","type":"blocks","created_at":"2026-02-13T10:58:43.135155641+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.5","type":"blocks","created_at":"2026-02-13T10:58:43.197015061+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.6","type":"blocks","created_at":"2026-02-13T10:58:43.246763992+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.7","type":"blocks","created_at":"2026-02-13T10:58:43.295935142+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.8","type":"blocks","created_at":"2026-02-13T10:58:43.345300956+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.9","type":"blocks","created_at":"2026-02-13T10:58:43.395508806+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.10","type":"blocks","created_at":"2026-02-13T10:58:43.443782516+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.11","type":"blocks","created_at":"2026-02-13T10:58:43.492942164+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.13","depends_on_id":"hypercerts-scaffold-jw5.12","type":"blocks","created_at":"2026-02-13T10:58:43.545747096+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.2","title":"Update type definitions to remove SDS","description":"Change RepoServer type from 'pds' | 'sds' to just 'pds' in lib/repo-context.ts (line 8). Remove serverOverride parameter type that includes 'sds' from lib/atproto-session.ts (line 8). Update all type usage to reflect PDS-only infrastructure. Files affected: lib/repo-context.ts (lines 8, 23, 30, 61), lib/atproto-session.ts (lines 8, 19).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:57:31.387671487+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:01:52.916414734+06:00","closed_at":"2026-02-13T11:01:52.916414734+06:00","close_reason":"Completed: 7cb57ff4f0e9545e9fd8b27d194de5236d269061","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.2","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:57:31.390035933+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.3","title":"Simplify session management by removing SDS logic","description":"Remove serverOverride parameter from getAuthenticatedRepo function in lib/atproto-session.ts (line 8). Remove server determination logic that defaults organizations to SDS (lines 19-26). Simplify to always use PDS. Remove comment about SDS default for organizations (line 23). This task depends on hypercerts-scaffold-jw5.2 (type definition updates) because we need the types updated first.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:57:36.812241339+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:03:28.27736993+06:00","closed_at":"2026-02-13T11:03:28.27736993+06:00","close_reason":"Completed: f904aed717e18e851fcd2d6e590836fa9b7dc689","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.3","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:57:36.814164408+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.3","depends_on_id":"hypercerts-scaffold-jw5.2","type":"blocks","created_at":"2026-02-13T10:58:36.651339481+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.4","title":"Update SDK initialization to remove SDS","description":"Remove 'sds: config.sdsUrl' from SDK server configuration in lib/hypercerts-sdk.ts (line 39). Update SDK initialization to only use PDS. This task depends on hypercerts-scaffold-jw5.1 (environment config removal) because we need config.sdsUrl removed first.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:57:41.609155705+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:03:51.936722151+06:00","closed_at":"2026-02-13T11:03:51.936722151+06:00","close_reason":"Completed: 0ee8d8c967f42b720a0203022ce99e33647cb12a","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.4","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:57:41.611008192+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.4","depends_on_id":"hypercerts-scaffold-jw5.1","type":"blocks","created_at":"2026-02-13T10:58:36.701434689+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.5","title":"Delete organization pages","description":"Delete the entire app/organizations/ directory, which includes: page.tsx (organization list), [orgDid]/page.tsx (organization detail), create/page.tsx (create organization), create/layout.tsx, loading.tsx, and [orgDid]/loading.tsx. This task depends on hypercerts-scaffold-jw5.3 (session management simplification) because those files use the serverOverride parameter that will be removed.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:57:46.81007388+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:04:11.172066695+06:00","closed_at":"2026-02-13T11:04:11.172066695+06:00","close_reason":"Completed: 3428fe02f55fe17c9193be3d78e01b24903474a5","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.5","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:57:46.811920897+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.5","depends_on_id":"hypercerts-scaffold-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:36.75669208+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.6","title":"Delete organization components","description":"Delete organization-related components: components/organization-form.tsx, components/organization-detail-view.tsx, components/organization-creation-success.tsx, components/collaborators-list-view.tsx, components/add-contributors-form.tsx. Remove any imports of these components from other files. This task can run in parallel with hypercerts-scaffold-jw5.5 (delete pages) since they are independent.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:57:52.089516982+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:02:17.815171991+06:00","closed_at":"2026-02-13T11:02:17.815171991+06:00","close_reason":"Completed: 4299fe74ca5d3a6bc7dcd16db4478e21495c7e5c","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.6","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:57:52.091170987+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.7","title":"Delete organization queries","description":"Delete the entire queries/organizations/ directory, which includes use-check-handle-query.ts and index.ts. Also remove checkHandleAvailability function from lib/api/external/bluesky.ts (lines 42-60) that checks handle availability on SDS server. This task can run in parallel with hypercerts-scaffold-jw5.5 and hypercerts-scaffold-jw5.6.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:57:57.491629768+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:02:44.401504275+06:00","closed_at":"2026-02-13T11:02:44.401504275+06:00","close_reason":"Completed: f20bf2f4eb234d67c9e06a9b71b103be938c90f9","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.7","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:57:57.493747823+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.8","title":"Remove organization operations from create-actions","description":"Remove organization-related functions from lib/create-actions.ts: lines 202 (create org with serverOverride), 214 (add collaborators), 232 (remove collaborators), 246 (list organizations). This task depends on hypercerts-scaffold-jw5.3 (session management) because these functions use serverOverride parameter.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:58:02.724974343+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:07:24.646163697+06:00","closed_at":"2026-02-13T11:07:24.646163697+06:00","close_reason":"Completed: 8b6439f","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.8","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:58:02.726703099+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.8","depends_on_id":"hypercerts-scaffold-jw5.3","type":"blocks","created_at":"2026-02-13T10:58:36.812943121+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-jw5.9","title":"Simplify blob utilities to remove SDS URL handling","description":"Remove SDS URL handling from lib/blob-utils.ts (line 25) - simplify blob URL resolution to only use PDS. Remove SDS URL usage from app/hypercerts/[hypercertUri]/page.tsx (line 86) for image blob resolution. This task depends on hypercerts-scaffold-jw5.1 (environment config) and hypercerts-scaffold-jw5.5 (delete org pages) because we need config cleaned up and no org pages referencing blobs.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T10:58:09.274201803+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:07:42.730303409+06:00","closed_at":"2026-02-13T11:07:42.730303409+06:00","close_reason":"Completed: Already cleaned up in previous commits","dependencies":[{"issue_id":"hypercerts-scaffold-jw5.9","depends_on_id":"hypercerts-scaffold-jw5","type":"parent-child","created_at":"2026-02-13T10:58:09.276322082+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.9","depends_on_id":"hypercerts-scaffold-jw5.1","type":"blocks","created_at":"2026-02-13T10:58:36.863175646+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-jw5.9","depends_on_id":"hypercerts-scaffold-jw5.5","type":"blocks","created_at":"2026-02-13T10:58:36.913677646+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-l3s","title":"Epic: Certified Email-First Auth (Option A1)","description":"## Goal\nImplement Option A1 from docs/architecture-decision-certified-email-auth.md: passwordless email login for Certified apps using a stock (unmodified) PDS at certified.app.\n\n## Context\nUsers currently see 'enter your handle' and leave. We need: email → OTP code → they're in. No handles, no passwords, no 'what's a PDS.' Sign-up and sign-in are identical from the user's perspective.\n\n## Architecture (Option A1)\nA separate Certified backend service handles the passwordless UX:\n1. User enters email on our app\n2. Backend generates OTP, sends via email\n3. User enters code, backend validates\n4. Backend authenticates against the stock PDS using an auto-generated password the user never sees\n5. On sign-up: backend calls com.atproto.server.createAccount with a random password, stores it encrypted\n6. After OTP validation: backend initiates the ATProto OAuth flow server-side using the hidden password\n7. User sees OAuth consent screen, approves, gets redirected back\n\n## Hard Constraints\n- NO PDS fork — stock PDS only, all logic in our application layer\n- NO sidecar — no wrapping/intercepting PDS internals\n- NO modifying PDS source code\n- The PDS stays vanilla and upgradeable\n- Talk to PDS only via its public XRPC API\n\n## What Success Looks Like\nUser on Ma Earth clicks 'Sign in with Certified' → enters email → gets OTP → enters code → approves OAuth consent → redirected back, logged in. Sign-up is identical (auto-creates account if email unknown).\n\n## Scope\nAuth only. Org/RBAC is a separate parallel workstream.\n\n## Reference\nSee docs/architecture-decision-certified-email-auth.md for full architecture decision document.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T16:05:21.16283+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.096751+08:00","closed_at":"2026-02-18T17:09:26.096751+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-l3s.1","title":"Set up credential store schema and encryption utilities","description":"## Files\n- lib/auth/credential-store.ts (create)\n- lib/auth/encryption.ts (create)\n\n## What to do\nCreate the credential store that maps email → {did, handle, encryptedPassword} and the encryption utilities for storing auto-generated PDS passwords.\n\n### credential-store.ts\n- Use Redis (already available in the project via lib/config.ts redis config) to store user credentials\n- Key pattern: `certified:user:{email}` → JSON object: `{ did: string, handle: string, encryptedPassword: string, createdAt: string }`\n- Key pattern: `certified:did:{did}` → email (reverse lookup)\n- Export functions:\n  - `storeUserCredentials(email: string, did: string, handle: string, password: string): Promise\u003cvoid\u003e` — encrypts password before storing\n  - `getUserByEmail(email: string): Promise\u003c{ did: string, handle: string, encryptedPassword: string } | null\u003e`\n  - `getUserByDid(did: string): Promise\u003c{ email: string, did: string, handle: string, encryptedPassword: string } | null\u003e`\n  - `getDecryptedPassword(email: string): Promise\u003cstring | null\u003e` — retrieves and decrypts the password\n  - `userExists(email: string): Promise\u003cboolean\u003e`\n\n### encryption.ts\n- Use Node.js built-in `crypto` module (no new dependencies)\n- AES-256-GCM encryption/decryption\n- Encryption key from env var `CREDENTIAL_ENCRYPTION_KEY` (32-byte hex string)\n- Export functions:\n  - `encrypt(plaintext: string): string` — returns `iv:authTag:ciphertext` (all hex-encoded)\n  - `decrypt(encrypted: string): string` — parses and decrypts\n  - `generatePassword(): string` — generates a cryptographically random 32-char password using `crypto.randomBytes`\n\n## Don't\n- Don't use any external encryption libraries — Node.js crypto is sufficient\n- Don't store passwords in plaintext\n- Don't use a separate database — use the existing Redis instance\n- Don't import from or depend on the PDS codebase","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T16:05:48.357409+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.728803+08:00","closed_at":"2026-02-18T17:09:29.728803+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.1","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:05:48.36201+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-l3s.1","depends_on_id":"hypercerts-scaffold-l3s.7","type":"blocks","created_at":"2026-02-18T16:08:24.692104+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-l3s.2","title":"Build OTP generation, validation, and email sending service","description":"## Files\n- lib/auth/otp-service.ts (create)\n- lib/auth/email-sender.ts (create)\n\n## What to do\nBuild the OTP service that generates codes, stores them in Redis with expiry, validates them, and sends them via email.\n\n### otp-service.ts\n- OTP codes: 6-digit numeric strings (zero-padded)\n- Generate using `crypto.randomInt(0, 999999)`\n- Store in Redis with key pattern: `certified:otp:{email}` → JSON: `{ code: string, attempts: number, createdAt: number }`\n- TTL: 10 minutes (configurable via `OTP_TTL_SECONDS` env var, default 600)\n- Max attempts per code: 5 (configurable via `OTP_MAX_ATTEMPTS` env var, default 5)\n- Rate limiting: max 3 OTP requests per email per 15 minutes. Use Redis key `certified:otp-rate:{email}` with TTL 900s, increment on each send\n- Export functions:\n  - `generateAndSendOTP(email: string): Promise\u003c{ success: boolean, error?: string }\u003e` — generates code, stores in Redis, sends email. Returns error if rate limited.\n  - `validateOTP(email: string, code: string): Promise\u003c{ valid: boolean, error?: string }\u003e` — checks code, increments attempt counter, deletes on success. Returns error if expired or max attempts exceeded.\n  - `invalidateOTP(email: string): Promise\u003cvoid\u003e` — deletes the OTP (used after successful auth)\n\n### email-sender.ts\n- Use Nodemailer (add `nodemailer` + `@types/nodemailer` as dependencies)\n- Configure via env var `SMTP_URL` (standard Nodemailer connection string, e.g. `smtps://user:pass@smtp.example.com`)\n- `FROM_EMAIL` env var for sender address (default: `noreply@certified.app`)\n- Export function:\n  - `sendOTPEmail(to: string, code: string): Promise\u003cvoid\u003e`\n- Email template: simple HTML with the 6-digit code prominently displayed. Subject: 'Your Certified login code'. Body: 'Your verification code is: {code}. It expires in 10 minutes. If you didn't request this, ignore this email.'\n- Log email sends (but not the code itself) for debugging\n\n## Don't\n- Don't use any OTP library — the logic is simple enough to implement directly\n- Don't store OTP codes without expiry\n- Don't log the actual OTP code in production (only in development mode)\n- Don't allow unlimited OTP attempts (must enforce max attempts)\n- Don't skip rate limiting","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T16:06:08.090862+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.731903+08:00","closed_at":"2026-02-18T17:09:29.731903+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.2","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:06:08.092285+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-l3s.2","depends_on_id":"hypercerts-scaffold-l3s.7","type":"blocks","created_at":"2026-02-18T16:08:24.847074+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-l3s.3","title":"Build PDS account management service (create account, create session)","description":"## Files\n- lib/auth/pds-account-service.ts (create)\n\n## What to do\nCreate a service that talks to the stock PDS via its public XRPC API to create accounts and sessions. This is the bridge between our OTP layer and the PDS.\n\n### pds-account-service.ts\nUses the `@atproto/api` package (already in package.json) to call PDS XRPC endpoints.\n\n- PDS URL from existing `config.pdsUrl` (lib/config.ts)\n- Export functions:\n\n#### createAccount\n`createPdsAccount(email: string, password: string): Promise\u003c{ did: string, handle: string, accessJwt: string, refreshJwt: string }\u003e`\n- Calls `com.atproto.server.createAccount` on the PDS\n- Handle generation: extract local part of email (before @), sanitize to alphanumeric + hyphens only, lowercase. If collision (PDS returns error), append random 4-digit suffix and retry (max 3 retries).\n- The handle format is `{localpart}.{pds-hostname}` — e.g. for email `alice@example.com` on PDS `certified.app`, handle = `alice.certified.app`\n- Pass the email and password to createAccount\n- Return the DID, handle, accessJwt, refreshJwt from the PDS response\n\n#### createSession\n`createPdsSession(identifier: string, password: string): Promise\u003c{ did: string, handle: string, accessJwt: string, refreshJwt: string }\u003e`\n- Calls `com.atproto.server.createSession` on the PDS\n- `identifier` can be a DID or handle\n- Returns the session tokens\n\n#### describeServer\n`describePdsServer(): Promise\u003c{ availableUserDomains: string[], inviteCodeRequired: boolean }\u003e`\n- Calls `com.atproto.server.describeServer` to check PDS configuration\n- Used to verify the PDS is reachable and get available user domains for handle generation\n\n### Error handling\n- Wrap XRPC errors in typed errors: `PdsAccountError` with fields `{ code: string, message: string, status: number }`\n- Handle specific error codes: `HandleNotAvailable`, `InvalidHandle`, `AccountTakedown`, network errors\n- Log errors with context but never log passwords\n\n## Don't\n- Don't import PDS internals — only use the public `@atproto/api` client (`AtpAgent`)\n- Don't cache sessions — each call creates a fresh session\n- Don't modify the PDS in any way\n- Don't use admin endpoints — only public XRPC endpoints\n- Don't hardcode the PDS URL — use config.pdsUrl","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T16:06:30.962242+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.081943+08:00","closed_at":"2026-02-18T17:09:26.081943+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.3","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:06:30.963484+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-l3s.4","title":"Build unified auth orchestrator (sign-up + sign-in via OTP)","description":"## Files\n- lib/auth/auth-orchestrator.ts (create)\n\n## What to do\nCreate the orchestrator that ties together the OTP service, credential store, and PDS account service into the unified sign-up/sign-in flow described in the architecture doc. Sign-up and sign-in are identical from the user's perspective.\n\n### auth-orchestrator.ts\nThis is the main entry point for the auth flow. It coordinates the other services.\n\n#### Flow: Request OTP\n`requestOTP(email: string): Promise\u003c{ success: boolean, isNewUser: boolean, error?: string }\u003e`\n1. Validate email format (basic regex: contains @ and a dot after @)\n2. Normalize email: lowercase, trim whitespace\n3. Check if user exists in credential store (getUserByEmail)\n4. Call generateAndSendOTP(email) from otp-service\n5. Return success + whether this is a new user (informational only — flow is identical either way)\n\n#### Flow: Verify OTP and authenticate\n`verifyOTPAndAuthenticate(email: string, code: string): Promise\u003c{ success: boolean, did: string, handle: string, error?: string }\u003e`\n1. Call validateOTP(email, code) from otp-service\n2. If invalid, return error\n3. If valid, check if user exists in credential store:\n   - **Existing user**: retrieve decrypted password, call createPdsSession(did, password) to verify PDS account still works\n   - **New user**: generate password via generatePassword(), call createPdsAccount(email, password), store credentials via storeUserCredentials(email, did, handle, password)\n4. Return { success: true, did, handle }\n\n#### Flow: Get OAuth authorize URL\n`getOAuthAuthorizeUrl(did: string): Promise\u003cstring\u003e`\n1. Use the existing SDK (`lib/hypercerts-sdk.ts`) to call `sdk.authorize(config.pdsUrl)`\n2. This returns the PDS OAuth authorize URL that the user should be redirected to\n3. The PDS will show its consent screen (the user already authenticated via OTP, so this is just consent)\n\nNote: The tricky part is that the PDS OAuth flow normally requires the user to enter handle+password on the PDS login form. Since we've already verified the user via OTP, we need the user to complete the PDS login form using their hidden credentials. There are two approaches:\n- **Approach 1 (simpler)**: After OTP verification, redirect user to PDS OAuth authorize URL. The PDS shows its login form. We pre-fill or auto-submit the form with the hidden credentials. This requires client-side JS to interact with the PDS login page — fragile.\n- **Approach 2 (recommended)**: After OTP verification, the backend creates a PDS session (createSession), then uses that session to programmatically complete the OAuth authorization. The user only sees the consent screen.\n\nFor now, implement the simpler version: after OTP verification, return the user's DID and handle. The frontend will initiate the OAuth flow via `sdk.authorize(config.pdsUrl)`, and the user will need to complete the PDS login form. We'll address the UX gap (user seeing PDS password form) in a follow-up task.\n\n**Important**: Document this UX gap clearly in a code comment. The architecture doc's ideal flow (steps 2-6) assumes the user never sees a password form, but achieving that requires either intercepting the PDS OAuth flow or building a custom OAuth provider — both of which are out of scope for this task.\n\n## Don't\n- Don't build a custom OAuth provider\n- Don't modify the PDS\n- Don't try to programmatically fill in the PDS login form (fragile, will break)\n- Don't skip email validation\n- Don't allow OTP verification without a prior OTP request","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T16:07:00.532776+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.735282+08:00","closed_at":"2026-02-18T17:09:29.735282+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.4","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:07:00.533767+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-l3s.4","depends_on_id":"hypercerts-scaffold-l3s.1","type":"blocks","created_at":"2026-02-18T16:08:24.993909+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-l3s.4","depends_on_id":"hypercerts-scaffold-l3s.2","type":"blocks","created_at":"2026-02-18T16:08:25.178576+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-l3s.4","depends_on_id":"hypercerts-scaffold-l3s.3","type":"blocks","created_at":"2026-02-18T16:08:25.296417+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-l3s.5","title":"Create API routes for OTP auth flow","description":"## Files\n- app/api/auth/otp/request/route.ts (create)\n- app/api/auth/otp/verify/route.ts (create)\n\n## What to do\nCreate Next.js API routes that expose the OTP auth flow to the frontend.\n\n### POST /api/auth/otp/request\nRequest body: `{ email: string }`\nResponse 200: `{ success: true, isNewUser: boolean }`\nResponse 400: `{ error: 'Invalid email format' }`\nResponse 429: `{ error: 'Too many requests. Try again later.' }`\nResponse 500: `{ error: 'Failed to send verification code' }`\n\nImplementation:\n1. Parse and validate request body (email is required, must be a string)\n2. Call `requestOTP(email)` from auth-orchestrator\n3. Return appropriate response based on result\n\n### POST /api/auth/otp/verify\nRequest body: `{ email: string, code: string }`\nResponse 200: `{ success: true, did: string, handle: string, authUrl: string }`\nResponse 400: `{ error: 'Invalid or expired code' }` or `{ error: 'Too many attempts' }`\nResponse 500: `{ error: 'Authentication failed' }`\n\nImplementation:\n1. Parse and validate request body (email and code are required)\n2. Call `verifyOTPAndAuthenticate(email, code)` from auth-orchestrator\n3. If successful, call `sdk.authorize(config.pdsUrl)` to get the OAuth authorize URL (same pattern as existing app/api/auth/login/route.ts)\n4. Return the authUrl along with did and handle\n\n### Shared concerns\n- Both routes are POST-only (return 405 for other methods — Next.js handles this automatically by only exporting POST)\n- Use standard Next.js 16 route handler patterns (see existing routes in app/api/auth/ for reference)\n- Import from `@/lib/auth/auth-orchestrator`\n- Import sdk from `@/lib/hypercerts-sdk` (for the authorize call in verify)\n- Log errors server-side but don't expose internal details to the client\n\n## Don't\n- Don't add authentication middleware to these routes (they ARE the auth flow)\n- Don't return internal error details to the client\n- Don't use GET methods for these routes (they mutate state)\n- Don't duplicate logic from auth-orchestrator — just call it","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T16:07:19.552259+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.737406+08:00","closed_at":"2026-02-18T17:09:29.737406+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.5","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:07:19.553674+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-l3s.5","depends_on_id":"hypercerts-scaffold-l3s.4","type":"blocks","created_at":"2026-02-18T16:08:25.397689+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-l3s.6","title":"Build email-first login UI (replace handle input with email+OTP flow)","description":"## Files\n- components/email-login-dialog.tsx (create)\n- queries/otp-auth.ts (create)\n- components/login-dialog.tsx (modify — add toggle or replace)\n\n## What to do\nCreate a new email-first login component that implements the OTP flow, and wire it into the app.\n\n### queries/otp-auth.ts\nCreate React Query mutation hooks for the OTP API routes:\n\n```typescript\n// Hook: useRequestOTP\n// Calls POST /api/auth/otp/request with { email }\n// Returns mutation with { success, isNewUser } on success\n\n// Hook: useVerifyOTP\n// Calls POST /api/auth/otp/verify with { email, code }\n// On success: redirects to authUrl (same pattern as useLoginMutation in queries/auth.ts)\n```\n\nFollow the same patterns as the existing `queries/auth.ts` file.\n\n### components/email-login-dialog.tsx\nA multi-step login form with two states:\n\n**Step 1: Email input**\n- Header: 'Sign In' (same as current)\n- Subtext: 'Enter your email to continue'\n- Email input field (type=email, placeholder='alice@example.com')\n- 'Continue' button → calls useRequestOTP\n- Loading state while sending OTP\n- Error display for invalid email or rate limiting\n\n**Step 2: OTP code input**\n- Header: 'Check your email'\n- Subtext: 'We sent a 6-digit code to {email}'\n- 6-digit code input field (type=text, inputMode=numeric, maxLength=6, autoFocus)\n- 'Verify' button → calls useVerifyOTP\n- 'Use a different email' link → goes back to step 1\n- 'Resend code' button (disabled for 30 seconds after send, then enabled)\n- Loading state while verifying\n- Error display for invalid code or too many attempts\n\n**Styling**: Use the same Shadcn/ui components and Tailwind classes as the existing login-dialog.tsx. Match the existing visual style (glass-panel, create-accent colors, font-outfit, font-syne, animate-fade-in-up).\n\n### components/login-dialog.tsx (modify)\n- Add an 'Or sign in with ATProto handle' link/button below the email form that shows the existing handle-based login (for ecosystem interop, as mentioned in the architecture doc)\n- OR: Replace the default view with EmailLoginDialog and add a toggle to switch to handle-based login\n- The handle-based login should still work exactly as before\n\n## Don't\n- Don't remove the existing handle-based login — keep it as a fallback\n- Don't change the existing OAuth callback flow (app/api/auth/callback/route.ts)\n- Don't add new UI libraries — use existing Shadcn/ui components\n- Don't auto-submit the OTP form (let the user click Verify)\n- Don't show the PDS password to the user anywhere","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T16:07:44.112169+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:29.739338+08:00","closed_at":"2026-02-18T17:09:29.739338+08:00","close_reason":"Superseded by new epic structure","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.6","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:07:44.113579+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-l3s.6","depends_on_id":"hypercerts-scaffold-l3s.5","type":"blocks","created_at":"2026-02-18T16:08:25.503365+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-l3s.7","title":"Update environment configuration for OTP auth","description":"## Files\n- .env.example (modify)\n- lib/config.ts (modify)\n\n## What to do\nAdd the new environment variables needed for the OTP auth flow to the config system.\n\n### .env.example (modify)\nAdd a new section after the existing 'Redis Configuration' section:\n\n```\n# -----------------------------\n# Certified Email Auth (OTP)\n# -----------------------------\n# Encryption key for storing auto-generated PDS passwords\n# Must be a 64-character hex string (32 bytes)\n# Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('hex'))\"\nCREDENTIAL_ENCRYPTION_KEY=\n\n# SMTP configuration for sending OTP emails\n# Format: smtps://user:pass@smtp.example.com\nSMTP_URL=\n\n# Sender email address for OTP emails\nFROM_EMAIL=noreply@certified.app\n\n# OTP configuration (optional, defaults shown)\n# OTP_TTL_SECONDS=600\n# OTP_MAX_ATTEMPTS=5\n```\n\n### lib/config.ts (modify)\nAdd the new env vars to the config object and validation:\n\n1. Add to the `config` object:\n   - `credentialEncryptionKey: process.env.CREDENTIAL_ENCRYPTION_KEY!`\n   - `smtpUrl: process.env.SMTP_URL!`\n   - `fromEmail: process.env.FROM_EMAIL || 'noreply@certified.app'`\n   - `otpTtlSeconds: parseInt(process.env.OTP_TTL_SECONDS || '600', 10)`\n   - `otpMaxAttempts: parseInt(process.env.OTP_MAX_ATTEMPTS || '5', 10)`\n\n2. Add `CREDENTIAL_ENCRYPTION_KEY` and `SMTP_URL` to the `requiredEnvVars` array\n\n3. Add validation for CREDENTIAL_ENCRYPTION_KEY: must be exactly 64 hex characters. Throw a descriptive error if not.\n\n4. Add to the startup log:\n   - `SMTP: configured` (don't log the actual URL — it contains credentials)\n   - `OTP TTL: {otpTtlSeconds}s`\n\n## Don't\n- Don't log SMTP_URL or CREDENTIAL_ENCRYPTION_KEY values\n- Don't change existing config values or behavior\n- Don't remove any existing env vars\n- Don't add the actual secret values to .env.example","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T16:08:04.733181+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.092782+08:00","closed_at":"2026-02-18T17:09:26.092782+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.7","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:08:04.73518+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-l3s.8","title":"Clean up old pds-sidecar artifacts","description":"## Files\n- packages/pds-sidecar/ (delete entire directory)\n- .gitmodules (modify if it references pds-sidecar)\n\n## What to do\nDelete the old `packages/pds-sidecar/` directory. It contains only orphaned compiled JS files from an old prototype — no source code, no package.json, no tsconfig. It's dead code that confuses anyone reading the repo.\n\n1. Delete the entire `packages/pds-sidecar/` directory\n2. Check `.gitmodules` — if it references pds-sidecar, remove that entry\n3. Check `package.json` at root — if it has any workspace references to pds-sidecar, remove them\n4. If `packages/` directory is now empty, leave it (other packages may be added later)\n\n## Don't\n- Don't delete anything outside of packages/pds-sidecar/\n- Don't modify any other package configuration","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T16:08:15.90162+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T17:09:26.094467+08:00","closed_at":"2026-02-18T17:09:26.094467+08:00","close_reason":"Superseded by new epic structure aligned with the Certified Auth architecture spec. The old epic embedded OTP logic in Scaffold; the new epics implement a standalone OTP service at auth.certified.app with same-domain cookie approach.","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-l3s.8","depends_on_id":"hypercerts-scaffold-l3s","type":"parent-child","created_at":"2026-02-18T16:08:15.907237+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-m4o","title":"Epic: Ship Email-First Auth to Production","description":"## Goal\nGet the email-first passwordless auth flow live at certified.app for the Ma Earth grants round. This is the critical path — everything else can follow.\n\n## What Option A1 Is\nOne stock (unmodified) PDS at certified.app. A separate sidecar auth service handles passwordless UX — OTP generation, email sending, code validation — and authenticates against the PDS using auto-generated passwords the user never sees. Apps use oauthClient.authorize('https://certified.app') with login_hint=email. No handle entry needed. The PDS stays vanilla and upgradeable.\n\n## What's Already Built\n- **Scaffold UI** (beads branch): /login page with email input, /api/auth/email-login route, useEmailLoginMutation hook (3 tasks completed: hypercerts-scaffold-2bf.1, 2bf.2, 2bf.3)\n- **PDS Sidecar** (beads branch): OTP service (8-digit, SHA-256 hashed, 15min expiry, 5 max attempts), rate limiter (per-email, per-IP), HMAC callback signer, mailer, auth-service Express routes (/oauth/authorize, /auth/send-code, /auth/verify-code), PDS core wrapper with OAuth metadata override + magic-callback endpoint (7 tasks completed: hypercerts-scaffold-qc3.1-7)\n- **Docker Compose** (beads branch): Caddy + PDS + sidecar stack (1 task completed: hypercerts-scaffold-0yp.1)\n- **Local dev setup** (beads branch): Startup script + .env for PDS at localhost:2583, sidecar at localhost:2584, MailHog at localhost:8025 (1 task completed: hypercerts-scaffold-mhp.1)\n\n## What's Left (this epic)\n1. Merge all completed work from beads/plan-passwordless-login to this branch\n2. Get the local E2E flow working (hypercerts-scaffold-mhp.2 is in progress but not done)\n3. Add encrypted credential storage (AES-256-GCM for auto-generated passwords)\n4. Add security headers + production error handling to sidecar\n5. Update Docker Compose for certified.app domain\n6. Create production .env template + DNS/email deliverability docs\n7. Add 'Sign in with ATProto/Bluesky' handle fallback to /login page\n8. E2E smoke test\n\n## Auth Flow (what the user sees)\n1. On Ma Earth, clicks 'Sign in with Certified'\n2. Redirected to certified.app/oauth/authorize\n3. Enters email address\n4. Receives OTP code via email\n5. Enters code\n6. Approves Ma Earth's access (OAuth consent)\n7. Redirected back to Ma Earth, logged in\n\nSign-up is identical: if email is new, account auto-created (random handle, hidden password).\n\n## Hard Constraints\n- Stock PDS only — no fork of bluesky-social/atproto\n- All passwordless logic in the sidecar, not the PDS\n- Auto-generated passwords encrypted at rest (AES-256-GCM)\n- Sign-up and sign-in visually identical (anti-enumeration)\n- Must ship within days, not weeks","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T15:42:34.248702+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:40.103073+08:00","closed_at":"2026-02-18T15:44:40.103077+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-m4o.1","title":"Merge all email-auth work from beads/plan-passwordless-login branch","description":"## Files\n- All files from beads/plan-passwordless-login that aren't on main yet\n\n## What to do\n1. Run `git log main..beads/plan-passwordless-login --oneline` to see all commits to merge\n2. Merge or cherry-pick the beads/plan-passwordless-login branch into the current branch (certified-email-auth-option-a)\n3. Resolve any conflicts\n4. Verify: `pnpm install \u0026\u0026 pnpm build` succeeds\n5. Verify: /login page exists at app/login/page.tsx\n6. Verify: /api/auth/email-login route exists\n7. Verify: packages/pds-sidecar/ has all three sub-packages (shared, auth-service, pds-core)\n8. Verify: packages/pds-sidecar/docker-compose.yml exists\n9. Verify: scripts/start-local-pds.sh (or similar) exists for local dev\n\n## Don't\n- Cherry-pick selectively — merge the whole branch to get everything\n- Modify any of the merged code in this task\n- Skip the build verification","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:42:48.145298+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:40.190543+08:00","closed_at":"2026-02-18T15:44:40.190547+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-m4o.1","depends_on_id":"hypercerts-scaffold-m4o","type":"parent-child","created_at":"2026-02-18T15:42:48.148206+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-mhp","title":"Epic: Local Test PDS with Sidecar for End-to-End OTP Flow","description":"## Goal\nSet up a local test PDS with the sidecar auth service so we can test the complete email-first passwordless login flow end-to-end on localhost. The user enters their email in the scaffold app → gets redirected to the sidecar → receives an OTP email → enters the code → gets redirected back to the scaffold with an active session.\n\n## Context\nWe have built:\n1. **Scaffold app** (Next.js at `/Users/sharfy/Code/hypercerts-scaffold`) — has a `/login` page with email input that calls `/api/auth/email-login`, which initiates ATProto OAuth with `login_hint=\u003cemail\u003e`. The scaffold runs on `http://127.0.0.1:3000`.\n2. **PDS sidecar** (at `packages/pds-sidecar/`) — contains three packages:\n   - `packages/shared/` — OTP service, rate limiter, HMAC callback signer, mailer, SQLite DB\n   - `packages/auth-service/` — Express app that serves email input + OTP verification pages\n   - `packages/pds-core/` — Wraps stock `@atproto/pds` with OAuth metadata override + magic-callback endpoint\n\nThe sidecar code is built and tests pass (56/56). But we've never run the full stack together. The current Docker Compose setup (`packages/pds-sidecar/docker-compose.yml`) is designed for production with Caddy, real DNS, and TLS — it won't work on localhost.\n\n## What We Need\nA **local development setup** that runs all three services on localhost without Docker, TLS, or real DNS:\n\n```\nScaffold (Next.js)     → http://127.0.0.1:3000\nPDS Core (ATProto PDS) → http://localhost:2583\nAuth Service (sidecar) → http://localhost:2584\nMailHog (fake SMTP)    → SMTP on :1025, Web UI on http://localhost:8025\n```\n\n### How the flow works\n1. User visits `http://127.0.0.1:3000/login`, enters email, clicks Continue\n2. Scaffold POSTs to `/api/auth/email-login` → calls `sdk.authorize('http://localhost:2583')` with `login_hint=email`\n3. SDK does PAR to PDS at `http://localhost:2583`\n4. PDS returns authorization URL → but metadata override rewrites `authorization_endpoint` to `http://localhost:2584/oauth/authorize`\n5. Browser redirects to sidecar at `http://localhost:2584/oauth/authorize?request_uri=...\u0026login_hint=email`\n6. Sidecar auto-sends OTP email via MailHog (SMTP on localhost:1025)\n7. User opens MailHog web UI at `http://localhost:8025`, copies the 8-digit code\n8. User enters code on sidecar's OTP page\n9. Sidecar verifies code, builds HMAC-signed callback URL\n10. Browser redirects to PDS at `http://localhost:2583/oauth/magic-callback?...\u0026sig=HMAC...`\n11. PDS verifies HMAC, creates account if new, issues OAuth auth code\n12. Browser redirects back to scaffold at `http://127.0.0.1:3000/api/auth/callback?code=...\u0026state=...\u0026iss=....`\n13. Scaffold exchanges code for session → user is logged in\n\n### Key Technical Challenges\n1. **ATProto PDS requires specific env vars and crypto keys** — PLC rotation key (secp256k1), JWT secret, admin password. These must be generated.\n2. **The PDS needs to reach the PLC directory** — `https://plc.directory` for DID creation. This requires internet access.\n3. **OAuth client ID for localhost** — The scaffold uses `http://localhost?scope=...` as client ID in dev mode (loopback client). The PDS must accept loopback clients.\n4. **The PDS hostname must match what the scaffold sends** — The scaffold's `NEXT_PUBLIC_PDS_URL` must point to the local PDS.\n5. **The auth service URL in the metadata override must be reachable from the browser** — It's `http://localhost:2584`.\n6. **MailHog for fake SMTP** — No real email provider needed. MailHog captures all emails and shows them in a web UI.\n7. **The `pds-core` wrapper uses PDS internal APIs** — These are accessed via `as any` casts and may not work exactly as expected. This is the riskiest part. If internal APIs don't match, we need to debug and fix.\n\n## Success Criteria\n- All three services start without errors\n- `GET http://localhost:2583/xrpc/_health` returns OK\n- `GET http://localhost:2584/health` returns `{\"status\":\"ok\"}`\n- `GET http://localhost:2583/.well-known/oauth-authorization-server` returns metadata with `authorization_endpoint` pointing to `http://localhost:2584/oauth/authorize`\n- The scaffold at `http://127.0.0.1:3000/login` can complete the full email→OTP→session flow\n- OTP emails appear in MailHog at `http://localhost:8025`","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-17T19:31:28.411132+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.684411+08:00","closed_at":"2026-02-18T15:50:27.684414+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-mhp.1","title":"Create local dev startup script and .env for PDS + sidecar + MailHog","description":"## Files\n- packages/pds-sidecar/scripts/dev-start.sh (create)\n- packages/pds-sidecar/.env.dev (create)\n- packages/pds-sidecar/scripts/generate-pds-keys.mjs (create)\n\n## What to do\nCreate a local development startup script that runs the PDS, auth service, and MailHog together on localhost without Docker or TLS. This is for testing the full email→OTP→session flow locally.\n\n### Architecture\n```\nScaffold (Next.js)     → http://127.0.0.1:3000  (started separately by the developer)\nPDS Core (ATProto PDS) → http://localhost:2583   (started by this script)\nAuth Service (sidecar) → http://localhost:2584   (started by this script)\nMailHog (fake SMTP)    → SMTP on :1025, Web UI on http://localhost:8025 (Docker)\n```\n\n### `scripts/generate-pds-keys.mjs`\nA Node.js script that generates all required crypto keys and outputs them as environment variables. It should:\n1. Generate a PLC rotation key (secp256k1 private key, 64 hex chars). Use `@noble/secp256k1` or `crypto.generateKeyPairSync('ec', { namedCurve: 'secp256k1' })` and extract the private key as hex. If those don't work, use `crypto.randomBytes(32).toString('hex')` — the PDS will validate it.\n2. Generate a JWT secret: `crypto.randomBytes(32).toString('hex')`\n3. Generate a session secret: `crypto.randomBytes(32).toString('hex')`\n4. Generate a callback secret: `crypto.randomBytes(32).toString('hex')`\n5. Generate an admin password: `crypto.randomBytes(16).toString('hex')`\n6. Print them all as KEY=VALUE lines that can be pasted into .env.dev\n\n### `.env.dev`\nPre-configured environment file for local development. All values should work out of the box EXCEPT the crypto keys (which the developer generates with the script above). Include clear comments.\n\n```env\n# PDS Core\nPDS_HOSTNAME=localhost\nPDS_PORT=2583\nPDS_DATA_DIRECTORY=./data/pds\nPDS_BLOBSTORE_DISK_LOCATION=./data/pds/blobs\nPDS_DID_PLC_URL=https://plc.directory\nPDS_ADMIN_PASSWORD=\u003cgenerated\u003e\nPDS_JWT_SECRET=\u003cgenerated\u003e\nPDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=\u003cgenerated\u003e\n\n# Auth Service\nAUTH_PORT=2584\nAUTH_DB_PATH=./data/auth/auth.sqlite\nSESSION_SECRET=\u003cgenerated\u003e\nCALLBACK_SECRET=\u003cgenerated\u003e\nPDS_URL=http://localhost:2583\nAUTH_SERVICE_URL=http://localhost:2584\n\n# SMTP (MailHog)\nSMTP_HOST=localhost\nSMTP_PORT=1025\nSMTP_SECURE=false\nSMTP_USER=\nSMTP_PASS=\nSMTP_FROM=Hypercerts Scaffold \u003cnoreply@localhost\u003e\n\n# Sidecar DB (used by PDS core)\nSIDECAR_DB_PATH=./data/pds/sidecar.sqlite\n```\n\n### `scripts/dev-start.sh`\nA bash script that:\n1. Checks prerequisites: Node.js \u003e= 20, Docker (for MailHog)\n2. Creates data directories: `./data/pds/blobs`, `./data/auth`\n3. Checks if `.env.dev` has been configured (look for `\u003cgenerated\u003e` placeholder values). If not, run `generate-pds-keys.mjs` and tell the user to paste the output into `.env.dev`.\n4. Loads `.env.dev` into the shell environment\n5. Starts MailHog via Docker: `docker run -d --name mailhog-dev -p 1025:1025 -p 8025:8025 mailhog/mailhog` (skip if already running)\n6. Builds the sidecar packages: `npm run build`\n7. Starts the PDS core in the background: `node packages/pds-core/dist/index.js \u0026`\n8. Waits for PDS health check: poll `http://localhost:2583/xrpc/_health` until it responds (max 30 seconds)\n9. Starts the auth service in the background: `node packages/auth-service/dist/index.js \u0026`\n10. Waits for auth health check: poll `http://localhost:2584/health` until it responds\n11. Prints a summary:\n    ```\n    ✅ All services running:\n       PDS:         http://localhost:2583\n       Auth:        http://localhost:2584\n       MailHog:     http://localhost:8025\n       \n    Next: Start the scaffold app:\n       cd /Users/sharfy/Code/hypercerts-scaffold\n       # Update .env.local: NEXT_PUBLIC_PDS_URL=http://localhost:2583\n       npm run dev\n       # Then visit http://127.0.0.1:3000/login\n    ```\n12. Waits for Ctrl+C, then kills both background processes and stops MailHog\n\nMake the script executable (`chmod +x`).\n\n### Important: PDS_HOSTNAME for localhost\nThe ATProto PDS uses `PDS_HOSTNAME` to determine its issuer URL. For local dev, set it to `localhost`. The PDS will serve on the port specified by `PDS_PORT` env var (which `@atproto/pds` reads from `readEnv()`). Check the PDS source — it may use `PDS_PORT` or default to 2583. If the PDS doesn't read `PDS_PORT`, you may need to set it via the config object in `packages/pds-core/src/index.ts`.\n\n### Important: PDS_PORT configuration\nThe current `packages/pds-core/src/index.ts` uses `readEnv()` + `envToCfg()` from `@atproto/pds`. Check if `PDS_PORT` is read by `readEnv()`. If not, you may need to modify `index.ts` to accept a port override. The PDS default port is 2583.\n\n### Important: AUTH_SERVICE_URL\nThe `AUTH_SERVICE_URL` env var is used by the PDS core's metadata override to rewrite `authorization_endpoint`. For local dev, it must be `http://localhost:2584` — this is the URL the **browser** will be redirected to, so it must be reachable from the developer's machine.\n\n## Don't\n- Don't modify any existing source files unless absolutely necessary (e.g., if PDS_PORT isn't configurable)\n- Don't use Docker for the PDS or auth service — run them directly with Node.js\n- Don't require real DNS or TLS\n- Don't commit actual secret values — use placeholders in .env.dev\n- Don't modify the scaffold app's .env.local (just document what needs to change)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T19:32:07.834948+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T19:55:39.722956+08:00","closed_at":"2026-02-17T19:55:39.722956+08:00","close_reason":"508a006 feat: local dev startup script and .env for PDS + sidecar + MailHog","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-mhp.1","depends_on_id":"hypercerts-scaffold-mhp","type":"parent-child","created_at":"2026-02-17T19:32:07.836725+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-mhp.2","title":"Update scaffold .env.local to point to local test PDS and verify full OTP flow","description":"## Files\n- .env.local (modify — at repo root /Users/sharfy/Code/hypercerts-scaffold/.env.local)\n\n## What to do\nAfter the local PDS + sidecar are running (from the previous task), update the scaffold's `.env.local` to point to the local PDS and test the complete end-to-end flow.\n\n### Step 1: Update .env.local\nChange `NEXT_PUBLIC_PDS_URL` from the remote PDS to the local one:\n```\nNEXT_PUBLIC_PDS_URL=http://localhost:2583\n```\nKeep all other values the same.\n\n### Step 2: Restart the scaffold\n```bash\n# Kill existing dev server if running\nlsof -ti:3000 | xargs kill -9 2\u003e/dev/null\nrm -rf .next\nnpm run dev\n```\n\n### Step 3: Test the full flow\n1. Open `http://127.0.0.1:3000/login` in a browser (or use curl to simulate)\n2. Enter an email address (e.g., `test@example.com`)\n3. The scaffold should redirect to the PDS, which should redirect to the sidecar\n4. The sidecar should send an OTP email to MailHog\n5. Check MailHog at `http://localhost:8025` for the OTP email\n6. Enter the 8-digit code on the sidecar's OTP page\n7. The sidecar should redirect back to the PDS with a signed callback\n8. The PDS should create the account and redirect back to the scaffold\n9. The scaffold should exchange the code for a session\n10. The user should be logged in\n\n### Step 4: Debug and fix any issues\nThe most likely failure points are:\n- **PDS internal API mismatches** — The `magic-callback.ts` and `account-creator.ts` use `as any` casts to access PDS internals. If the API shape doesn't match, you'll get runtime errors. Debug by reading the actual PDS source in `node_modules/@atproto/pds/` and adjusting the code.\n- **OAuth redirect URI mismatch** — The scaffold's redirect URI must match what the PDS expects. Check the error messages.\n- **CORS issues** — The sidecar may need CORS headers for cross-origin requests from the scaffold.\n- **Cookie issues** — The sidecar sets session cookies. These may not work across different localhost ports. May need `SameSite=None` or same-origin setup.\n\n### Step 5: Document what works and what doesn't\nCreate a brief summary of:\n- What worked out of the box\n- What needed fixing (and what the fix was)\n- Any remaining issues\n\n## Don't\n- Don't modify the sidecar code unless there are actual runtime errors that need fixing\n- Don't change the scaffold's auth flow logic\n- Don't commit .env.local to git (it's in .gitignore)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T19:32:31.917935+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.565009+08:00","closed_at":"2026-02-18T15:54:59.565012+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-mhp.2","depends_on_id":"hypercerts-scaffold-mhp","type":"parent-child","created_at":"2026-02-17T19:32:31.919372+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-mhp.2","depends_on_id":"hypercerts-scaffold-mhp.1","type":"blocks","created_at":"2026-02-17T19:32:31.934553+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-mk1","title":"Fix private JWK format - replace 'use' with 'key_ops'","description":"CRITICAL: Private JWK with 'use' property is causing authentication to fail completely. Error chain: ERR_CRYPTO_INVALID_JWK → ERR_JWK_INVALID → Unable to create JWT. Users cannot log in. Need to replace 'use' with valid 'key_ops' in the JWK configuration.","status":"closed","priority":0,"issue_type":"task","owner":"adam@hypercerts.org","created_at":"2026-01-29T00:00:27.640799834+13:00","created_by":"Adam Spiers","updated_at":"2026-01-29T00:05:01.57288757+13:00","closed_at":"2026-01-29T00:05:01.57288757+13:00","close_reason":"Fixed by regenerating JWK with npm run generate-jwk. The script already correctly sets key_ops and removes the deprecated use property."}
{"id":"hypercerts-scaffold-mws","title":"Epic: Sidecar Auth Service (OTP + PDS Wrapper)","description":"## Goal\nBuild a standalone sidecar auth service that runs alongside a stock @atproto/pds to provide email-first passwordless login via OTP codes. This is the core backend for Option A1.\n\n## Architecture (Option A1)\n```\nClient App (scaffold)\n  │\n  │ 1. PAR request to PDS\n  │ 8. Token exchange (stock ATProto)\n  ▼\nStock PDS (@atproto/pds, unmodified npm package)\n  │  OAuth AS metadata overridden:\n  │  authorization_endpoint → sidecar\n  │\n  │ 2. Redirect to sidecar    7. Auth code issued via HMAC-signed callback\n  ▼                            ▲\nSidecar Auth Service (Express.js)\n  GET  /oauth/authorize     ← shows email input (or auto-sends OTP if login_hint present)\n  POST /auth/send-code      ← generates OTP, sends email\n  POST /auth/verify-code    ← validates OTP, builds HMAC callback to PDS\n  │\n  │ 3-5. Sends 8-digit OTP code via email\n  ▼\nUser's inbox\n```\n\n## How It Works\n1. Client calls `sdk.authorize('https://certified.app')` with `login_hint=email`\n2. SDK does PAR to PDS → PDS returns authorization URL\n3. But the PDS's OAuth metadata has been overridden: `authorization_endpoint` points to the sidecar\n4. Browser redirects to sidecar's /oauth/authorize with the PAR request_uri + login_hint\n5. Sidecar sends OTP email, shows code entry form\n6. User enters code → sidecar verifies → builds HMAC-signed callback URL\n7. Browser redirects to PDS's /oauth/magic-callback with signed params\n8. PDS verifies HMAC, creates account if new (random handle + hidden password), issues OAuth auth code\n9. Browser redirects back to client with auth code → client exchanges for tokens\n\n## Key Design Decisions\n- **Wrap, don't fork.** @atproto/pds is an npm dependency, not modified source.\n- **HMAC-SHA256 signed callback** between sidecar and PDS to prevent account takeover.\n- **Unified sign-in/sign-up.** New emails get auto-created; existing emails get authenticated. Both look identical.\n- **Random handles.** New accounts get random handles (e.g., a3x9kf.certified.app) — no email leakage.\n- **8-digit OTP codes.** SHA-256 hashed before storage, single-use, 15-min expiry, max 5 attempts.\n- **Auto-generated passwords.** Users never see a password. Backend generates 128-char hex passwords, encrypts with AES-256-GCM, stores server-side.\n\n## Project Structure\n```\npackages/pds-sidecar/\n  package.json              ← root workspace\n  tsconfig.json\n  docker-compose.yml        ← Caddy + PDS + sidecar\n  Caddyfile\n  .env.example\n  scripts/\n    start-local.sh          ← local dev: PDS + sidecar + MailHog\n  packages/\n    shared/                 ← DB, OTP service, rate limiter, HMAC signer, mailer, credential store\n    auth-service/           ← Express app (routes, middleware, templates)\n    pds-core/               ← PDS wrapper (metadata override, magic-callback, account creator)\n```\n\n## What Exists on Main\npackages/pds-sidecar/ has compiled dist/ files from a previous prototype but NO source code, NO package.json, NO tsconfig. The dist/ files can be used as reference for the implementation but everything must be built from scratch as a proper TypeScript project.\n\n## Hard Constraints\n- Stock @atproto/pds as npm dependency — NO fork\n- All passwordless logic in the sidecar\n- Auto-generated passwords encrypted at rest (AES-256-GCM)\n- SQLite for sidecar data (OTP tokens, accounts, credentials)\n- Must work on localhost for development (no TLS required locally)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T15:45:22.366037+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.496736+08:00","closed_at":"2026-02-18T15:54:59.496738+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-mws.1","title":"Initialize sidecar monorepo with TypeScript project structure","description":"## Files\n- packages/pds-sidecar/package.json (create)\n- packages/pds-sidecar/tsconfig.json (create)\n- packages/pds-sidecar/packages/shared/package.json (create)\n- packages/pds-sidecar/packages/shared/tsconfig.json (create)\n- packages/pds-sidecar/packages/shared/src/index.ts (create)\n- packages/pds-sidecar/packages/auth-service/package.json (create)\n- packages/pds-sidecar/packages/auth-service/tsconfig.json (create)\n- packages/pds-sidecar/packages/auth-service/src/index.ts (create)\n- packages/pds-sidecar/packages/pds-core/package.json (create)\n- packages/pds-sidecar/packages/pds-core/tsconfig.json (create)\n- packages/pds-sidecar/packages/pds-core/src/index.ts (create)\n- packages/pds-sidecar/.env.example (create)\n\n## What to do\nDelete the existing orphaned dist/ files in packages/pds-sidecar/ and create a proper TypeScript monorepo from scratch.\n\n1. Remove packages/pds-sidecar/packages/*/dist/ directories and packages/pds-sidecar/data/ directory\n2. Create root package.json with pnpm workspaces pointing to packages/*\n3. Create root tsconfig.json with project references\n4. Create each sub-package with:\n   - package.json (name: @certified/shared, @certified/auth-service, @certified/pds-core)\n   - tsconfig.json extending root, outputting to dist/\n   - src/index.ts with a placeholder export\n5. Dependencies to install:\n   - shared: better-sqlite3, @types/better-sqlite3, nodemailer, @types/nodemailer, pino\n   - auth-service: express, @types/express, cookie-parser, @types/cookie-parser, @certified/shared (workspace:*)\n   - pds-core: @atproto/pds, @atproto/api, @certified/shared (workspace:*)\n   - All: typescript, vitest (devDependencies)\n6. Create .env.example listing all required env vars with comments\n7. Add build/test/dev scripts to root package.json\n8. Verify: `pnpm install \u0026\u0026 pnpm build` succeeds from packages/pds-sidecar/\n\n## Don't\n- Keep any old dist/ files — delete them all\n- Use npm or yarn — this is a pnpm workspace\n- Add any business logic yet — just project scaffolding\n- Add docker-compose yet — that's a separate task","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:45:41.340562+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.42796+08:00","closed_at":"2026-02-18T15:54:59.427962+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-mws.1","depends_on_id":"hypercerts-scaffold-mws","type":"parent-child","created_at":"2026-02-18T15:45:41.341839+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-mws.2","title":"Implement shared package: DB, OTP service, rate limiter, credential store, HMAC signer, mailer","description":"## Files\n- packages/pds-sidecar/packages/shared/src/db.ts (create)\n- packages/pds-sidecar/packages/shared/src/otp-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/rate-limiter.ts (create)\n- packages/pds-sidecar/packages/shared/src/credential-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/callback-signer.ts (create)\n- packages/pds-sidecar/packages/shared/src/mailer.ts (create)\n- packages/pds-sidecar/packages/shared/src/logger.ts (create)\n- packages/pds-sidecar/packages/shared/src/types.ts (create)\n- packages/pds-sidecar/packages/shared/src/index.ts (modify — re-export all)\n- packages/pds-sidecar/packages/shared/src/*.test.ts (create tests for each)\n\n## What to do\nImplement all shared services. Use the compiled JS files in the OLD dist/ directories as reference (they contain the exact logic from the previous prototype). The old dist/ files were deleted in the previous task, but their content is documented here.\n\n### db.ts — SQLite database setup\n- Initialize better-sqlite3 database\n- Create tables on init:\n  ```sql\n  otp_tokens (id INTEGER PK, email TEXT, token_hash TEXT, attempts INT, max_attempts INT, expires_at TEXT, used INT, created_at TEXT DEFAULT datetime('now'))\n  accounts (email TEXT PK, did TEXT UNIQUE, handle TEXT, email_verified INT DEFAULT 0, created_at TEXT, updated_at TEXT)\n  credentials (did TEXT PK, encrypted_password TEXT, iv TEXT, auth_tag TEXT, created_at TEXT, updated_at TEXT)\n  rate_limits (key TEXT, action TEXT, count INT, window_start TEXT, PRIMARY KEY(key, action))\n  ```\n\n### otp-service.ts — OTP generation and verification\n- generateOTP(email): generates 8-digit code, SHA-256 hashes it, stores hash in DB, invalidates old codes for same email, returns { code, expiresAt }. Expiry: 15 minutes. Max attempts: 5.\n- verifyOTP(email, code): hashes provided code, timing-safe compares with stored hash, increments attempts, marks used on success or max attempts. Returns { valid, error? }.\n- cleanupExpired(): deletes expired/used tokens.\n\n### rate-limiter.ts — Per-email and per-IP rate limiting\n- checkLimit(key, action, maxCount, windowMinutes): returns { allowed, retryAfterSeconds? }\n- Predefined limits: SEND_PER_EMAIL (3/15min), SEND_PER_EMAIL_HOURLY (5/60min), SEND_PER_IP (10/15min), VERIFY_PER_IP (20/15min)\n\n### credential-store.ts — AES-256-GCM encrypted password storage\n- constructor(db, encryptionKey: Buffer) — 32-byte key from CREDENTIAL_ENCRYPTION_KEY env var\n- storePassword(did, password): encrypts with AES-256-GCM (random 12-byte IV), stores ciphertext+iv+tag\n- getPassword(did): retrieves and decrypts\n- rotatePassword(did, newPassword): re-encrypts\n- deletePassword(did): removes\n\n### callback-signer.ts — HMAC-SHA256 for sidecar↔PDS communication\n- constructor(secret: string) — shared HMAC secret\n- sign(params: CallbackParams): returns hex signature\n- verify(params, signature, maxAge?): returns { valid, error? }\n- buildCallbackUrl(pdsUrl, params): builds full URL with signature\n- static parseCallbackUrl(url): extracts params + signature\n\n### mailer.ts — Email sending via SMTP\n- constructor(smtpConfig: { host, port, user, pass, from })\n- sendOTP(email, code): sends formatted OTP email with the 8-digit code\n\n### logger.ts — Pino logger setup\n\n## Don't\n- Use any encryption library other than node:crypto\n- Store plaintext passwords or OTP codes in the database\n- Use fixed IVs for encryption (must be random per encryption)\n- Skip timing-safe comparison for OTP verification\n- Skip tests — every service needs at least 3 test cases","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:46:08.819055+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.340874+08:00","closed_at":"2026-02-18T15:54:59.340876+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-mws.2","depends_on_id":"hypercerts-scaffold-mws","type":"parent-child","created_at":"2026-02-18T15:46:08.820257+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-mws.2","depends_on_id":"hypercerts-scaffold-mws.1","type":"blocks","created_at":"2026-02-18T15:46:08.821838+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-mws.3","title":"Implement auth-service Express app with OTP routes and email/code UI pages","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/app.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/index.ts (modify)\n- packages/pds-sidecar/packages/auth-service/src/session.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/templates.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/authorize.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/send-code.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/verify-code.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/security-headers.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/error-handler.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/auth.test.ts (create)\n\n## What to do\nBuild the Express auth service that serves the email input + OTP verification pages.\n\n### app.ts — Express application setup\n- Create Express app with: JSON body parser, cookie-parser, CSRF double-submit cookie, security headers middleware, error handler\n- Mount routes: authorize, send-code, verify-code\n- Health check at GET /health returning { status: 'ok' }\n\n### Routes\n\n**GET /oauth/authorize** — Entry point from PDS redirect\n- Receives query params: request_uri, client_id, login_hint (optional)\n- If login_hint is an email: auto-send OTP, show code entry page\n- If no login_hint: show email input page\n- Store request_uri + client_id in signed session cookie\n\n**POST /auth/send-code** — Send OTP email\n- Body: { email }\n- Rate limit check (per-email + per-IP)\n- Generate OTP via OTPService\n- Send email via Mailer\n- Show OTP entry page (always — even if email doesn't exist, for anti-enumeration)\n- Store email in session cookie\n\n**POST /auth/verify-code** — Verify OTP and redirect to PDS\n- Body: { code }\n- Get email from session cookie\n- Verify OTP via OTPService\n- If invalid: re-render OTP page with error\n- If valid: check if account exists in sidecar DB\n- Build HMAC-signed callback URL with: requestUri, email, approved=true, newAccount=(bool), timestamp\n- Redirect browser to PDS's /oauth/magic-callback?...\u0026sig=HMAC...\n\n### session.ts — Signed cookie session management\n- Uses HMAC-signed JSON cookies (not express-session — keep it stateless)\n- Stores: email, requestUri, clientId, csrfToken\n\n### templates.ts — Server-rendered HTML pages\n- renderEmailPage(opts): email input form with CSRF token\n- renderOTPPage(opts): 8-digit code input with masked email display, error message, resend link\n- renderErrorPage(opts): generic error page\n- All pages: minimal CSS, mobile-friendly, Certified branding (simple — just a heading + form)\n\n### Middleware\n- security-headers.ts: HSTS (prod only), CSP, X-Frame-Options: DENY, X-Content-Type-Options: nosniff, Cache-Control: no-store on auth routes\n- error-handler.ts: catches unhandled errors, logs full details via pino, returns safe error in production (no stack traces)\n\n## Don't\n- Use express-session or any session store — use signed cookies\n- Render React/JSX — use plain HTML template strings\n- Skip CSRF protection\n- Skip rate limiting on send-code\n- Expose internal error details in production responses","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:46:35.738718+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.269704+08:00","closed_at":"2026-02-18T15:54:59.269707+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-mws.3","depends_on_id":"hypercerts-scaffold-mws","type":"parent-child","created_at":"2026-02-18T15:46:35.740242+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-mws.3","depends_on_id":"hypercerts-scaffold-mws.2","type":"blocks","created_at":"2026-02-18T15:46:35.742276+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-mws.4","title":"Implement pds-core: PDS wrapper with metadata override, magic-callback, and account creator","description":"## Files\n- packages/pds-sidecar/packages/pds-core/src/index.ts (modify)\n- packages/pds-sidecar/packages/pds-core/src/metadata-override.ts (create)\n- packages/pds-sidecar/packages/pds-core/src/magic-callback.ts (create)\n- packages/pds-sidecar/packages/pds-core/src/account-creator.ts (create)\n- packages/pds-sidecar/packages/pds-core/src/pds-core.test.ts (create)\n\n## What to do\nBuild the PDS wrapper that starts a stock @atproto/pds with two additions: OAuth metadata override and a magic-callback endpoint.\n\n### index.ts — PDS startup with sidecar integration\n```typescript\n// 1. Import and configure stock @atproto/pds\n// 2. Inject metadata override middleware BEFORE PDS routes\n// 3. Add /oauth/magic-callback route\n// 4. Start PDS\n// 5. Export for use by the startup script\nexport async function startPdsCore(config: PdsCoreConfig): Promise\u003c{ pds: PDS, app: Express }\u003e\n```\n\n### metadata-override.ts — Intercept OAuth AS metadata\n- Express middleware that intercepts GET /.well-known/oauth-authorization-server\n- Collects the PDS's response (may be chunked/compressed), decompresses if needed\n- Replaces `authorization_endpoint` with the sidecar's URL (e.g., https://auth.certified.app/oauth/authorize)\n- Re-sends the modified JSON response\n- Must handle gzip, brotli, and deflate compression\n- Must be injected BEFORE PDS route handlers in the Express stack\n\n### magic-callback.ts — Handle HMAC-signed callback from sidecar\n- Express handler for GET /oauth/magic-callback\n- Steps:\n  1. Parse query params using CallbackSigner.parseCallbackUrl\n  2. Verify HMAC signature (max age 300 seconds)\n  3. If newAccount=true, create account via AccountCreator\n  4. Look up user's DID from PDS's internal account manager (pds.ctx.accountManager.getAccountByEmail)\n  5. Create/load device session via PDS's OAuthProvider.deviceManager\n  6. Load PAR request via requestManager.get(requestUri, deviceId)\n  7. Mark request as authorized via requestManager.setAuthorized()\n  8. Redirect to client via /oauth/authorize/redirect with auth code + state + iss\n\n### account-creator.ts — Create ATProto accounts for new users\n- Uses PDS internal API: pds.ctx.oauthProvider.store.createAccount({ handle, email, password, locale })\n- Generates random handle: `${randomBase36(6)}.${pdsDomain}`\n- Generates random password: crypto.randomBytes(64).toString('hex')\n- Stores email→DID mapping in sidecar DB\n- Stores encrypted password via CredentialStore\n- Retries up to 5 times on handle collision\n\n### Internal API access pattern\nThe PDS class exposes `ctx` as a public property. We access internal APIs via `as any` casts:\n- `(pds as any).ctx.oauthProvider` — OAuthProvider instance\n- `(pds as any).ctx.accountManager` — PDS AccountManager\n- `(pds as any).ctx.oauthProvider.deviceManager` — DeviceManager\n- `(pds as any).ctx.oauthProvider.requestManager` — RequestManager\n- `(pds as any).ctx.oauthProvider.clientManager` — ClientManager\nThese are tested against @atproto/pds ^0.4.0.\n\n## Don't\n- Modify @atproto/pds source code — it's an npm dependency only\n- Skip HMAC verification on magic-callback (security critical)\n- Store plaintext passwords (use CredentialStore)\n- Use a fixed handle (must be random per account)\n- Skip the metadata decompression handling (PDS may gzip the response)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:47:03.004193+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.201426+08:00","closed_at":"2026-02-18T15:54:59.201429+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-mws.4","depends_on_id":"hypercerts-scaffold-mws","type":"parent-child","created_at":"2026-02-18T15:47:03.019267+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-mws.4","depends_on_id":"hypercerts-scaffold-mws.2","type":"blocks","created_at":"2026-02-18T15:47:03.021587+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-mws.5","title":"Create local dev startup script and Docker Compose for production","description":"## Files\n- packages/pds-sidecar/scripts/start-local.sh (create)\n- packages/pds-sidecar/.env.local.example (create)\n- packages/pds-sidecar/docker-compose.yml (create)\n- packages/pds-sidecar/Caddyfile (create)\n- packages/pds-sidecar/.env.production.example (create)\n\n## What to do\n\n### Local dev script (start-local.sh)\nA bash script that starts all services for local development:\n1. Check prerequisites: node, pnpm, MailHog (or install via brew)\n2. Start MailHog in background (SMTP on :1025, web UI on :8025)\n3. Build all packages: pnpm build\n4. Start PDS core on port 2583 (with sidecar integration)\n5. Start auth service on port 2584\n6. Print URLs:\n   - Scaffold: http://127.0.0.1:3000\n   - PDS: http://localhost:2583\n   - Auth service: http://localhost:2584\n   - MailHog: http://localhost:8025\n7. Trap SIGINT to clean up background processes\n\n### .env.local.example\n```bash\nPDS_HOSTNAME=localhost\nPDS_PORT=2583\nPDS_DATA_DIRECTORY=./data\nPDS_PLC_ROTATION_KEY_K256_PRIVATE_KEY_HEX=\u003cgenerate with: openssl rand -hex 32\u003e\nPDS_JWT_SECRET=\u003cgenerate with: openssl rand -hex 32\u003e\nPDS_ADMIN_PASSWORD=local-admin-password\nPDS_EMAIL_SMTP_URL=smtp://localhost:1025\nPDS_EMAIL_FROM_ADDRESS=noreply@localhost\n\nSIDECAR_PORT=2584\nSIDECAR_SESSION_SECRET=\u003cgenerate with: openssl rand -hex 32\u003e\nHMAC_SECRET=\u003cgenerate with: openssl rand -hex 32\u003e\nCREDENTIAL_ENCRYPTION_KEY=\u003cgenerate with: openssl rand -hex 32\u003e\nAUTH_SERVICE_URL=http://localhost:2584\nPDS_INTERNAL_URL=http://localhost:2583\n\nSMTP_HOST=localhost\nSMTP_PORT=1025\nSMTP_FROM=noreply@localhost\n# No SMTP_USER/SMTP_PASS needed for MailHog\n```\n\n### Docker Compose (production)\nServices:\n- **caddy**: Caddy reverse proxy with TLS. Routes certified.app → pds:3000, auth.certified.app → auth-service:3001, *.certified.app → pds:3000\n- **pds**: Stock @atproto/pds with sidecar integration (pds-core). Port 3000 internal.\n- **auth-service**: Sidecar auth service. Port 3001 internal.\n- Shared Docker network, shared volumes for PDS data and sidecar SQLite\n\n### Caddyfile\n```\ncertified.app {\n    reverse_proxy pds:3000\n}\nauth.certified.app {\n    reverse_proxy auth-service:3001\n}\n*.certified.app {\n    reverse_proxy pds:3000\n}\n```\nUse DNS challenge for wildcard TLS (configurable provider via env var).\n\n## Don't\n- Hard-code any secrets or domain names (use env vars)\n- Require Docker for local development (script uses node directly)\n- Skip the MailHog setup in the local script\n- Forget to make start-local.sh executable (chmod +x)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:47:25.856425+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.130632+08:00","closed_at":"2026-02-18T15:54:59.130634+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-mws.5","depends_on_id":"hypercerts-scaffold-mws","type":"parent-child","created_at":"2026-02-18T15:47:25.858213+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-mws.5","depends_on_id":"hypercerts-scaffold-mws.3","type":"blocks","created_at":"2026-02-18T15:47:25.85956+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-mws.5","depends_on_id":"hypercerts-scaffold-mws.4","type":"blocks","created_at":"2026-02-18T15:47:25.860595+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-p33","title":"Epic: Organization Membership, RBAC \u0026 Repo Management","description":"## Goal\nBuild the application-layer organization system: membership management, role-based access control, and server-side repo signing for org data. This is independent of the auth flow and can be built in parallel.\n\n## Context\nATProto has NO native org support. Every repo has exactly one signing key. All org logic lives in our application layer. The architecture doc specifies:\n- Our backend maintains org membership (user_did → [org_ids])\n- Roles: admin (manage members + write + delete), contributor (write), viewer (read)\n- Org repos are DID-based PDS accounts whose signing keys we hold server-side\n- The org/RBAC layer is completely independent of how users authenticate\n\n### How Orgs Work\nEach org is a regular ATProto account on the PDS. The difference:\n- The org's signing key (password) is held by our backend, encrypted with AES-256-GCM\n- Our backend mediates all writes: User → Scaffold API → RBAC check → PDS write as org account\n- Users never directly interact with the org's PDS credentials\n\n### Data Model\n- organizations: id (UUID), did, handle, name, created_at\n- org_memberships: org_id + user_did (composite PK), role, invited_by, created_at\n\n## What Has to Be Built\n1. OrgStore — data access layer for orgs and memberships (SQLite)\n2. PdsAdminService — creates/deletes org PDS accounts, manages encrypted credentials\n3. PdsRecordService — RBAC-gated CRUD on org repos via XRPC\n4. Org API routes — REST endpoints for org management\n5. Scaffold UI — org listing page after login\n\n## Hard Constraints\n- All org data in sidecar SQLite (same DB as auth data)\n- Org PDS accounts created via com.atproto.server.createAccount (XRPC, not internal API)\n- Org credentials encrypted at rest (reuse CredentialStore from shared package)\n- Stock PDS only — no protocol changes\n- Must work with any ATProto Lexicon (hypercerts, profiles, etc.)","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-02-18T15:48:27.289644+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.840465+08:00","closed_at":"2026-02-18T15:54:59.840467+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-p33.1","title":"Implement OrgStore data layer and org API routes","description":"## Files\n- packages/pds-sidecar/packages/shared/src/org-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/org-store.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add org tables)\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.test.ts (create)\n\n## What to do\n\n### OrgStore class (shared/src/org-store.ts)\nData access layer for organizations and memberships.\n\nTypes: OrgRole = 'admin' | 'contributor' | 'viewer'\n\nMethods:\n- createOrg({ did, handle, name }): Organization\n- getOrg(id), getOrgByDid(did), getOrgByHandle(handle): Organization | null\n- updateOrg(id, { name?, handle? }): Organization\n- deleteOrg(id): void\n- addMember(orgId, userDid, role, invitedBy): OrgMembership\n- removeMember(orgId, userDid): void — cannot remove last admin\n- updateRole(orgId, userDid, newRole): void\n- getMember(orgId, userDid): OrgMembership | null\n- getMembers(orgId): OrgMembership[]\n- getUserOrgs(userDid): (Organization \u0026 { role })[]\n- canWrite(orgId, userDid): boolean — admin or contributor\n- canAdmin(orgId, userDid): boolean — admin only\n\nDB tables:\n```sql\norganizations (id TEXT PK, did TEXT UNIQUE, handle TEXT UNIQUE, name TEXT, created_at TEXT)\norg_memberships (org_id TEXT, user_did TEXT, role TEXT CHECK(IN admin/contributor/viewer), invited_by TEXT, created_at TEXT, PK(org_id, user_did))\n```\n\n### Org API routes (auth-service/src/routes/orgs.ts)\nAll routes require auth (user DID from Authorization header — simplified for now).\n\nPOST /api/orgs — create org (creator becomes admin)\nGET /api/orgs — list user's orgs\nGET /api/orgs/:orgId — get org (must be member)\nPUT /api/orgs/:orgId — update org (admin only)\nDELETE /api/orgs/:orgId — delete org (admin only)\nPOST /api/orgs/:orgId/members — add member (admin only)\nGET /api/orgs/:orgId/members — list members (must be member)\nPUT /api/orgs/:orgId/members/:did — update role (admin only)\nDELETE /api/orgs/:orgId/members/:did — remove member (admin only, can't remove last admin)\n\n## Don't\n- Create PDS accounts for orgs in this task (that's PdsAdminService)\n- Use an external UUID library (use crypto.randomUUID())\n- Allow removing the last admin from an org\n- Skip input validation on API routes","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T15:48:47.222864+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.772439+08:00","closed_at":"2026-02-18T15:54:59.772441+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-p33.1","depends_on_id":"hypercerts-scaffold-p33","type":"parent-child","created_at":"2026-02-18T15:48:47.225035+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-p33.1","depends_on_id":"hypercerts-scaffold-mws.1","type":"blocks","created_at":"2026-02-18T15:48:47.226361+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-p33.2","title":"Implement PdsAdminService and PdsRecordService for org repo management","description":"## Files\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-record-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-admin-service.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/pds-record-service.test.ts (create)\n\n## What to do\n\n### PdsAdminService — Org account lifecycle\nManages creating/deleting PDS accounts for organizations.\n\n```typescript\nclass PdsAdminService {\n  constructor(pdsUrl: string, pdsDomain: string, credentialStore: CredentialStore, orgStore: OrgStore)\n\n  async createOrgAccount(orgName: string, creatorDid: string): Promise\u003c{ orgId, did, handle }\u003e\n  // 1. Generate handle: org-{randomBase36(6)}.{pdsDomain}\n  // 2. Generate password: crypto.randomBytes(64).toString('hex')\n  // 3. Call com.atproto.server.createAccount via AtpAgent XRPC\n  //    - email: org-{uuid}@{pdsDomain} (synthetic, not real)\n  //    - handle, password from above\n  // 4. Store encrypted password via credentialStore.storePassword(did, password)\n  // 5. Create org in orgStore, add creator as admin\n  // 6. Return { orgId, did, handle }\n\n  async deleteOrgAccount(orgId: string, callerDid: string): Promise\u003cvoid\u003e\n  // 1. Verify caller is admin via orgStore.canAdmin()\n  // 2. Get org's credentials, create session\n  // 3. Call com.atproto.server.deleteAccount via XRPC\n  // 4. Delete from credentialStore and orgStore\n\n  async getOrgSession(orgId: string): Promise\u003cAtpSessionData\u003e\n  // 1. Get org DID from orgStore\n  // 2. Get decrypted password from credentialStore\n  // 3. Call com.atproto.server.createSession via XRPC\n  // 4. Return session data\n}\n```\n\n### PdsRecordService — RBAC-gated CRUD on org repos\n```typescript\nclass PdsRecordService {\n  constructor(pdsAdminService: PdsAdminService, orgStore: OrgStore)\n\n  async createRecord(orgId, callerDid, { collection, record, rkey? }): Promise\u003c{ uri, cid }\u003e\n  // Check canWrite → get org session → com.atproto.repo.createRecord\n\n  async getRecord(orgDid, collection, rkey): Promise\u003cunknown\u003e\n  // No RBAC needed (ATProto repos are public)\n\n  async putRecord(orgId, callerDid, { collection, rkey, record }): Promise\u003c{ uri, cid }\u003e\n  // Check canWrite → get org session → com.atproto.repo.putRecord\n\n  async deleteRecord(orgId, callerDid, { collection, rkey }): Promise\u003cvoid\u003e\n  // Check canAdmin (only admins delete) → get org session → com.atproto.repo.deleteRecord\n\n  async listRecords(orgDid, collection, { limit?, cursor? }): Promise\u003c{ records, cursor? }\u003e\n  // No RBAC needed\n}\n```\n\nAll XRPC calls use @atproto/api's AtpAgent, authenticated with the org's session.\n\n## Don't\n- Expose org credentials to callers\n- Skip RBAC checks on any write operation\n- Allow contributors to delete records (admin only)\n- Cache sessions indefinitely (they expire)\n- Use PDS internal APIs (use XRPC only — external API)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T15:49:09.204251+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.704454+08:00","closed_at":"2026-02-18T15:54:59.704456+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-p33.2","depends_on_id":"hypercerts-scaffold-p33","type":"parent-child","created_at":"2026-02-18T15:49:09.208196+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-p33.2","depends_on_id":"hypercerts-scaffold-p33.1","type":"blocks","created_at":"2026-02-18T15:49:09.210359+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-p33.2","depends_on_id":"hypercerts-scaffold-mws.2","type":"blocks","created_at":"2026-02-18T15:49:09.211473+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-p33.3","title":"Add org listing page and components to scaffold app","description":"## Files\n- app/orgs/page.tsx (create)\n- components/org-list.tsx (create)\n- components/org-card.tsx (create)\n- lib/api/orgs.ts (create)\n- queries/queries/use-user-orgs-query.ts (create)\n\n## What to do\nAfter login, users should be able to see their organizations. Create the org listing page.\n\n### /orgs page (app/orgs/page.tsx)\nServer component that renders the OrgList client component. Protected by SignedInProvider (requires auth).\n\n### OrgList component (components/org-list.tsx)\nClient component. Uses useUserOrgsQuery to fetch orgs from the sidecar API. Renders a responsive grid of OrgCard components. Shows empty state with 'Create Organization' CTA if no orgs.\n\n### OrgCard component (components/org-card.tsx)\nDisplays: org name, handle (e.g., maearth.certified.app), user's role as a badge (admin=red, contributor=blue, viewer=gray). Clicking navigates to /orgs/[orgId]. Uses shadcn Card + Badge.\n\n### API client (lib/api/orgs.ts)\n- getUserOrgs(): fetches GET /api/orgs from sidecar\n- getOrg(orgId): fetches GET /api/orgs/:orgId\n- createOrg(name): POSTs to /api/orgs\n\n### Query hook\nuseUserOrgsQuery wraps getUserOrgs with TanStack Query. Key: ['orgs'].\n\n### Styling\n- Responsive grid: 1 col mobile, 2 tablet, 3 desktop\n- Use existing design system: shadcn Card, Badge, Syne headings, Outfit body\n- Match the existing glassmorphism/gradient aesthetic\n\n## Don't\n- Implement org creation form (just the listing + empty state CTA)\n- Implement member management UI\n- Fetch from PDS directly — go through sidecar API\n- Break existing pages or navigation\n- Add new npm dependencies","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T15:49:27.344802+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.634635+08:00","closed_at":"2026-02-18T15:54:59.634638+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-p33.3","depends_on_id":"hypercerts-scaffold-p33","type":"parent-child","created_at":"2026-02-18T15:49:27.345935+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-p33.3","depends_on_id":"hypercerts-scaffold-p33.1","type":"blocks","created_at":"2026-02-18T15:49:27.347315+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-p5n","title":"Epic: Unified Sign-up/Sign-in Flow with Handle Assignment","description":"## Goal\nImplement a unified auth flow where sign-up and sign-in are identical from the user's perspective. User enters email → gets OTP → enters code → they're in. If the email is new, an account is auto-created. If existing, they're logged in. Handle assignment is automatic and invisible.\n\n## Context\nThe architecture doc specifies Option A1: application-layer OTP + hidden password. The pds-sidecar already has:\n- AccountCreator (packages/pds-sidecar/packages/pds-core/dist/account-creator.js) that creates accounts with random handles (6-char base36 + domain) and random passwords\n- OTP verification flow in auth-service routes\n- verify-code route that checks if account exists and builds HMAC callback\n\nWhat's MISSING:\n1. **Email→account lookup before OTP send**: The send-code route should check if the email already has an account and behave identically either way (anti-enumeration)\n2. **Handle collision detection**: randomBase36(6) could collide. Need retry logic.\n3. **Handle customization later**: Users should be able to change their handle after signup (not in this epic, but the schema should support it)\n4. **Credential storage integration**: AccountCreator generates a random password but doesn't store it encrypted via CredentialStore (from Epic: OTP Hardening)\n5. **Email verification status**: Track whether an email has been verified via OTP at least once\n\n## User Flow (detailed)\n1. User enters email on scaffold /login page\n2. Scaffold calls /api/auth/email-login with email\n3. SDK calls authorize('https://certified.app') with login_hint=email\n4. PDS returns auth URL → sidecar's /oauth/authorize\n5. Sidecar receives login_hint, auto-sends OTP email\n6. User enters 8-digit code\n7. Sidecar verifies code\n8. If new email: sidecar creates account (random handle, random encrypted password), stores credentials\n9. If existing email: sidecar looks up DID from accounts table\n10. Sidecar builds HMAC-signed callback → PDS magic-callback → OAuth code → scaffold callback → session\n\n## Hard Constraints\n- Sign-up and sign-in MUST be visually identical (anti-enumeration)\n- Handle format: `{random6}.certified.app` (or configured domain)\n- Auto-generated passwords: 128 hex chars, encrypted via CredentialStore\n- No user-visible password at any point\n- Stock PDS — account creation via com.atproto.server.createAccount or PDS internal OAuthStore.createAccount\n\n## Success Looks Like\n- New email → account created → OTP verified → session established\n- Existing email → OTP verified → session established\n- Both flows look identical to the user\n- Handle collisions are retried automatically (max 5 attempts)\n- Credentials stored encrypted","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T14:04:18.311383+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.22461+08:00","closed_at":"2026-02-18T15:44:49.224613+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-p5n.1","title":"Add handle collision retry logic to AccountCreator","description":"## Files\n- packages/pds-sidecar/packages/pds-core/src/account-creator.ts (modify)\n- packages/pds-sidecar/packages/pds-core/src/account-creator.test.ts (create)\n\n## What to do\nModify the AccountCreator.createAccount() method to retry handle generation on collision.\n\n### Current behavior (account-creator.js in dist/)\n- Generates a single random handle: `${randomBase36(6)}.${pdsDomain}`\n- If the handle already exists on the PDS, the createAccount call throws and the user gets an error\n\n### New behavior\n1. Wrap the account creation in a retry loop (max 5 attempts)\n2. On each attempt, generate a new random handle\n3. If createAccount throws with a handle-already-exists error (check for 'HandleNotAvailable' or similar ATProto error code), retry with a new handle\n4. If all 5 attempts fail, throw a clear error: 'Failed to generate unique handle after 5 attempts'\n5. Log each retry attempt via pino logger\n\n### Source code location\nThe TypeScript source for account-creator.ts should be on the beads/plan-passwordless-login branch. Check there first. If not available, recreate from the compiled dist/account-creator.js (which is readable and well-commented).\n\n## Don't\n- Change the handle format (keep randomBase36(6))\n- Increase handle length (6 chars = 2.1 billion combinations, collisions are rare)\n- Retry on non-collision errors (only retry HandleNotAvailable)\n- Add more than 5 retry attempts","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:04:32.95251+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.313671+08:00","closed_at":"2026-02-18T15:44:49.313674+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-p5n.1","depends_on_id":"hypercerts-scaffold-p5n","type":"parent-child","created_at":"2026-02-18T14:04:32.953804+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-p5n.2","title":"Integrate CredentialStore into AccountCreator for encrypted password storage","description":"## Files\n- packages/pds-sidecar/packages/pds-core/src/account-creator.ts (modify)\n- packages/pds-sidecar/packages/pds-core/src/account-creator.test.ts (modify)\n\n## What to do\nUpdate AccountCreator to use CredentialStore (from Epic: OTP Hardening) to encrypt and store auto-generated passwords.\n\n### Current behavior\nAccountCreator.createAccount() generates a random password (`crypto.randomBytes(64).toString('hex')`) and passes it to the PDS's OAuthStore.createAccount(). The password is stored in the sidecar's accounts table as plaintext (it's not stored at all currently — only the email→DID mapping is stored).\n\n### New behavior\n1. Add CredentialStore as a constructor dependency:\n   ```typescript\n   constructor(pds: any, pdsDomain: string, sidecarDb: Database, credentialStore: CredentialStore)\n   ```\n2. After successful account creation, call `credentialStore.storePassword(did, password)`\n3. Add a `getPasswordForDid(did: string): string | null` method that delegates to `credentialStore.getPassword(did)`\n4. Update tests to verify password is stored encrypted after account creation\n\n### Why this matters\nThe architecture doc identifies this as a key risk: 'We hold auto-generated passwords server-side — if our backend is compromised, all PDS accounts are exposed.' Encrypting at rest with AES-256-GCM mitigates this.\n\n## Don't\n- Store plaintext passwords anywhere\n- Change the password generation logic (keep crypto.randomBytes(64).toString('hex'))\n- Remove the existing email→DID mapping storage (keep both)\n- Make CredentialStore optional — it's required","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T14:04:47.431356+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.403943+08:00","closed_at":"2026-02-18T15:44:49.403956+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-p5n.2","depends_on_id":"hypercerts-scaffold-p5n","type":"parent-child","created_at":"2026-02-18T14:04:47.432789+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-p5n.2","depends_on_id":"hypercerts-scaffold-8mu.1","type":"blocks","created_at":"2026-02-18T14:04:47.44827+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-p5n.3","title":"Add email verification tracking to accounts table","description":"## Files\n- packages/pds-sidecar/packages/shared/src/db.ts (modify)\n- packages/pds-sidecar/packages/shared/src/account-service.ts (create)\n- packages/pds-sidecar/packages/shared/src/account-service.test.ts (create)\n\n## What to do\nCreate an AccountService that manages the email→DID mapping and tracks email verification status.\n\n### AccountService class\n```typescript\nexport class AccountService {\n  constructor(db: BetterSqlite3.Database)\n  findByEmail(email: string): { did: string, handle: string, emailVerified: boolean, createdAt: string } | null\n  findByDid(did: string): { email: string, handle: string, emailVerified: boolean, createdAt: string } | null\n  create(email: string, did: string, handle: string): void\n  markEmailVerified(email: string): void\n  isEmailVerified(email: string): boolean\n  updateHandle(did: string, newHandle: string): void\n}\n```\n\n### DB migration\nAlter the existing accounts table (or create if not exists):\n```sql\nCREATE TABLE IF NOT EXISTS accounts (\n  email TEXT PRIMARY KEY,\n  did TEXT UNIQUE NOT NULL,\n  handle TEXT NOT NULL,\n  email_verified INTEGER DEFAULT 0,\n  created_at TEXT DEFAULT (datetime('now')),\n  updated_at TEXT DEFAULT (datetime('now'))\n);\nCREATE INDEX IF NOT EXISTS idx_accounts_did ON accounts(did);\n```\n\n### Integration point\nAfter OTP verification succeeds in verify-code route, call `accountService.markEmailVerified(email)`. This is NOT done in this task — just create the service. The route integration is a separate task.\n\n## Don't\n- Delete or modify existing account records during migration\n- Make email case-sensitive (normalize to lowercase before storage)\n- Add any auth logic to AccountService (it's a data layer only)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:05:01.225752+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:49.499263+08:00","closed_at":"2026-02-18T15:44:49.499266+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-p5n.3","depends_on_id":"hypercerts-scaffold-p5n","type":"parent-child","created_at":"2026-02-18T14:05:01.227197+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-p9n","title":"Epic: Document SDK Packaging and Enhance Developer Experience","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-13T11:18:09.88485984+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:28:40.447887994+06:00","closed_at":"2026-02-13T11:28:40.447887994+06:00","close_reason":"Completed all 7 documentation tasks: created DEVELOPMENT.md, added SDK warnings, enhanced loopback docs, improved prerequisites, updated .env.example, reorganized footer, and reviewed code examples"}
{"id":"hypercerts-scaffold-p9n.1","title":"Create DEVELOPMENT.md with SDK version warnings and development guide","description":"Create a comprehensive DEVELOPMENT.md file covering: (1) Critical warning about unreleased SDK version (0.10.0-beta.8 from vendor/), (2) Explanation of packed packages and why we use them for dogfooding, (3) Warning that installing latest SDK may break scaffold, (4) Step-by-step instructions to update vendor SDK package manually, (5) Local development workflow and setup, (6) Contributing guidelines encouraging users to file issues for @kzoeps. This file serves as the technical reference for developers working with the scaffold.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T11:18:18.009152902+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:23:15.860547626+06:00","closed_at":"2026-02-13T11:23:15.860547626+06:00","close_reason":"Completed: 5ec8a6e - Created comprehensive DEVELOPMENT.md covering SDK version warnings, packed package explanation, update instructions, development workflow, troubleshooting, and contributing guidelines","dependencies":[{"issue_id":"hypercerts-scaffold-p9n.1","depends_on_id":"hypercerts-scaffold-p9n","type":"parent-child","created_at":"2026-02-13T11:18:18.010805084+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-p9n.2","title":"Add SDK version warning section to README.md","description":"Add a prominent '⚠️ Important: SDK Version \u0026 Breaking Changes' section to README.md immediately after the Quick Start section (around line 32). This section must explain: (1) Uses unreleased v0.10.0-beta.8 from vendor/, (2) Built from github.com/hypercerts-org/hypercerts-sdk not npm, (3) Purpose is dogfooding latest features, (4) Contains unreleased/unmerged changes, (5) Breaking changes expected, (6) Installing latest SDK may break scaffold, (7) Link to DEVELOPMENT.md for details, (8) Link to issues at github.com/hypercerts-org/hypercerts-scaffold-atproto with @kzoeps as maintainer. Depends on hypercerts-scaffold-p9n.1 because DEVELOPMENT.md must exist to link to it.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-13T11:18:25.62233731+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:23:59.686592067+06:00","closed_at":"2026-02-13T11:23:59.686592067+06:00","close_reason":"Completed: 1e8c516 - Added SDK version warning section to README after Quick Start with all required details","dependencies":[{"issue_id":"hypercerts-scaffold-p9n.2","depends_on_id":"hypercerts-scaffold-p9n","type":"parent-child","created_at":"2026-02-13T11:18:25.623979997+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-p9n.2","depends_on_id":"hypercerts-scaffold-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:05.137659881+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-p9n.3","title":"Enhance README loopback configuration documentation","description":"Improve the existing loopback configuration docs in README.md: (1) Make Quick Start note more prominent (line 31) - emphasize OAuth requirement for 127.0.0.1, (2) Add TL;DR to 'Localhost Redirect' section (line 127) explaining that .env.local MUST use 127.0.0.1 for OAuth to work, (3) Add troubleshooting subsection with common OAuth issues (callback failed, invalid redirect_uri, redirect loops, ngrok issues). The loopback docs are already comprehensive, this task just enhances clarity and adds troubleshooting.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-13T11:18:33.299950647+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:24:57.350432049+06:00","closed_at":"2026-02-13T11:24:57.350432049+06:00","close_reason":"Completed: 2a3277f - Enhanced loopback docs with prominent OAuth requirement, TL;DR, and troubleshooting section","dependencies":[{"issue_id":"hypercerts-scaffold-p9n.3","depends_on_id":"hypercerts-scaffold-p9n","type":"parent-child","created_at":"2026-02-13T11:18:33.30151496+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-p9n.4","title":"Improve README prerequisites and installation section","description":"Update Prerequisites section (lines 5-10) in README.md to be more detailed and helpful: (1) Specify Node.js 20+ with nvm recommendation, (2) Mention pnpm explicitly with install command, (3) Expand Redis section with both local Docker and cloud options, (4) Clarify PDS account requirement, (5) Add note referencing DEVELOPMENT.md for SDK details. Update Quick Start section to mention pnpm explicitly and add Redis check before running dev server. Depends on hypercerts-scaffold-p9n.1 because needs DEVELOPMENT.md to reference it.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-13T11:18:41.139193052+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:25:37.166639803+06:00","closed_at":"2026-02-13T11:25:37.166639803+06:00","close_reason":"Completed: e31646b - Updated prerequisites with detailed requirements and Quick Start with pnpm/Redis clarity","dependencies":[{"issue_id":"hypercerts-scaffold-p9n.4","depends_on_id":"hypercerts-scaffold-p9n","type":"parent-child","created_at":"2026-02-13T11:18:41.141044172+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-p9n.4","depends_on_id":"hypercerts-scaffold-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:05.725129883+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-p9n.5","title":"Update .env.example with SDK version reference","description":"Add a header comment block at the top of .env.example file explaining: (1) This scaffold uses unreleased packed SDK version, (2) Reference DEVELOPMENT.md for SDK details and breaking changes, (3) Reference README.md for setup instructions. This provides context for developers when they first copy the file. Depends on hypercerts-scaffold-p9n.1 because needs DEVELOPMENT.md to reference it.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-13T11:18:47.282193967+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:26:10.199986381+06:00","closed_at":"2026-02-13T11:26:10.199986381+06:00","close_reason":"Completed: 4818387 - Added header comment with SDK version warning and references to DEVELOPMENT.md","dependencies":[{"issue_id":"hypercerts-scaffold-p9n.5","depends_on_id":"hypercerts-scaffold-p9n","type":"parent-child","created_at":"2026-02-13T11:18:47.283647269+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-p9n.5","depends_on_id":"hypercerts-scaffold-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:06.370792289+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-p9n.6","title":"Add DEVELOPMENT.md link to README footer","description":"Update the 'Learn More' section (around line 242) in README.md to add DEVELOPMENT.md as the first link under a new 'Scaffold Documentation' subsection. Also add links to report issues (github.com/hypercerts-org/hypercerts-scaffold-atproto/issues) and mention @kzoeps as maintainer. Reorganize external docs links into a separate subsection. Depends on hypercerts-scaffold-p9n.1 because DEVELOPMENT.md must exist to link to it.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-13T11:18:53.526270655+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:26:50.075541431+06:00","closed_at":"2026-02-13T11:26:50.075541431+06:00","close_reason":"Completed: 9aee7d0 - Reorganized Learn More section with DEVELOPMENT.md, external docs, and issue reporting links","dependencies":[{"issue_id":"hypercerts-scaffold-p9n.6","depends_on_id":"hypercerts-scaffold-p9n","type":"parent-child","created_at":"2026-02-13T11:18:53.528019597+06:00","created_by":"kzoeps"},{"issue_id":"hypercerts-scaffold-p9n.6","depends_on_id":"hypercerts-scaffold-p9n.1","type":"blocks","created_at":"2026-02-13T11:19:06.902665893+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-p9n.7","title":"Review and update code examples in README","description":"Review all code snippets throughout README.md for accuracy with current codebase: (1) Check Authentication section code example (lines 170-187), (2) Check Repository Context section (lines 193-210), (3) Verify all imports are correct, (4) Verify function signatures match current SDK version, (5) Add helpful comments where appropriate, (6) Ensure examples follow best practices. This is a review/polish task to ensure documentation matches implementation.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-13T11:19:00.53603122+06:00","created_by":"kzoeps","updated_at":"2026-02-13T11:28:18.636827322+06:00","closed_at":"2026-02-13T11:28:18.636827322+06:00","close_reason":"Completed: 91d11f0 - Reviewed and improved all code examples, added simpler alternatives, fixed authentication flow description","dependencies":[{"issue_id":"hypercerts-scaffold-p9n.7","depends_on_id":"hypercerts-scaffold-p9n","type":"parent-child","created_at":"2026-02-13T11:19:00.537513614+06:00","created_by":"kzoeps"}]}
{"id":"hypercerts-scaffold-qc3","title":"Epic: PDS Sidecar Auth Service","description":"## Goal\nBuild a standalone Express.js auth service that runs alongside the stock `@atproto/pds` package to provide email-first passwordless login via OTP codes. This lives in `packages/pds-sidecar/` within the hypercerts-scaffold repo (same PR as the scaffold UI changes).\n\n## Context\nATProto's PDS has a built-in OAuth authorization server with a password-based sign-in form. We want to replace this with email + OTP for the Certified ecosystem (Ma Earth, GainForest, etc.). The PDS is ~80% ready for email OTP — the `emailOtp` field exists in the sign-in schema, `SecondAuthenticationFactorRequiredError` is implemented, email token infrastructure is production-ready, and password is already optional at the AccountManager level. The blocker is a hard `throw new Error('Email OTP is not supported')` in `OAuthStore.authenticateAccount()`.\n\nRather than forking the PDS, we build a **sidecar auth service** that:\n1. Overrides the PDS's OAuth authorization server metadata (`/.well-known/oauth-authorization-server`) to redirect the `authorization_endpoint` to itself\n2. Serves its own email input + OTP verification pages\n3. After OTP verification, calls into the PDS's internal `OAuthProvider` APIs to create accounts (if new) and issue OAuth authorization codes\n4. Redirects the user back to the client app with a standard OAuth code\n\nFrom the client app's perspective, this is a normal OAuth flow. The client doesn't know the sidecar exists.\n\n## Location\nAll sidecar code lives under `packages/pds-sidecar/` in the hypercerts-scaffold repo. This is a monorepo with three sub-packages:\n- `packages/pds-sidecar/packages/shared/` — DB, OTP service, rate limiter, HMAC signer, mailer\n- `packages/pds-sidecar/packages/auth-service/` — Express auth service\n- `packages/pds-sidecar/packages/pds-core/` — PDS wrapper\n\n## Architecture\n```\nClient App (scaffold)\n  │\n  │ 1. PAR request\n  │ 8. Token exchange (stock ATProto)\n  ▼\nPDS Core (stock @atproto/pds, unmodified npm package)\n  │  AS metadata overridden:\n  │  authorization_endpoint → auth.pds.certs.network\n  │\n  │ 2. Redirect to sidecar    7. Auth code issued via signed callback\n  ▼                            ▲\nSidecar Auth Service (Express)\n  GET  /oauth/authorize     ← email input form\n  POST /auth/send-code      ← generate OTP, send email\n  POST /auth/verify-code    ← validate OTP\n  GET  /auth/consent        ← consent screen\n  │\n  │ 3-5. Email 6-digit OTP code\n  ▼\nUser's inbox\n```\n\n## Key Design Decisions\n1. **Wrap, don't fork.** `@atproto/pds` is an npm dependency, not modified source.\n2. **Signed callback.** HMAC-SHA256 between sidecar and PDS to prevent account takeover.\n3. **Unified sign-in/sign-up.** New emails get an account auto-created; existing emails get authenticated.\n4. **`login_hint` passthrough.** Client passes email as `login_hint` → sidecar sends OTP immediately.\n5. **Random handles.** New accounts get random handles to avoid leaking emails.\n6. **8-digit OTP codes.** Better brute-force resistance.\n\n## Security Requirements\n- HMAC-SHA256 signed callback between sidecar and PDS\n- OTP codes: 8 digits, SHA-256 hashed before storage, single-use, 15-min expiry, max 5 attempts\n- Rate limiting: per-email (3/15min, 5/hr), per-IP (10/15min)\n- Anti-enumeration: show OTP form regardless of whether email exists\n- CSRF protection: double-submit cookie with timing-safe comparison\n- Security headers: HSTS, CSP, X-Frame-Options, X-Content-Type-Options\n\n## Success Criteria\n- Sidecar starts alongside stock PDS, overrides AS metadata\n- Email OTP flow works end-to-end\n- New accounts auto-created with random handles\n- Callback between sidecar and PDS is HMAC-signed\n- Rate limiting and anti-enumeration in place","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-17T18:12:07.512977+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:50:27.496331+08:00","closed_at":"2026-02-18T15:50:27.496334+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-qc3.1","title":"Initialize sidecar repo with monorepo structure","description":"## Files\n- packages/pds-sidecar/package.json (create)\n- packages/pds-sidecar/tsconfig.json (create)\n- packages/pds-sidecar/packages/shared/package.json (create)\n- packages/pds-sidecar/packages/shared/src/index.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (create)\n- packages/pds-sidecar/packages/shared/src/types.ts (create)\n- packages/pds-sidecar/packages/shared/src/logger.ts (create)\n- packages/pds-sidecar/packages/auth-service/package.json (create)\n- packages/pds-sidecar/packages/auth-service/src/index.ts (create)\n- packages/pds-sidecar/packages/pds-core/package.json (create)\n- packages/pds-sidecar/packages/pds-core/src/index.ts (create)\n- packages/pds-sidecar/.gitignore (create)\n- packages/pds-sidecar/README.md (create)\n\n## What to do\nCreate the PDS sidecar monorepo structure under `packages/pds-sidecar/` in the hypercerts-scaffold repo. This directory contains three sub-packages using npm workspaces.\n\n### Root `packages/pds-sidecar/package.json`\n- Name: `@certified/pds-sidecar`\n- Private: true\n- Workspaces: `['packages/*']`\n- Scripts: `dev`, `build`, `test`, `lint`\n- Engine: Node.js \u003e= 20\n\n### `packages/pds-sidecar/packages/shared`\nShared utilities used by both auth-service and pds-core:\n- **`db.ts`**: Initialize better-sqlite3 database. Export a `createDatabase(path: string)` function that creates the SQLite file and returns a Database instance. Create tables on init:\n  - `accounts`: `id INTEGER PRIMARY KEY, email TEXT UNIQUE NOT NULL, did TEXT UNIQUE, handle TEXT, created_at TEXT DEFAULT CURRENT_TIMESTAMP`\n  - `otp_tokens`: `id INTEGER PRIMARY KEY, email TEXT NOT NULL, token_hash TEXT NOT NULL, attempts INTEGER DEFAULT 0, max_attempts INTEGER DEFAULT 5, expires_at TEXT NOT NULL, used INTEGER DEFAULT 0, created_at TEXT DEFAULT CURRENT_TIMESTAMP`\n  - `rate_limits`: `id INTEGER PRIMARY KEY, key TEXT NOT NULL, action TEXT NOT NULL, count INTEGER DEFAULT 1, window_start TEXT NOT NULL`\n- **`types.ts`**: Shared TypeScript types (`Account`, `OTPToken`, `RateLimitEntry`)\n- **`logger.ts`**: Pino logger instance with pretty-print in dev\n\n### `packages/pds-sidecar/packages/auth-service`\nThe Express auth service (skeleton only in this task):\n- `src/index.ts`: Create Express app, add JSON body parser, add a health check route `GET /health` that returns `{ status: 'ok' }`. Listen on `process.env.AUTH_PORT || 3001`.\n- Dependencies: express, cors, cookie-parser\n\n### `packages/pds-sidecar/packages/pds-core`\nThe PDS wrapper (skeleton only in this task):\n- `src/index.ts`: Import `@atproto/pds` and create a minimal PDS startup script. For now, just log 'PDS core starting...' and export a placeholder `startPDS()` function.\n- Dependencies: @atproto/pds\n\n### TypeScript config\n- Root `tsconfig.json` with project references\n- Each package has its own `tsconfig.json` extending root\n- Target: ES2022, module: Node16, strict: true\n\n### IMPORTANT: Do not modify the root scaffold package.json\nThe sidecar has its own independent package.json and node_modules. Run `npm install` from within `packages/pds-sidecar/`, not from the repo root.\n\n## Don't\n- Don't modify any files outside `packages/pds-sidecar/`\n- Don't implement any auth logic (that's later tasks)\n- Don't implement the OAuth metadata override (that's later)\n- Don't set up Docker yet (that's the deployment epic)\n- Don't install nodemailer yet (that's the OTP task)\n- Don't modify the root package.json or any scaffold files","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:13:53.671557+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:38:19.085359+08:00","closed_at":"2026-02-17T18:38:19.085359+08:00","close_reason":"4a06158 Initialize pds-sidecar monorepo with shared, auth-service, pds-core packages","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-qc3.1","depends_on_id":"hypercerts-scaffold-qc3","type":"parent-child","created_at":"2026-02-17T18:13:53.672463+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-qc3.2","title":"Implement OTP generation, hashing, and verification service","description":"## Files\n- packages/shared/src/otp-service.ts (create)\n- packages/shared/src/otp-service.test.ts (create)\n\n## What to do\nImplement the OTP token service in the shared package. This handles generating, storing (hashed), and verifying one-time passcodes.\n\n### `otp-service.ts`\n\nExport a class `OTPService` that takes a Database instance (from `db.ts`) in its constructor.\n\n**Methods:**\n\n#### `async generateOTP(email: string): Promise\u003c{ code: string; expiresAt: Date }\u003e`\n1. Generate an 8-digit random numeric code using `crypto.randomInt(10000000, 99999999)`\n2. Hash the code with SHA-256: `crypto.createHash('sha256').update(code).digest('hex')`\n3. Calculate expiry: `new Date(Date.now() + 15 * 60 * 1000)` (15 minutes)\n4. Mark any existing unused tokens for this email as used (prevent token accumulation)\n5. Insert into `otp_tokens` table: `{ email, token_hash, attempts: 0, max_attempts: 5, expires_at, used: 0 }`\n6. Return `{ code, expiresAt }` (the plaintext code — caller sends it via email)\n\n#### `async verifyOTP(email: string, code: string): Promise\u003c{ valid: boolean; error?: string }\u003e`\n1. Hash the provided code with SHA-256\n2. Find the most recent unused, non-expired token for this email: `SELECT * FROM otp_tokens WHERE email = ? AND used = 0 AND expires_at \u003e datetime('now') ORDER BY created_at DESC LIMIT 1`\n3. If no token found: return `{ valid: false, error: 'No valid code found. Please request a new one.' }`\n4. Increment the `attempts` counter on the token\n5. If `attempts \u003e= max_attempts`: mark token as used, return `{ valid: false, error: 'Too many attempts. Please request a new code.' }`\n6. Compare hashes using `crypto.timingSafeEqual(Buffer.from(storedHash, 'hex'), Buffer.from(providedHash, 'hex'))`\n7. If match: mark token as used, return `{ valid: true }`\n8. If no match: return `{ valid: false, error: 'Invalid code. Please try again.' }`\n\n#### `async cleanupExpired(): Promise\u003cnumber\u003e`\nDelete all tokens where `expires_at \u003c datetime('now')` or `used = 1`. Return count of deleted rows. This should be called periodically (e.g., every 5 minutes via setInterval).\n\n### Test file: `otp-service.test.ts`\nWrite vitest tests covering:\n1. `generateOTP` returns an 8-digit numeric string\n2. `verifyOTP` succeeds with correct code\n3. `verifyOTP` fails with wrong code\n4. `verifyOTP` fails after code expires (mock time or use short expiry)\n5. `verifyOTP` fails after max attempts exceeded\n6. `verifyOTP` fails when no token exists\n7. Generating a new OTP invalidates the previous one for the same email\n8. `cleanupExpired` removes old tokens\n9. Timing-safe comparison is used (verify by checking the code path, not timing)\n\nUse an in-memory SQLite database for tests (`createDatabase(':memory:')`).\n\n## Don't\n- Don't implement rate limiting here (that's a separate service)\n- Don't implement email sending here (that's a separate task)\n- Don't store plaintext codes in the database\n- Don't use Math.random() — use crypto.randomInt() for cryptographic randomness","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:14:15.505739+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:40:13.952341+08:00","closed_at":"2026-02-17T18:40:13.952341+08:00","close_reason":"00d3e19 Implement OTP generation, hashing, and verification service","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-qc3.2","depends_on_id":"hypercerts-scaffold-qc3","type":"parent-child","created_at":"2026-02-17T18:14:15.506563+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.2","depends_on_id":"hypercerts-scaffold-qc3.1","type":"blocks","created_at":"2026-02-17T18:14:15.507565+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-qc3.3","title":"Implement rate limiting service","description":"## Files\n- packages/shared/src/rate-limiter.ts (create)\n- packages/shared/src/rate-limiter.test.ts (create)\n\n## What to do\nImplement a rate limiting service that enforces per-email and per-IP limits for OTP requests. Uses the `rate_limits` table from the shared database.\n\n### `rate-limiter.ts`\n\nExport a class `RateLimiter` that takes a Database instance in its constructor.\n\n**Methods:**\n\n#### `async checkLimit(key: string, action: string, maxCount: number, windowMinutes: number): Promise\u003c{ allowed: boolean; retryAfterSeconds?: number }\u003e`\n1. Calculate window start: `new Date(Date.now() - windowMinutes * 60 * 1000)`\n2. Query: `SELECT SUM(count) as total FROM rate_limits WHERE key = ? AND action = ? AND window_start \u003e ?`\n3. If `total \u003e= maxCount`: return `{ allowed: false, retryAfterSeconds: \u003cseconds until oldest entry in window expires\u003e }`\n4. Otherwise: insert or update the rate limit entry for the current minute window, return `{ allowed: true }`\n\n#### `async recordAction(key: string, action: string): Promise\u003cvoid\u003e`\nInsert a new rate limit entry or increment the count for the current minute window.\n\n#### `async cleanupOld(): Promise\u003cnumber\u003e`\nDelete entries older than 1 hour. Return count deleted.\n\n### Predefined limit configurations (export as constants):\n\n```typescript\nexport const RATE_LIMITS = {\n  OTP_PER_EMAIL: { action: 'otp_send', maxCount: 5, windowMinutes: 60 },\n  OTP_PER_EMAIL_BURST: { action: 'otp_send', maxCount: 3, windowMinutes: 15 },\n  OTP_PER_IP: { action: 'otp_send_ip', maxCount: 10, windowMinutes: 15 },\n  VERIFY_PER_IP: { action: 'otp_verify_ip', maxCount: 20, windowMinutes: 15 },\n} as const;\n```\n\n### Express middleware factory (export):\n```typescript\nexport function rateLimitMiddleware(\n  rateLimiter: RateLimiter,\n  keyExtractor: (req: Request) =\u003e string,\n  config: { action: string; maxCount: number; windowMinutes: number }\n): RequestHandler\n```\n- Extract key from request using `keyExtractor`\n- Call `checkLimit`\n- If not allowed: respond with 429 and `Retry-After` header\n- If allowed: call `recordAction` and `next()`\n\n### Tests\n1. Allows requests under the limit\n2. Blocks requests over the limit\n3. Returns correct `retryAfterSeconds`\n4. Different keys are tracked independently\n5. Different actions are tracked independently\n6. Cleanup removes old entries\n7. Middleware returns 429 when rate limited\n\nUse in-memory SQLite for tests.\n\n## Don't\n- Don't use in-memory-only rate limiting (must survive process restart via SQLite)\n- Don't implement Redis-based rate limiting (SQLite is sufficient for single-server)\n- Don't add Express as a dependency to the shared package — the middleware factory should accept generic types or be in a separate file that auth-service imports","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:14:34.643111+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:40:20.358772+08:00","closed_at":"2026-02-17T18:40:20.358772+08:00","close_reason":"614da36 Implement rate limiting service","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-qc3.3","depends_on_id":"hypercerts-scaffold-qc3","type":"parent-child","created_at":"2026-02-17T18:14:34.644336+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.3","depends_on_id":"hypercerts-scaffold-qc3.1","type":"blocks","created_at":"2026-02-17T18:14:34.645479+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-qc3.4","title":"Implement HMAC-signed callback between sidecar and PDS","description":"## Files\n- packages/shared/src/callback-signer.ts (create)\n- packages/shared/src/callback-signer.test.ts (create)\n\n## What to do\nImplement the cryptographic signing and verification for the callback between the sidecar auth service and the PDS. This is the **critical security fix** over the magic-pds reference implementation, which uses unsigned callbacks (enabling account takeover).\n\n### Background\nAfter the sidecar verifies a user's OTP, it needs to tell the PDS 'this user is authenticated, issue an auth code.' In magic-pds, this is done via a plain redirect with query parameters (`?email=user@example.com\u0026approved=1`). Anyone who can reach the PDS's callback endpoint can forge this. Our implementation signs the callback with HMAC-SHA256 using a shared secret.\n\n### `callback-signer.ts`\n\nExport a class `CallbackSigner` that takes a `secret: string` in its constructor.\n\n**Methods:**\n\n#### `sign(params: CallbackParams): string`\n```typescript\ninterface CallbackParams {\n  requestUri: string;   // The PAR request URI (urn:ietf:params:oauth:request_uri:...)\n  email: string;        // The authenticated user's email\n  approved: boolean;    // Whether the user approved the request\n  newAccount: boolean;  // Whether this is a new account creation\n  timestamp: number;    // Unix timestamp in seconds (Date.now() / 1000)\n}\n```\n1. Serialize params deterministically: `${requestUri}|${email}|${approved}|${newAccount}|${timestamp}`\n2. Compute HMAC-SHA256: `crypto.createHmac('sha256', this.secret).update(serialized).digest('hex')`\n3. Return the hex signature\n\n#### `verify(params: CallbackParams, signature: string, maxAgeSeconds: number = 300): { valid: boolean; error?: string }`\n1. Check timestamp is within `maxAgeSeconds` of current time (prevents replay attacks). Return `{ valid: false, error: 'Callback expired' }` if too old.\n2. Recompute the expected signature using `sign(params)`\n3. Compare using `crypto.timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expected, 'hex'))`\n4. Return `{ valid: true }` or `{ valid: false, error: 'Invalid signature' }`\n\n#### `buildCallbackUrl(baseUrl: string, params: CallbackParams): string`\nBuild the full callback URL with all params as query parameters plus the signature:\n```\n{baseUrl}/oauth/magic-callback?request_uri={requestUri}\u0026email={email}\u0026approved={approved}\u0026new_account={newAccount}\u0026timestamp={timestamp}\u0026sig={signature}\n```\n\n#### `static parseCallbackUrl(url: URL): { params: CallbackParams; signature: string }`\nParse query parameters back into `CallbackParams` and extract the signature.\n\n### Tests\n1. `sign` produces a consistent signature for the same inputs\n2. `sign` produces different signatures for different inputs\n3. `verify` succeeds with a valid signature\n4. `verify` fails with a tampered email\n5. `verify` fails with a tampered approved flag\n6. `verify` fails with a wrong secret\n7. `verify` fails when timestamp is too old (expired)\n8. `verify` fails when timestamp is in the future (clock skew \u003e maxAge)\n9. `buildCallbackUrl` produces a valid URL with all params\n10. `parseCallbackUrl` round-trips with `buildCallbackUrl`\n11. Timing-safe comparison is used\n\n## Don't\n- Don't use JWT for this (HMAC is simpler and sufficient for server-to-server within the same deployment)\n- Don't use asymmetric keys (shared secret is fine since both services are co-deployed)\n- Don't hardcode the secret — it's passed to the constructor","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:14:57.2573+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:39:54.935494+08:00","closed_at":"2026-02-17T18:39:54.935494+08:00","close_reason":"ca63038 Implement HMAC-signed callback signer with 11 tests","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-qc3.4","depends_on_id":"hypercerts-scaffold-qc3","type":"parent-child","created_at":"2026-02-17T18:14:57.258125+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.4","depends_on_id":"hypercerts-scaffold-qc3.1","type":"blocks","created_at":"2026-02-17T18:14:57.259258+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-qc3.5","title":"Implement OTP email sending service","description":"## Files\n- packages/shared/src/mailer.ts (create)\n- packages/shared/src/mailer.test.ts (create)\n\n## What to do\nImplement the email sending service for OTP codes. Uses nodemailer with SMTP transport.\n\n### `mailer.ts`\n\nExport a class `Mailer` with constructor:\n```typescript\nconstructor(config: {\n  host: string;\n  port: number;\n  secure: boolean;\n  auth: { user: string; pass: string };\n  from: string;  // e.g., 'Hypercerts \u003cnoreply@certified.app\u003e'\n})\n```\n\n**Methods:**\n\n#### `async sendOTP(to: string, code: string, options?: { appName?: string }): Promise\u003cvoid\u003e`\nSend an email with the OTP code. The email should be:\n- **Subject:** `Your sign-in code: ${code}` (include code in subject for quick access on mobile)\n- **From:** The configured `from` address\n- **HTML body:** Clean, minimal HTML email:\n  - App name heading (defaults to 'Hypercerts Scaffold')\n  - 'Your sign-in code is:' text\n  - The 8-digit code displayed large and monospaced (easy to read/copy)\n  - 'This code expires in 15 minutes.' subtext\n  - 'If you didn't request this code, you can safely ignore this email.' footer\n- **Text body:** Plain text fallback with the same content\n\n#### `async verifyConnection(): Promise\u003cboolean\u003e`\nCall `transporter.verify()` to check SMTP connectivity. Return true/false. Log errors but don't throw.\n\n### Test file\n- Mock nodemailer's `createTransport` to capture sent emails\n- Test that `sendOTP` calls `sendMail` with correct to, from, subject, html, text\n- Test that the code appears in both HTML and text bodies\n- Test that `verifyConnection` returns false when SMTP is unreachable\n- Test custom `appName` appears in the email\n\n## Don't\n- Don't implement custom email templates per OAuth client (that's a future enhancement)\n- Don't implement email template fetching from URLs (SSRF risk — magic-pds had this issue)\n- Don't send emails in tests — mock the transport","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:15:14.469648+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:40:31.949481+08:00","closed_at":"2026-02-17T18:40:31.949481+08:00","close_reason":"d5ae3b7 Implement OTP email sending service","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-qc3.5","depends_on_id":"hypercerts-scaffold-qc3","type":"parent-child","created_at":"2026-02-17T18:15:14.470511+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.5","depends_on_id":"hypercerts-scaffold-qc3.1","type":"blocks","created_at":"2026-02-17T18:15:14.471624+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-qc3.6","title":"Implement auth service routes: send-code, verify-code, authorize","description":"## Files\n- packages/auth-service/src/routes/authorize.ts (create)\n- packages/auth-service/src/routes/send-code.ts (create)\n- packages/auth-service/src/routes/verify-code.ts (create)\n- packages/auth-service/src/middleware/security.ts (create)\n- packages/auth-service/src/middleware/csrf.ts (create)\n- packages/auth-service/src/index.ts (modify)\n\n## What to do\nImplement the three core auth service routes that handle the email OTP flow. These are the routes that the user's browser interacts with after being redirected from the PDS.\n\n### Flow overview\n1. PDS redirects user to sidecar: `GET /oauth/authorize?request_uri=urn:...\u0026client_id=...\u0026login_hint=user@example.com`\n2. Sidecar shows email form (or auto-sends OTP if `login_hint` is present)\n3. User submits email → `POST /auth/send-code` → sidecar sends OTP email\n4. User enters code → `POST /auth/verify-code` → sidecar verifies OTP\n5. On success: sidecar builds HMAC-signed callback URL and redirects to PDS\n\n### `middleware/security.ts`\nAdd security headers to all responses:\n- `Strict-Transport-Security: max-age=31536000; includeSubDomains`\n- `X-Content-Type-Options: nosniff`\n- `X-Frame-Options: DENY`\n- `Content-Security-Policy: default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:`\n\n### `middleware/csrf.ts`\nImplement double-submit cookie CSRF protection:\n- On GET requests: generate a random CSRF token, set it as a cookie (`csrf-token`, HttpOnly=false so JS can read it, Secure in production, SameSite=Lax`)\n- On POST requests: compare the `csrf-token` cookie with the `x-csrf-token` header using `crypto.timingSafeEqual`\n- Reject with 403 if they don't match\n\n### `routes/authorize.ts` — `GET /oauth/authorize`\nThis is the entry point — the PDS redirects here after PAR.\n\n**Query params:** `request_uri`, `client_id`, `login_hint` (optional)\n\n**Logic:**\n1. Validate `request_uri` is present (required)\n2. Store `request_uri` and `client_id` in a session cookie (encrypted or signed) so they survive the send-code/verify-code round-trip\n3. If `login_hint` is present and looks like an email (contains `@`):\n   - Auto-trigger OTP send (call OTPService.generateOTP + Mailer.sendOTP)\n   - Render the OTP verification page directly (skip email input)\n4. If no `login_hint` or it's not an email:\n   - Render the email input page\n\n**Pages:** Server-rendered HTML (use a simple template function, no React needed):\n- Email input page: form with email input, 'Continue' button\n- OTP verification page: form with 8-digit code input, 'Verify' button, 'Resend code' link, masked email display (e.g., 'u***@example.com')\n\n### `routes/send-code.ts` — `POST /auth/send-code`\n**Body:** `{ email: string }`\n\n**Logic:**\n1. Validate CSRF token\n2. Check rate limits (per-email burst + hourly, per-IP)\n3. Normalize email (lowercase, trim)\n4. Generate OTP via OTPService\n5. Send OTP via Mailer\n6. **Anti-enumeration:** Always respond with success, even if the email doesn't exist in the system. The OTP is generated regardless — if the email is new, the account will be created after verification.\n7. Store email in session cookie for the verify step\n8. Respond with redirect to OTP verification page (or JSON `{ success: true }` if called via fetch)\n\n### `routes/verify-code.ts` — `POST /auth/verify-code`\n**Body:** `{ code: string }`\n\n**Logic:**\n1. Validate CSRF token\n2. Check rate limits (per-IP verify limit)\n3. Retrieve email from session cookie\n4. Verify OTP via OTPService\n5. If invalid: re-render OTP page with error message\n6. If valid:\n   a. Check if email exists in the accounts table\n   b. If new email: set `newAccount = true`\n   c. Build HMAC-signed callback URL using CallbackSigner\n   d. Redirect to PDS callback: `{pdsUrl}/oauth/magic-callback?request_uri=...\u0026email=...\u0026approved=1\u0026new_account=...\u0026timestamp=...\u0026sig=...`\n\n### Session cookies\nUse a signed cookie (using the HMAC secret) to store the OAuth flow state across requests:\n```typescript\ninterface AuthFlowSession {\n  requestUri: string;\n  clientId: string;\n  email?: string;\n}\n```\nSign with HMAC-SHA256 using the same shared secret. Set HttpOnly, Secure (in production), SameSite=Lax, Max-Age=600 (10 minutes).\n\n## Don't\n- Don't use React or any frontend framework for the HTML pages — use template literals\n- Don't implement the PDS-side callback handler (that's a separate task in pds-core)\n- Don't implement consent screens (that's a future task)\n- Don't fetch OAuth client metadata for branding (future enhancement)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:15:49.998905+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:46:19.914818+08:00","closed_at":"2026-02-17T18:46:19.914818+08:00","close_reason":"5bdd18a Implement auth service routes: send-code, verify-code, authorize","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-qc3.6","depends_on_id":"hypercerts-scaffold-qc3","type":"parent-child","created_at":"2026-02-17T18:15:50.001457+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.6","depends_on_id":"hypercerts-scaffold-qc3.2","type":"blocks","created_at":"2026-02-17T18:15:50.003149+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.6","depends_on_id":"hypercerts-scaffold-qc3.3","type":"blocks","created_at":"2026-02-17T18:15:50.00393+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.6","depends_on_id":"hypercerts-scaffold-qc3.4","type":"blocks","created_at":"2026-02-17T18:15:50.004741+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.6","depends_on_id":"hypercerts-scaffold-qc3.5","type":"blocks","created_at":"2026-02-17T18:15:50.005499+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-qc3.7","title":"Implement PDS core wrapper with OAuth metadata override and magic-callback endpoint","description":"## Files\n- packages/pds-core/src/index.ts (modify)\n- packages/pds-core/src/metadata-override.ts (create)\n- packages/pds-core/src/magic-callback.ts (create)\n- packages/pds-core/src/account-creator.ts (create)\n\n## What to do\nImplement the PDS wrapper that starts a stock `@atproto/pds` instance with two additions: (1) an Express middleware that overrides the OAuth authorization server metadata to point to the sidecar, and (2) a `/oauth/magic-callback` endpoint that accepts HMAC-signed callbacks from the sidecar and issues OAuth authorization codes.\n\n### Background\nThe stock PDS serves `GET /.well-known/oauth-authorization-server` which returns metadata including `authorization_endpoint` pointing to itself. We intercept this and rewrite `authorization_endpoint` to point to the sidecar auth service. All other OAuth endpoints (PAR, token, JWKS) remain on the PDS.\n\nAfter the sidecar verifies the user's OTP, it redirects the user's browser to `/oauth/magic-callback` on the PDS with HMAC-signed parameters. The PDS verifies the signature, then uses its internal `OAuthProvider` to issue an authorization code and redirect the user back to the client app.\n\n### `metadata-override.ts`\nExport a function `createMetadataOverride(authServiceUrl: string): RequestHandler` that:\n1. Intercepts `GET /.well-known/oauth-authorization-server`\n2. Calls `next()` to let the stock PDS generate the response\n3. Captures the response body (use response interception — override `res.json` or use a response-capture middleware pattern)\n4. Replaces `authorization_endpoint` with `${authServiceUrl}/oauth/authorize`\n5. Sends the modified response\n\n**Important:** This middleware must be mounted BEFORE the PDS middleware in the Express stack so it can intercept the response.\n\n### `magic-callback.ts`\nExport a function `createMagicCallback(pds: PDS, callbackSigner: CallbackSigner): RequestHandler` that handles `GET /oauth/magic-callback`:\n\n1. Parse query parameters using `CallbackSigner.parseCallbackUrl`\n2. Verify the HMAC signature using `callbackSigner.verify()`\n3. If invalid: return 403 with error\n4. If `approved !== true`: return 403 'Request not approved'\n5. If `newAccount === true`:\n   - Call `accountCreator.createAccount(email)` to create a new ATProto account\n6. Look up the user's DID from the email (query the sidecar's accounts table or the PDS's internal account manager)\n7. Use the PDS's internal `OAuthProvider` to:\n   a. Load the pending PAR request using `requestUri`\n   b. Create or load a device session for the user\n   c. Mark the request as authorized for the user's DID\n   d. Generate an authorization code\n   e. Build the redirect URL back to the client app\n8. Redirect the user's browser to the client app with the authorization code\n\n**Accessing PDS internals:** The PDS instance exposes `pds.ctx.oauthProvider` (accessed via `as any` cast since it's not part of the public API). Key internal APIs:\n- `pds.ctx.oauthProvider.deviceManager` — manage device sessions\n- `pds.ctx.oauthProvider.requestManager` — load PAR requests\n- `pds.ctx.accountManager` — look up accounts by email\n\n**Note:** These are internal APIs that may change between `@atproto/pds` versions. Document each access point with a comment noting the PDS version it was tested against.\n\n### `account-creator.ts`\nExport a class `AccountCreator` that creates new ATProto accounts on the PDS:\n\n```typescript\nasync createAccount(email: string): Promise\u003c{ did: string; handle: string }\u003e\n```\n\n1. Generate a random handle: `${randomBase36(6)}.${pdsDomain}` (e.g., `a3x9kf.pds.certs.network`)\n2. Generate a random throwaway password: `crypto.randomBytes(64).toString('hex')`\n3. Call the PDS's internal account creation (via `pds.ctx.accountManager` or the XRPC endpoint `com.atproto.server.createAccount`)\n4. Store the email→DID mapping in the sidecar's accounts table\n5. Return `{ did, handle }`\n\n### `index.ts` — PDS startup\n1. Import and configure `@atproto/pds`\n2. Create the PDS instance with environment-based config\n3. Mount the metadata override middleware BEFORE PDS middleware\n4. Mount the magic-callback endpoint\n5. Start the server\n\n**Environment variables needed:**\n- `PDS_HOSTNAME` — e.g., `pds.certs.network`\n- `PDS_DATA_DIRECTORY` — path to PDS data\n- `PDS_BLOBSTORE_DISK_LOCATION` — blob storage path\n- `PDS_DID_PLC_URL` — PLC directory URL\n- `PDS_ADMIN_PASSWORD` — PDS admin password\n- `AUTH_SERVICE_URL` — sidecar URL (e.g., `https://auth.pds.certs.network`)\n- `CALLBACK_SECRET` — shared HMAC secret for signed callbacks\n\n## Don't\n- Don't fork or modify `@atproto/pds` source code — use it as a dependency\n- Don't implement the auth service routes (those are in the auth-service package)\n- Don't implement email sending (that's in the auth-service via shared mailer)\n- Don't disable stock login endpoints yet (that's a separate hardening task)\n- Don't implement consent screens","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T18:16:25.5113+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:45:14.654387+08:00","closed_at":"2026-02-17T18:45:14.654387+08:00","close_reason":"79a6915 Implement PDS core wrapper with OAuth metadata override and magic-callback endpoint","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-qc3.7","depends_on_id":"hypercerts-scaffold-qc3","type":"parent-child","created_at":"2026-02-17T18:16:25.512781+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-qc3.7","depends_on_id":"hypercerts-scaffold-qc3.4","type":"blocks","created_at":"2026-02-17T18:16:25.514074+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-r25","title":"Configure allowedDevOrigins in next.config for ngrok","description":"Next.js detected cross-origin request from ngrok domain to /_next/* resources. Future versions will require explicit configuration of allowedDevOrigins. See: https://nextjs.org/docs/app/api-reference/config/next-config-js/allowedDevOrigins","status":"open","priority":2,"issue_type":"task","owner":"adam@hypercerts.org","created_at":"2026-01-29T00:00:24.942442259+13:00","created_by":"Adam Spiers","updated_at":"2026-01-29T00:00:24.942442259+13:00"}
{"id":"hypercerts-scaffold-ril","title":"Fix: vitest missing from auth-service devDependencies (from hypercerts-scaffold-qc3.6)","description":"Review of hypercerts-scaffold-qc3.6 found: auth-service/package.json has a 'test': 'vitest run' script and auth.test.ts uses vitest, but vitest is not listed in devDependencies. The test suite will fail to run in CI or a fresh install because vitest is only available transitively via @certified/shared. Evidence: packages/auth-service/package.json devDependencies has no vitest entry; packages/shared/package.json has vitest ^1.4.0 in devDependencies. Fix: add vitest to auth-service devDependencies.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-17T18:52:56.283264+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.66292+08:00","closed_at":"2026-02-17T18:56:11.662923+08:00","dependencies":[{"issue_id":"hypercerts-scaffold-ril","depends_on_id":"hypercerts-scaffold-qc3.6","type":"discovered-from","created_at":"2026-02-17T18:52:56.366227+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-rw1","title":"Epic: OAuth \u0026 PDS Integration (Reverse Proxy)","description":"## Goal\nWire together the OTP service, PDS, and Scaffold so the full OAuth flow works end-to-end using a reverse proxy approach.\n\n## Architecture (Reverse Proxy Approach)\nThe OTP service sits in front of the PDS as a reverse proxy at certified.app. The PDS runs internally (e.g., localhost:2583). From the browser's perspective, everything happens on certified.app — same origin.\n\n### Why Reverse Proxy (not cross-subdomain cookies)\nResearch confirmed that the PDS DeviceManager sets cookies scoped to the exact hostname/path — not configurable for a parent domain. Cross-subdomain cookie sharing is not feasible with a stock PDS. The reverse proxy approach solves this by making the OTP service and PDS share the same origin naturally.\n\n### Traffic Routing\n```\nBrowser → certified.app (OTP service / reverse proxy)\n              │\n              ├── GET /oauth/authorize     → INTERCEPTED: OTP service shows email/OTP UI\n              ├── POST /api/v1/sign-in     → INTERCEPTED: OTP service authenticates with stored password\n              ├── POST /oauth/par          → Proxied to PDS\n              ├── POST /oauth/token        → Proxied to PDS\n              ├── GET /.well-known/*       → Proxied to PDS\n              ├── GET /xrpc/*              → Proxied to PDS\n              └── everything else          → Proxied to PDS\n```\n\n### End-to-End Flow\n1. App (Scaffold) sends PAR to certified.app/oauth/par → proxied to PDS → gets request_uri\n2. App redirects user to certified.app/oauth/authorize?request_uri=...\n3. OTP service INTERCEPTS /oauth/authorize → shows email/OTP UI (instead of PDS login form)\n4. User enters email → OTP sent → user enters code → verified\n5. For new users: OTP service calls PDS createAccount XRPC (server-to-server via PDS_INTERNAL_URL)\n6. OTP service calls PDS /api/v1/sign-in internally (same-origin through proxy, with stored password)\n7. PDS sets device session cookie on certified.app (naturally, since it is same origin)\n8. OTP service redirects to /oauth/authorize — PDS now sees authenticated session → shows consent only\n9. User approves → PDS redirects to app callback with authorization code\n10. App BFF exchanges code for DPoP-bound tokens\n\n### Key Benefits\n- No PDS source code modifications\n- No cross-domain cookie issues — everything is same-origin\n- PDS sign-in API same-origin checks pass naturally\n- User never sees a password form — seamless email → OTP → consent flow\n\n## Reference\nSee docs/certified-implementation-spec.md","status":"open","priority":1,"issue_type":"epic","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:10:18.629006+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:00:20.802636+08:00"}
{"id":"hypercerts-scaffold-rw1.1","title":"Research PDS DeviceManager cookie format and cross-subdomain behavior","description":"## What to Do\nResearch and document exactly how the PDS DeviceManager sets device session cookies, and whether they can be shared across subdomains.\n\n### Background\nThe PDS uses a DeviceManager (from @atproto/oauth-provider) that creates httpOnly cookies to track device sessions. When a user authenticates on the PDS, the DeviceManager sets a cookie that identifies the device. On subsequent visits to /oauth/authorize, the PDS checks this cookie to see if the user is already authenticated.\n\nOur plan: The OTP service (auth.certified.app) authenticates the user via OTP, then needs the PDS (pds.certified.app) to recognize the user as authenticated. If both services share the .certified.app domain, cookies set on .certified.app should be readable by both.\n\n### Research Questions\n1. What cookie name does the PDS DeviceManager use? (e.g., 'device_id', 'oauth_device', etc.)\n2. What domain is the cookie set on? (the PDS hostname, or configurable?)\n3. Is the cookie domain configurable in the PDS DeviceManager?\n4. What is the cookie value format? (opaque ID, signed JWT, etc.)\n5. How does the DeviceManager create a new device session? (what data is stored server-side?)\n6. Can the OTP service create a compatible device session cookie that the PDS will accept?\n7. Does the PDS validate the device session cookie's origin (would it reject a cookie set by a different subdomain)?\n\n### Where to Look\n- @atproto/oauth-provider source: src/device/device-manager.ts\n- @atproto/oauth-provider source: src/device/device-store.ts  \n- PDS source: packages/pds/src/context.ts (OAuthProvider initialization)\n- PDS source: packages/pds/src/auth-routes.ts (cookie usage)\n- https://github.com/bluesky-social/atproto/tree/main/packages/oauth/oauth-provider/src/device/\n\n### Output\nWrite a technical document (in the task notes or a markdown file) with:\n1. Exact cookie format and configuration\n2. Whether cross-subdomain cookie sharing is feasible\n3. If feasible: exact steps to set a compatible cookie from the OTP service\n4. If not feasible: alternative approaches (reverse proxy, iframe, etc.)\n5. Any PDS configuration changes needed\n\n### Don't\n- Don't modify PDS source code\n- Don't build anything yet — this is pure research\n- Don't assume the cookie format — read the actual source code\n\n## Acceptance Criteria\n1. Cookie name, format, and domain documented\n2. Cross-subdomain feasibility assessed with evidence from source code\n3. If feasible: exact implementation plan documented\n4. If not feasible: alternative approaches documented with pros/cons\n5. Findings are recorded in task notes or a reference document","status":"closed","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:14:45.431318+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:02:01.655884+08:00","closed_at":"2026-02-18T18:02:01.655884+08:00","close_reason":"Resolved: PDS DeviceManager cookies are scoped to the exact hostname/path and are not configurable for a parent domain. Cross-subdomain cookie sharing between auth.certified.app and pds.certified.app is not feasible with a stock PDS. Decision: use reverse proxy approach instead — OTP service sits in front of PDS at certified.app, making everything same-origin so the PDS device cookie is set naturally without any cross-domain issues.","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-rw1.1","depends_on_id":"hypercerts-scaffold-rw1","type":"parent-child","created_at":"2026-02-18T17:14:45.433323+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-rw1.2","title":"Implement reverse proxy layer in OTP service","description":"## What to Do\nBuild the reverse proxy layer in the OTP service that sits in front of the PDS. The proxy intercepts specific OAuth routes to inject the OTP login flow, and forwards everything else to the PDS backend (PDS_INTERNAL_URL) transparently.\n\n### Background\nThe PDS runs internally (e.g., localhost:2583). The OTP service is the public-facing server at certified.app. All browser traffic hits the OTP service first. Most requests are proxied to the PDS unchanged. A few key routes are intercepted to replace the PDS login form with the OTP email flow.\n\n### Routes to Intercept\n\n#### GET /oauth/authorize\nThe OTP service checks for a PDS device session cookie on the incoming request:\n- **Cookie present**: proxy the request to PDS — PDS sees authenticated user, shows consent screen\n- **No cookie**: show the OTP login UI (implemented in 08v.9)\n\nAfter OTP verification succeeds the OTP service:\n1. Calls PDS /api/v1/sign-in server-side via PDS_INTERNAL_URL with stored credentials\n2. Captures the Set-Cookie headers from the PDS response\n3. Forwards those cookies to the browser\n4. Redirects the browser back to /oauth/authorize\n5. On the second visit the cookie is present → proxied to PDS → consent screen\n\n### Routes to Proxy (everything else)\nAll other routes are forwarded to PDS_INTERNAL_URL unchanged:\n- POST /oauth/par — PAR requests from app BFFs\n- POST /oauth/token — token exchange\n- GET /.well-known/* — OAuth metadata, DID documents\n- GET/POST /xrpc/* — all XRPC API calls\n- Static assets served by PDS\n- POST /api/v1/consent — consent submission\n- Everything else\n\n### Implementation\n\n#### src/proxy/proxy.ts\n- Use http-proxy-middleware (or Hono built-in proxy)\n- Target: PDS_INTERNAL_URL env var (e.g., http://localhost:2583)\n- Forward all headers; set Host to the PDS internal hostname\n- Add X-Forwarded-For and X-Forwarded-Proto: https headers\n- Handle WebSocket upgrade for XRPC subscriptions\n\n#### src/proxy/intercepts.ts\n- Export a function that checks whether a request should be intercepted or proxied\n- Intercepted: GET /oauth/authorize (when no device session cookie)\n- Proxied: everything else\n\n#### Device session cookie detection\n- Inspect the incoming Cookie header for the PDS device session cookie name\n- The cookie name used by @atproto/oauth-provider DeviceManager must be confirmed from the PDS source (likely 'session' or 'device_id' — check packages/oauth/oauth-provider/src/device/device-manager.ts)\n\n### Configuration\n- PDS_INTERNAL_URL: internal PDS address (e.g., http://localhost:2583)\n\n### Don't\n- Don't modify PDS source code\n- Don't strip or alter PDS security headers (CSP, CORS, etc.)\n- Don't buffer large request/response bodies — stream them\n- Don't expose PDS_INTERNAL_URL to the browser\n- Don't break WebSocket connections for XRPC subscriptions\n\n## Acceptance Criteria\n1. All non-intercepted routes are proxied to PDS_INTERNAL_URL transparently\n2. GET /oauth/authorize is intercepted and shows OTP UI when no device session cookie exists\n3. GET /oauth/authorize is proxied to PDS when device session cookie is present\n4. After OTP verification, PDS /api/v1/sign-in is called and device cookie forwarded to browser\n5. PDS consent screen appears after OTP verification (not the login form)\n6. PAR, token exchange, XRPC, and .well-known routes work through the proxy\n7. Headers (X-Forwarded-For, X-Forwarded-Proto) are correctly set\n8. No PDS source code modifications","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:14:53.477127+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:02:23.642307+08:00","labels":["scope:medium"],"dependencies":[{"issue_id":"hypercerts-scaffold-rw1.2","depends_on_id":"hypercerts-scaffold-rw1","type":"parent-child","created_at":"2026-02-18T17:14:53.478492+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-rw1.2","depends_on_id":"hypercerts-scaffold-08v.9","type":"blocks","created_at":"2026-02-18T18:04:25.216914+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-rw1.3","title":"Configure PDS behind reverse proxy for Scaffold OAuth","description":"## What to Do\nConfigure the stock PDS to run correctly behind the OTP service reverse proxy, and ensure Scaffold is properly registered as an OAuth client against certified.app.\n\n### PDS Configuration (behind proxy)\nThe PDS runs on an internal address (e.g., localhost:2583 or an internal Docker network hostname). The OTP service reverse proxy is the public-facing server at certified.app.\n\nKey PDS config:\n1. **PDS_HOSTNAME / SERVICE_HOSTNAME**: Set to 'certified.app' (the public-facing domain, NOT the internal address). The PDS uses this to construct URLs in OAuth metadata, DID documents, handle resolution, etc.\n2. **PDS_PORT**: Internal port (e.g., 2583). Not exposed publicly.\n3. **Trusted Client** (optional): Configure Scaffold as a trusted/first-party client to potentially skip the consent screen. Check PDS config for PDS_OAUTH_TRUSTED_CLIENTS or similar env var.\n4. **SMTP**: Verify PDS has its own SMTP configured for PDS-level email verification (separate from OTP service SMTP).\n\n### Scaffold Side\n1. Set NEXT_PUBLIC_PDS_URL=https://certified.app — the public-facing reverse proxy URL\n2. Verify client-metadata.json includes correct:\n   - client_id (URL where client-metadata.json is hosted, e.g., https://scaffold.app/client-metadata.json)\n   - redirect_uris (e.g., https://scaffold.app/api/auth/callback)\n   - scope\n   - grant_types\n   - dpop_bound_access_tokens: true\n   - token_endpoint_auth_method\n3. Verify JWKS endpoint serves valid keys\n4. Test PAR request against certified.app (proxied to PDS)\n\n### Verification Steps\n1. curl https://certified.app/.well-known/oauth-authorization-server returns valid OAuth metadata with issuer: https://certified.app\n2. curl https://certified.app/.well-known/oauth-protected-resource returns valid resource metadata\n3. PAR request from Scaffold succeeds and returns a request_uri\n4. Scaffold's client-metadata.json is fetchable by the PDS (the PDS fetches it during PAR to validate the client)\n\n### Don't\n- Don't expose the PDS internal port to the public internet\n- Don't set PDS_HOSTNAME to the internal address — it must be certified.app\n- Don't modify PDS source code\n- Don't hardcode values that should be configurable\n\n## Acceptance Criteria\n1. PDS is accessible only through the reverse proxy at certified.app\n2. PDS_HOSTNAME is set to certified.app\n3. OAuth metadata endpoints return correct URLs (certified.app, not internal address)\n4. Scaffold's client-metadata.json is fetchable from the PDS\n5. PAR request to certified.app succeeds with Scaffold's client_id\n6. JWKS endpoint is verified\n7. Redirect URI matches between client-metadata.json and actual callback\n8. All configuration is documented","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:15:00.434331+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:02:39.906573+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-rw1.3","depends_on_id":"hypercerts-scaffold-rw1","type":"parent-child","created_at":"2026-02-18T17:15:00.435509+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-rw1.3","depends_on_id":"hypercerts-scaffold-y4y.1","type":"blocks","created_at":"2026-02-18T17:16:43.803939+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-rw1.4","title":"End-to-end flow testing and debugging","description":"## What to Do\nTest the complete auth flow end-to-end and fix any issues discovered.\n\n### Full Flow to Test\n1. User visits Scaffold, clicks 'Sign in'\n2. Scaffold BFF sends PAR to certified.app → proxied to PDS → gets request_uri\n3. Scaffold redirects user to certified.app/oauth/authorize?request_uri=...\u0026client_id=...\n4. OTP service (reverse proxy) intercepts /oauth/authorize → shows email input\n5. User enters email → OTP sent to email\n6. User enters OTP code → verified\n7. OTP service calls PDS /api/v1/sign-in server-side (same-origin through proxy) with stored credentials\n8. PDS device session cookie set on certified.app and forwarded to browser\n9. OTP service redirects to /oauth/authorize → PDS sees authenticated session → shows consent screen\n10. User approves → PDS redirects to Scaffold callback\n11. Scaffold BFF exchanges authorization code for DPoP-bound tokens\n12. User is logged into Scaffold with a valid session\n\n### Edge Cases to Test\n- New user (first time, account creation on PDS + stored in OTP service DB)\n- Returning user (existing account — device session cookie present → skips OTP, goes straight to consent)\n- Wrong OTP code (3 attempts then lockout)\n- Expired OTP code\n- Rate limiting (5+ OTP requests per email per hour)\n- User with existing ATProto handle (signs in via 'Use an ATProto handle instead' link — passes through to PDS login form)\n- Multiple apps using the same Certified account (each gets independent OAuth tokens)\n- Session expiry and re-authentication\n- Network errors during PDS communication\n- Invalid/expired request_uri\n- Proxy passthrough correctness for non-intercepted routes (XRPC, .well-known, PAR, token)\n\n### Local Development Setup\n- OTP service (reverse proxy) running locally on port 3000 with PDS_INTERNAL_URL=http://localhost:2583\n- PDS running locally on port 2583 (internal only, not accessed directly by browser)\n- Scaffold running locally\n- Document the local setup steps in README\n\n### Don't\n- Don't skip error case testing\n- Don't test only the happy path\n- Don't leave undocumented workarounds\n\n## Acceptance Criteria\n1. Full flow works end-to-end for new users (account created on PDS, stored in OTP DB)\n2. Full flow works for returning users (device session cookie → straight to consent)\n3. Error cases handled gracefully\n4. Edge cases documented\n5. Local development setup documented\n6. Any bugs found filed as separate issues","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:15:06.964544+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:02:54.177463+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-rw1.4","depends_on_id":"hypercerts-scaffold-rw1","type":"parent-child","created_at":"2026-02-18T17:15:06.966187+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-rw1.4","depends_on_id":"hypercerts-scaffold-rw1.2","type":"blocks","created_at":"2026-02-18T17:16:43.873441+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-rw1.4","depends_on_id":"hypercerts-scaffold-rw1.3","type":"blocks","created_at":"2026-02-18T17:16:43.940775+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-rw1.4","depends_on_id":"hypercerts-scaffold-aou.1","type":"blocks","created_at":"2026-02-18T17:16:44.007072+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-rw1.4","depends_on_id":"hypercerts-scaffold-08v.9","type":"blocks","created_at":"2026-02-18T17:16:44.071956+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-rw1.5","title":"Handle PDS password desync (email change recovery)","description":"## What to Do\nHandle the case where a user changes their email or password directly on the PDS (bypassing the OTP service), causing the OTP service's stored credentials to become stale.\n\n### Risk\nFrom the architecture doc: 'If a user changes their email directly on the PDS (bypassing the OTP service), the email → DID mapping goes stale.'\n\nThis can also happen with passwords — if a user uses the PDS directly to change their password, the OTP service's stored encrypted password becomes invalid.\n\n### Detection\nWhen the OTP service tries to create a PDS session (com.atproto.server.createSession) with the stored password and it fails with 'Invalid identifier or password':\n- The password was changed on the PDS\n- The OTP service can no longer authenticate this user\n\n### Recovery Options\n\n#### Option 1: Password Reset (recommended)\n1. Detect createSession failure\n2. Generate a new random password\n3. Use the PDS's password reset flow:\n   - Call com.atproto.server.requestPasswordReset (sends email to user)\n   - User clicks the reset link in the PDS email\n   - Call com.atproto.server.resetPassword with the new password\n4. Update the stored encrypted password\nProblem: This requires the user to interact with a PDS-sent email, which breaks the seamless flow.\n\n#### Option 2: Admin Password Reset\n- Use PDS admin endpoints to force-reset the password\n- Requires admin credentials\n- Simpler but requires elevated access\n\n#### Option 3: Graceful Failure\n1. Detect createSession failure\n2. Show user a message: 'Your account credentials have changed. Please contact support.'\n3. Log the event for admin investigation\n4. Provide a way for admins to manually resync\n\n### Implementation\nFor v1, implement Option 3 (graceful failure) with logging:\n1. In auth-orchestrator.ts, wrap createPdsSession in error handling\n2. If createSession fails with auth error:\n   - Log warning with DID (not password)\n   - Return a clear error to the user\n   - Don't delete the account record (admin may need to investigate)\n3. Add a notes field to the accounts table for admin annotations\n4. Document the recovery process for admins\n\n### Don't\n- Don't silently ignore auth failures\n- Don't delete the user's account record on auth failure\n- Don't expose PDS error details to the user\n- Don't try to auto-recover without user consent\n\n## Acceptance Criteria\n1. Auth failures from stale credentials are detected and logged\n2. User sees a clear, non-technical error message\n3. Admin can identify and investigate stale credential cases\n4. Recovery process is documented\n5. Account record is preserved for admin investigation","status":"open","priority":2,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:15:14.515008+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T17:15:14.515008+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-rw1.5","depends_on_id":"hypercerts-scaffold-rw1","type":"parent-child","created_at":"2026-02-18T17:15:14.516425+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-rw1.5","depends_on_id":"hypercerts-scaffold-08v.7","type":"blocks","created_at":"2026-02-18T17:16:44.136914+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-tam","title":"Fix: login_hint appended with \u0026 but authorize URL may already lack query params (from hypercerts-scaffold-2bf.3)","description":"Review of hypercerts-scaffold-2bf.3 found: app/api/auth/email-login/route.ts line 25 appends login_hint with a bare '\u0026': `${baseAuthUrl}\u0026login_hint=...`. If sdk.authorize(pdsUrl) returns a URL that has no existing query parameters (e.g. 'https://pds.example.com/oauth/authorize'), the result would be 'https://pds.example.com/oauth/authorize\u0026login_hint=...' which is malformed. The correct approach is to use URL/URLSearchParams to append the parameter safely. Evidence: route.ts line 25: const authUrl = `${baseAuthUrl}\u0026login_hint=${encodeURIComponent(email)}`. Fix: parse baseAuthUrl as a URL object, use url.searchParams.set('login_hint', email), then return url.toString().","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-02-17T18:53:17.066412+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.9052+08:00","closed_at":"2026-02-17T18:56:11.905203+08:00","dependencies":[{"issue_id":"hypercerts-scaffold-tam","depends_on_id":"hypercerts-scaffold-2bf.3","type":"discovered-from","created_at":"2026-02-17T18:53:17.242534+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-xi5","title":"Fix: magic-callback redirects to /oauth/authorize/redirect but this endpoint may not exist on stock PDS (from hypercerts-scaffold-qc3.7)","description":"Review of hypercerts-scaffold-qc3.7 found: magic-callback.ts lines 138-153 builds a redirect to `${issuer}/oauth/authorize/redirect` with code, redirect_uri, redirect_mode, state, and iss as query params. However, the stock @atproto/pds does not expose a public /oauth/authorize/redirect endpoint that accepts these parameters externally — the authorization code redirect is normally handled internally by the OAuthProvider after setAuthorized(). The correct flow after calling requestManager.setAuthorized() is to use the returned code and build the redirect to the client's redirect_uri directly (not via an intermediate PDS endpoint). This may cause a 404 or incorrect redirect in production. Evidence: magic-callback.ts lines 138-153; @atproto/pds OAuth flow internals. This needs verification against the actual @atproto/pds ^0.4.0 source to confirm whether /oauth/authorize/redirect is a real endpoint.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-17T18:53:44.449732+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:27.258457+08:00","closed_at":"2026-02-17T18:56:27.258464+08:00","dependencies":[{"issue_id":"hypercerts-scaffold-xi5","depends_on_id":"hypercerts-scaffold-qc3.7","type":"discovered-from","created_at":"2026-02-17T18:53:44.562288+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-xpo","title":"Epic: Organization Membership \u0026 RBAC Backend","description":"## Goal\nBuild the application-layer organization membership and role-based access control (RBAC) system. Users belong to organizations with roles (admin, contributor, viewer) that control who can write to org repos.\n\n## Context\nATProto has NO native org support — no multi-signature repos, no RBAC, no org identity, no delegation tokens. Every repo has exactly one signing key. All org logic must live in our application layer.\n\nThe architecture doc specifies:\n- Our backend maintains org membership (user_did → [org_ids])\n- Roles: admin, contributor, viewer\n- Org repos are DID-based accounts whose signing keys we hold server-side\n- The org/RBAC layer is completely independent of how users authenticate\n\nThis is a parallel workstream to the auth work. It does NOT depend on the OTP/sidecar being complete.\n\n### How Orgs Work in ATProto\nEach org is a regular ATProto account (has a DID, a handle, a repo). The difference:\n- The org's signing key is held by our backend (not by any individual user)\n- Our backend mediates all writes to the org's repo\n- Users don't directly interact with the org's PDS account — they go through our API\n\n### Data Model\n```\norganizations\n  id: UUID\n  did: TEXT (the org's ATProto DID)\n  handle: TEXT (e.g., maearth.certified.app)\n  name: TEXT\n  created_at: TIMESTAMP\n\norg_memberships\n  org_id: UUID (FK → organizations.id)\n  user_did: TEXT (the user's ATProto DID)\n  role: TEXT (admin | contributor | viewer)\n  invited_by: TEXT (DID of inviter)\n  created_at: TIMESTAMP\n  PRIMARY KEY (org_id, user_did)\n```\n\n## Hard Constraints\n- All org data lives in our application DB (SQLite for now, Postgres later)\n- Org repos are real ATProto accounts on the same PDS\n- Org signing keys are held server-side (encrypted, like user passwords)\n- No ATProto protocol changes — pure application layer\n- Must work with the existing PDS sidecar architecture\n\n## Success Looks Like\n- CRUD API for organizations\n- Membership management (invite, remove, change role)\n- Role-based permission checks on all org operations\n- Org accounts created on the PDS with server-held signing keys\n- Users can see all orgs they belong to after login","status":"closed","priority":2,"issue_type":"epic","created_at":"2026-02-18T14:07:37.261395+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.407706+08:00","closed_at":"2026-02-18T15:44:50.40771+08:00","labels":["scope:medium"]}
{"id":"hypercerts-scaffold-xpo.1","title":"Create org and membership database schema and data access layer","description":"## Files\n- packages/pds-sidecar/packages/shared/src/org-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/org-store.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add org tables)\n\n## What to do\nCreate the database schema and data access layer for organizations and memberships.\n\n### OrgStore class\n```typescript\nexport type OrgRole = 'admin' | 'contributor' | 'viewer'\n\nexport interface Organization {\n  id: string  // UUID\n  did: string\n  handle: string\n  name: string\n  createdAt: string\n}\n\nexport interface OrgMembership {\n  orgId: string\n  userDid: string\n  role: OrgRole\n  invitedBy: string\n  createdAt: string\n}\n\nexport class OrgStore {\n  constructor(db: BetterSqlite3.Database)\n\n  // Organization CRUD\n  createOrg(org: { did: string, handle: string, name: string }): Organization\n  getOrg(id: string): Organization | null\n  getOrgByDid(did: string): Organization | null\n  getOrgByHandle(handle: string): Organization | null\n  updateOrg(id: string, updates: { name?: string, handle?: string }): Organization\n  deleteOrg(id: string): void\n\n  // Membership management\n  addMember(orgId: string, userDid: string, role: OrgRole, invitedBy: string): OrgMembership\n  removeMember(orgId: string, userDid: string): void\n  updateRole(orgId: string, userDid: string, newRole: OrgRole): void\n  getMember(orgId: string, userDid: string): OrgMembership | null\n  getMembers(orgId: string): OrgMembership[]\n  getUserOrgs(userDid: string): (Organization \u0026 { role: OrgRole })[]\n\n  // Permission checks\n  hasRole(orgId: string, userDid: string, requiredRole: OrgRole): boolean\n  canWrite(orgId: string, userDid: string): boolean  // admin or contributor\n  canAdmin(orgId: string, userDid: string): boolean   // admin only\n}\n```\n\n### DB tables\n```sql\nCREATE TABLE IF NOT EXISTS organizations (\n  id TEXT PRIMARY KEY,\n  did TEXT UNIQUE NOT NULL,\n  handle TEXT UNIQUE NOT NULL,\n  name TEXT NOT NULL,\n  created_at TEXT DEFAULT (datetime('now'))\n);\n\nCREATE TABLE IF NOT EXISTS org_memberships (\n  org_id TEXT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n  user_did TEXT NOT NULL,\n  role TEXT NOT NULL CHECK(role IN ('admin', 'contributor', 'viewer')),\n  invited_by TEXT NOT NULL,\n  created_at TEXT DEFAULT (datetime('now')),\n  PRIMARY KEY (org_id, user_did)\n);\nCREATE INDEX IF NOT EXISTS idx_memberships_user ON org_memberships(user_did);\n```\n\n### Role hierarchy\n- admin: can manage members, change roles, delete org, write to org repo\n- contributor: can write to org repo\n- viewer: can read org repo (read is public in ATProto, so this is mainly for UI filtering)\n\n### UUID generation\nUse crypto.randomUUID() (Node.js built-in).\n\n## Don't\n- Add API routes (that's a separate task)\n- Add PDS account creation logic (that's the org repo management epic)\n- Use an external UUID library\n- Make role checks case-sensitive (normalize to lowercase)","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:07:55.666996+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.519682+08:00","closed_at":"2026-02-18T15:44:50.519685+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-xpo.1","depends_on_id":"hypercerts-scaffold-xpo","type":"parent-child","created_at":"2026-02-18T14:07:55.668333+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-xpo.2","title":"Create org management API routes (CRUD + membership)","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/auth-middleware.ts (create)\n\n## What to do\nCreate Express API routes for organization management, protected by user authentication.\n\n### Auth Middleware\nCreate middleware that extracts the user's DID from the request. In the Certified architecture, the user is authenticated via ATProto OAuth — the scaffold backend has their session. For org API calls, the scaffold backend includes the user's DID in a signed header or JWT.\n\nFor now, use a simple approach:\n```typescript\n// Middleware that extracts user DID from Authorization header\n// Format: Bearer \u003cuser_did\u003e (simplified for internal service-to-service calls)\n// In production, this should verify a JWT signed by the scaffold backend\nexport function requireAuth(): RequestHandler\n```\n\n### API Routes\n```\nPOST   /api/orgs                    — Create org (requires auth, creator becomes admin)\nGET    /api/orgs                    — List user's orgs (requires auth, returns orgs for user's DID)\nGET    /api/orgs/:orgId             — Get org details (requires auth, must be member)\nPUT    /api/orgs/:orgId             — Update org (requires admin role)\nDELETE /api/orgs/:orgId             — Delete org (requires admin role)\n\nPOST   /api/orgs/:orgId/members     — Add member (requires admin role)\nGET    /api/orgs/:orgId/members     — List members (requires member)\nPUT    /api/orgs/:orgId/members/:did — Update member role (requires admin)\nDELETE /api/orgs/:orgId/members/:did — Remove member (requires admin, can't remove last admin)\n```\n\n### Request/Response formats\n```typescript\n// POST /api/orgs\nRequest:  { name: string }\nResponse: { id, did, handle, name, createdAt, role: 'admin' }\n\n// POST /api/orgs/:orgId/members\nRequest:  { userDid: string, role: 'admin' | 'contributor' | 'viewer' }\nResponse: { orgId, userDid, role, invitedBy, createdAt }\n```\n\n### Validation\n- name: required, 1-100 chars, trimmed\n- role: must be one of admin/contributor/viewer\n- orgId: must exist\n- userDid: must be a valid DID format (did:plc:... or did:web:...)\n\n## Don't\n- Create PDS accounts for orgs (that's a separate task)\n- Implement invitation emails (just add to membership directly)\n- Allow removing the last admin from an org\n- Skip input validation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:08:14.636488+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.615249+08:00","closed_at":"2026-02-18T15:44:50.615252+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-xpo.2","depends_on_id":"hypercerts-scaffold-xpo","type":"parent-child","created_at":"2026-02-18T14:08:14.637483+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-xpo.2","depends_on_id":"hypercerts-scaffold-xpo.1","type":"blocks","created_at":"2026-02-18T14:08:14.638864+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-xpo.3","title":"Add org listing UI to scaffold app after login","description":"## Files\n- app/orgs/page.tsx (create)\n- components/org-list.tsx (create)\n- components/org-card.tsx (create)\n- lib/api/orgs.ts (create)\n- queries/queries/use-user-orgs-query.ts (create)\n\n## What to do\nAfter a user logs in, they should see a list of organizations they belong to. Create the org listing page and components.\n\n### /orgs page\nServer component that shows the user's organizations. If the user has no orgs, show a 'Create Organization' CTA.\n\n### OrgList component\n```typescript\n// Client component that fetches and displays user's orgs\nexport function OrgList(): JSX.Element\n// Uses useUserOrgsQuery to fetch orgs from the sidecar API\n// Renders a grid of OrgCard components\n// Shows empty state with 'Create Organization' button if no orgs\n```\n\n### OrgCard component\n```typescript\ninterface OrgCardProps {\n  org: { id: string, name: string, handle: string, role: string, memberCount?: number }\n}\nexport function OrgCard({ org }: OrgCardProps): JSX.Element\n// Displays org name, handle, user's role badge, member count\n// Clicking navigates to /orgs/[orgId]\n// Uses shadcn Card component\n```\n\n### API client\n```typescript\n// lib/api/orgs.ts\nexport async function getUserOrgs(): Promise\u003cOrg[]\u003e\nexport async function getOrg(orgId: string): Promise\u003cOrg\u003e\nexport async function createOrg(name: string): Promise\u003cOrg\u003e\n```\n\n### Query hook\n```typescript\nexport function useUserOrgsQuery() {\n  return useQuery({ queryKey: ['orgs'], queryFn: getUserOrgs })\n}\n```\n\n### Styling\n- Use the existing design system (shadcn Card, Badge for roles, Syne headings, Outfit body)\n- Role badges: admin=red, contributor=blue, viewer=gray\n- Responsive grid: 1 col mobile, 2 cols tablet, 3 cols desktop\n\n## Don't\n- Implement org creation flow (just the listing)\n- Add org management (member add/remove) — that's a separate task\n- Fetch org data from the PDS directly — go through the sidecar API\n- Break existing pages or navigation","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-18T14:08:31.351755+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.701517+08:00","closed_at":"2026-02-18T15:44:50.701519+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-xpo.3","depends_on_id":"hypercerts-scaffold-xpo","type":"parent-child","created_at":"2026-02-18T14:08:31.352705+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-scaffold-xpo.3","depends_on_id":"hypercerts-scaffold-xpo.2","type":"blocks","created_at":"2026-02-18T14:08:31.354332+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-y4y","title":"Epic: Infrastructure \u0026 Deployment","description":"## Goal\nSet up all infrastructure needed to deploy and operate the Certified auth system: OTP service + PDS deployment as a reverse proxy topology, database, SMTP, domain configuration, and environment setup.\n\n## Components\n1. **Deployment Topology**: OTP service (public-facing at certified.app) sits in front of PDS (internal-only). Both run together via Docker Compose or equivalent. No auth.certified.app or pds.certified.app subdomains needed.\n2. **Database**: PostgreSQL for the OTP service (accounts, otp_codes, rate_limits tables). Managed service with backups.\n3. **SMTP**: Email delivery for OTP codes. Use Resend or SES. Domain verification (SPF, DKIM, DMARC) for certified.app.\n4. **Domain Configuration**: certified.app points to the OTP service (reverse proxy). PDS is internal-only. TLS at the proxy layer.\n5. **Secret Management**: AES-256 encryption key for stored passwords. Environment variables for SMTP, DB connection, PDS_INTERNAL_URL.\n6. **Scaffold Environment**: Update Scaffold's .env.example and config.ts with CERTIFIED_PDS_URL=https://certified.app.\n7. **Cleanup**: Remove old packages/pds-sidecar/ artifacts from Scaffold repo.\n\n## Reference\nSee docs/certified-implementation-spec.md","status":"open","priority":1,"issue_type":"epic","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:10:26.836671+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:00:25.816119+08:00"}
{"id":"hypercerts-scaffold-y4y.1","title":"Domain and network configuration for reverse proxy","description":"## What to Do\nConfigure the network topology for the reverse proxy architecture. The OTP service is the public-facing server at certified.app; the PDS runs internally behind it.\n\n### Architecture\n```\nInternet → certified.app (OTP service / reverse proxy, port 443)\n                │\n                └──→ PDS (internal only, e.g., localhost:2583 or internal Docker hostname)\n```\n\n### DNS\n- certified.app already exists and currently points to the PDS directly\n- After migration: certified.app points to the OTP service (reverse proxy)\n- The PDS moves to an internal address — not publicly accessible\n- No auth.certified.app subdomain needed\n- No pds.certified.app subdomain needed\n\n### Migration Plan\n1. Deploy OTP service alongside PDS on the same host/network\n2. Configure OTP service with PDS_INTERNAL_URL pointing to PDS internal address\n3. Verify proxy works — all PDS functionality accessible through the OTP service at the same URLs\n4. Switch certified.app DNS / load-balancer to point to OTP service instead of PDS directly\n5. Verify everything still works end-to-end\n\n### Email DNS\nConfigure on certified.app domain for OTP email delivery:\n- SPF TXT record: allow the chosen SMTP provider to send on behalf of certified.app\n- DKIM CNAME or TXT record: email signing key\n- DMARC TXT record: email authentication policy\n- Verify domain with the chosen SMTP provider (Resend, SES, etc.)\n\n### TLS\n- TLS certificate for certified.app (already exists; may need to be transferred to OTP service host)\n- Internal PDS-to-OTP communication can be plain HTTP (same host / private network)\n\n### Don't\n- Don't expose the PDS port to the public internet after migration\n- Don't leave DNS changes undocumented\n- Don't skip TLS on the public endpoint\n- Don't break existing PDS functionality during migration (plan a rollback)\n\n## Acceptance Criteria\n1. certified.app resolves to the OTP service (reverse proxy)\n2. PDS is accessible only through the reverse proxy — not directly from the internet\n3. TLS certificate is valid for certified.app\n4. SPF/DKIM/DMARC records support sending from noreply@certified.app\n5. Migration plan documented with rollback steps","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:15:37.413061+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:04:00.065667+08:00","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-y4y.1","depends_on_id":"hypercerts-scaffold-y4y","type":"parent-child","created_at":"2026-02-18T17:15:37.414581+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-y4y.2","title":"OTP service + PDS deployment (reverse proxy topology)","description":"## What to Do\nSet up deployment infrastructure for the OTP service and PDS running together in a reverse proxy topology at certified.app.\n\n### Deployment Topology\nThe OTP service and PDS run together. Options:\n- **Same host, different ports**: OTP service on port 443 (public), PDS on port 2583 (internal)\n- **Docker Compose**: Two containers on the same Docker network. OTP service exposed publicly, PDS is internal-only.\n- **Kubernetes**: Two pods; OTP service has a Service/Ingress, PDS is ClusterIP only.\n\n### Dockerfile (OTP Service)\nBuild from the OTP service project (08v.1):\n- Multi-stage build: builder stage + production stage\n- Node.js 20 Alpine base image\n- Run database migrations on startup (or as a pre-deploy hook)\n- Health check: GET /health\n- Non-root user for security\n- Environment variables passed at runtime (not baked in)\n\n### Docker Compose (recommended for initial deployment)\n```yaml\nservices:\n  otp-service:\n    build: ./otp-service\n    ports:\n      - '443:3000'\n    environment:\n      - PDS_INTERNAL_URL=http://pds:2583\n      - DATABASE_URL=postgresql://...\n      - CREDENTIAL_ENCRYPTION_KEY=...\n      - SMTP_URL=...\n    depends_on:\n      - pds\n      - postgres\n\n  pds:\n    image: ghcr.io/bluesky-social/pds:latest\n    # NOT exposed publicly — internal only\n    environment:\n      - PDS_HOSTNAME=certified.app\n      - PDS_PORT=2583\n      # ... other PDS config\n\n  postgres:\n    image: postgres:15\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n```\n\n### Hosting\n- **Fly.io** (recommended): Docker deployment, built-in TLS, PostgreSQL add-on\n- **Railway**: Similar to Fly.io\n- **DigitalOcean**: Docker Compose on a Droplet\n- **AWS ECS/Fargate**: More complex but enterprise-grade\n\n### CI/CD\n- GitHub Actions workflow: build Docker image, push to registry, deploy on push to main\n- Run tests before deployment\n- Tag images with git commit SHA\n\n### Don't\n- Don't expose the PDS port publicly\n- Don't bake secrets into the Docker image\n- Don't skip health checks\n- Don't deploy without a CI/CD pipeline\n\n## Acceptance Criteria\n1. OTP service Dockerfile builds and runs\n2. Docker Compose (or equivalent) runs both OTP service and PDS together\n3. certified.app serves the OTP service (reverse proxy)\n4. PDS is only accessible through the proxy — not directly from the internet\n5. Health check endpoint is monitored\n6. Secrets are passed as environment variables\n7. CI/CD pipeline is configured","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:15:50.903974+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:04:13.451606+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-y4y.2","depends_on_id":"hypercerts-scaffold-y4y","type":"parent-child","created_at":"2026-02-18T17:15:50.905181+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-y4y.2","depends_on_id":"hypercerts-scaffold-08v.1","type":"blocks","created_at":"2026-02-18T17:16:45.125672+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-y4y.2","depends_on_id":"hypercerts-scaffold-y4y.1","type":"blocks","created_at":"2026-02-18T17:16:45.206082+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-y4y.2","depends_on_id":"hypercerts-scaffold-y4y.3","type":"blocks","created_at":"2026-02-18T17:16:45.278234+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-y4y.3","title":"PostgreSQL database provisioning","description":"## What to Do\nProvision a PostgreSQL database for the OTP service.\n\n### Requirements\n- PostgreSQL 15+ \n- Managed service with automated backups (daily, 7-day retention minimum)\n- Connection pooling (PgBouncer or built-in)\n- TLS-encrypted connections\n- Located in same region as OTP service for low latency\n\n### Options\n- **Fly.io Postgres** (if using Fly.io for hosting): Built-in, easy to set up\n- **Neon** (serverless Postgres): Good for variable workloads, generous free tier\n- **Supabase**: Managed Postgres with extras\n- **AWS RDS**: Enterprise-grade, more setup\n\n### Schema\nThe schema is defined in Epic 1 Task 2 (Database schema and migrations). This task is about provisioning the actual database instance.\n\n### Access\n- DATABASE_URL connection string with credentials\n- Restrict network access to OTP service only (private networking or IP allowlist)\n- Separate credentials for migrations vs application access (if the provider supports it)\n\n### Don't\n- Don't use an unmanaged database without backups\n- Don't expose the database to the public internet\n- Don't skip TLS for database connections\n\n## Acceptance Criteria\n1. PostgreSQL database is provisioned and accessible\n2. DATABASE_URL is generated and stored securely\n3. Automated backups are configured\n4. Network access is restricted to OTP service\n5. TLS is enabled for connections","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:15:56.241852+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T17:15:56.241852+08:00","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-y4y.3","depends_on_id":"hypercerts-scaffold-y4y","type":"parent-child","created_at":"2026-02-18T17:15:56.243678+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-y4y.4","title":"SMTP configuration for OTP emails","description":"## What to Do\nConfigure SMTP email delivery for the OTP service.\n\n### Requirements\n- Reliable email delivery (\u003e99% deliverability)\n- Support for sending from noreply@certified.app\n- SPF, DKIM, DMARC records on certified.app domain\n- Reasonable rate limits (at least 100 emails/hour)\n- SMTP connection string format for Nodemailer\n\n### Options\n- **Resend** (recommended): Already used for PDS sidecar (see packages/pds-sidecar/.env.dev.local). Modern API, good deliverability, supports SMTP. Free tier: 100 emails/day.\n- **AWS SES**: Highly scalable, cheap, requires domain verification\n- **Postmark**: Good deliverability, transactional email focused\n- **SendGrid**: Popular, free tier available\n\n### DNS Records for certified.app\n1. SPF record: TXT record allowing the SMTP provider to send on behalf of certified.app\n2. DKIM record: CNAME or TXT record for email signing\n3. DMARC record: TXT record for email authentication policy\n4. Verify the domain with the chosen provider\n\n### Environment Variable\nSMTP_URL in the format: smtps://resend:re_xxxx@smtp.resend.com:465\n\n### Don't\n- Don't use a personal email account as SMTP relay\n- Don't skip domain verification (emails will go to spam)\n- Don't use the same SMTP credentials as the PDS (separation of concerns)\n\n## Acceptance Criteria\n1. SMTP provider is configured and verified\n2. SPF, DKIM, DMARC records are set on certified.app\n3. Test email sends successfully from noreply@certified.app\n4. SMTP_URL is generated and stored securely\n5. Emails don't land in spam folders","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:16:02.464894+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T17:16:02.464894+08:00","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-y4y.4","depends_on_id":"hypercerts-scaffold-y4y","type":"parent-child","created_at":"2026-02-18T17:16:02.465923+08:00","created_by":"Sharfy Adamantine"},{"issue_id":"hypercerts-scaffold-y4y.4","depends_on_id":"hypercerts-scaffold-y4y.1","type":"blocks","created_at":"2026-02-18T17:16:45.349416+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-y4y.5","title":"Update Scaffold environment configuration","description":"## What to Do\nUpdate Scaffold's environment configuration to support the Certified auth flow.\n\n### Files to Modify\n\n#### .env.example\nAdd new variables:\n```\n# -----------------------------\n# Certified Auth\n# -----------------------------\n# URL of the Certified PDS reverse proxy (for the 'Sign in' button)\n# Defaults to NEXT_PUBLIC_PDS_URL if not set\nCERTIFIED_PDS_URL=https://certified.app\n```\n\n#### lib/config.ts\nAdd to the config object:\n- certifiedPdsUrl: process.env.CERTIFIED_PDS_URL || process.env.NEXT_PUBLIC_PDS_URL || 'https://certified.app'\n\nNote: CERTIFIED_PDS_URL is optional — if not set, it falls back to NEXT_PUBLIC_PDS_URL (which is already the PDS URL configured for this deployment). This means the 'Sign in' button works without extra configuration when NEXT_PUBLIC_PDS_URL already points to certified.app.\n\n### Don't\n- Don't add OTP-service-specific env vars to Scaffold (PDS_INTERNAL_URL, CREDENTIAL_ENCRYPTION_KEY, SMTP_URL belong in the OTP service only)\n- Don't remove existing env vars\n- Don't make CERTIFIED_PDS_URL required — it has a sensible default\n- Don't reference auth.certified.app or pds.certified.app\n\n## Acceptance Criteria\n1. .env.example has CERTIFIED_PDS_URL with a comment explaining its purpose\n2. config.ts has certifiedPdsUrl with fallback chain (CERTIFIED_PDS_URL → NEXT_PUBLIC_PDS_URL → 'https://certified.app')\n3. Existing config values and behaviour unchanged\n4. TypeScript compiles without errors","status":"open","priority":1,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:16:08.455704+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T18:04:21.014819+08:00","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-y4y.5","depends_on_id":"hypercerts-scaffold-y4y","type":"parent-child","created_at":"2026-02-18T17:16:08.457137+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-y4y.6","title":"Clean up old pds-sidecar artifacts","description":"## What to Do\nDelete the old packages/pds-sidecar/ directory from the Scaffold repo. It contains orphaned compiled JS files from an old prototype — no source code, no package.json at root level, no tsconfig. It's dead code that confuses anyone reading the repo.\n\n### Steps\n1. Delete the entire packages/pds-sidecar/ directory\n2. Check .gitmodules — if it references pds-sidecar, remove that entry\n3. Check root package.json — if it has workspace references to pds-sidecar, remove them\n4. If packages/ directory is now empty, leave it (other packages may be added later)\n\n### Don't\n- Don't delete anything outside of packages/pds-sidecar/\n- Don't modify any other package configuration\n\n## Acceptance Criteria\n1. packages/pds-sidecar/ directory no longer exists\n2. .gitmodules has no pds-sidecar references\n3. Root package.json has no pds-sidecar workspace references\n4. No other files are modified\n5. git status shows the deletion cleanly","status":"open","priority":2,"issue_type":"task","owner":"sharfy.adamantine@gmail.com","created_at":"2026-02-18T17:16:13.310422+08:00","created_by":"Sharfy Adamantine","updated_at":"2026-02-18T17:16:13.310422+08:00","labels":["scope:trivial"],"dependencies":[{"issue_id":"hypercerts-scaffold-y4y.6","depends_on_id":"hypercerts-scaffold-y4y","type":"parent-child","created_at":"2026-02-18T17:16:13.311947+08:00","created_by":"Sharfy Adamantine"}]}
{"id":"hypercerts-scaffold-y8f","title":"Fix: CADDY_DNS_PROVIDER env var missing from docker-compose.yml caddy service (from hypercerts-scaffold-0yp.1)","description":"Review of hypercerts-scaffold-0yp.1 found: Caddyfile uses ${CADDY_DNS_PROVIDER} (line 11) and .env.example documents it (line 88), but docker-compose.yml only passes CADDY_DNS_API_KEY to the caddy service environment — CADDY_DNS_PROVIDER is not passed. The wildcard TLS DNS challenge will fail at runtime because the Caddy container won't have the DNS provider name. Evidence: docker-compose.yml caddy environment block only has CADDY_DNS_API_KEY; Caddyfile line 11 references both ${CADDY_DNS_PROVIDER} and ${CADDY_DNS_API_KEY}. Fix: add '- CADDY_DNS_PROVIDER=${CADDY_DNS_PROVIDER}' to the caddy service environment in docker-compose.yml.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-02-17T18:53:09.612553+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.830453+08:00","closed_at":"2026-02-17T18:56:11.830455+08:00","dependencies":[{"issue_id":"hypercerts-scaffold-y8f","depends_on_id":"hypercerts-scaffold-0yp.1","type":"discovered-from","created_at":"2026-02-17T18:53:09.731197+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-scaffold-y9g","title":"Epic: Scaffold Email-First Login UI","description":"## Goal\nAdd an email-first login page to the scaffold Next.js app. Users enter their email, get redirected to the sidecar for OTP, and come back authenticated. Also add a handle-based fallback for existing ATProto/Bluesky users.\n\n## Context\nThe scaffold currently has handle-based login only:\n- components/login-dialog.tsx: form with handle input, calls useLoginMutation\n- app/api/auth/login/route.ts: POST handler that calls sdk.authorize(handle)\n- app/api/auth/callback/route.ts: OAuth callback handler (works for both flows)\n- providers/SignedInProvider.tsx: auth gate that shows LoginDialog if not signed in\n\n## What Needs to Change\n1. New /login page with email input as primary option + handle fallback as secondary\n2. New /api/auth/email-login route that calls sdk.authorize(pdsUrl, { login_hint: email })\n3. New useEmailLoginMutation hook\n4. The existing handle-based flow stays untouched — both coexist\n\n## The Email Login Flow\n1. User visits /login, enters email, clicks Continue\n2. Scaffold POSTs to /api/auth/email-login with { email }\n3. Route calls sdk.authorize(NEXT_PUBLIC_PDS_URL) — this is the key shortcut: passing the PDS URL directly skips handle resolution\n4. The authorize URL includes login_hint=email as a query parameter\n5. Browser redirects to PDS → PDS metadata points to sidecar → sidecar shows OTP form\n6. After OTP verification, browser redirects back to /api/auth/callback (same as handle flow)\n7. User is logged in\n\n## Key Technical Detail\nsdk.authorize() accepts a handle, DID, or PDS URL. When given a PDS URL like 'https://certified.app', it skips handle→DID→PDS resolution and goes directly to that PDS. The login_hint parameter is passed through to the authorization URL so the sidecar can auto-send the OTP.\n\n## Existing Code to Reference\n- lib/config.ts: has config.pdsUrl (from NEXT_PUBLIC_PDS_URL env var)\n- lib/hypercerts-sdk.ts: SDK initialization with sdk.authorize()\n- queries/auth.ts: useLoginMutation hook\n- components/login-dialog.tsx: existing handle login UI\n\n## Hard Constraints\n- Don't break the existing handle-based login\n- Don't modify the OAuth callback route\n- Email-first must be the primary/default option on /login\n- Handle fallback must be secondary (smaller, below a divider)","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-18T15:47:46.193644+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.058144+08:00","closed_at":"2026-02-18T15:54:59.058146+08:00","labels":["scope:small"]}
{"id":"hypercerts-scaffold-y9g.1","title":"Add /login page, email-login API route, and useEmailLoginMutation hook","description":"## Files\n- app/login/page.tsx (create)\n- app/api/auth/email-login/route.ts (create)\n- queries/mutations/use-email-login-mutation.ts (create)\n- lib/api/auth.ts (modify — add emailLogin function)\n- providers/SignedInProvider.tsx (modify — allow /login to bypass auth gate)\n\n## What to do\n\n### 1. API route: app/api/auth/email-login/route.ts\n```typescript\nimport sdk from '@/lib/hypercerts-sdk'\nimport { config } from '@/lib/config'\nimport { NextResponse } from 'next/server'\n\nexport async function POST(request: Request) {\n  const { email } = await request.json()\n  if (!email || typeof email !== 'string') {\n    return Response.json({ error: 'Email is required' }, { status: 400 })\n  }\n  try {\n    // Pass PDS URL directly — skips handle resolution\n    // Append login_hint so sidecar auto-sends OTP\n    const authUrl = await sdk.authorize(config.pdsUrl)\n    // Append login_hint to the auth URL\n    const url = new URL(authUrl)\n    url.searchParams.set('login_hint', email)\n    return NextResponse.json({ authUrl: url.toString() })\n  } catch (e) {\n    console.error('Failed to initiate email login', e)\n    return Response.json({ error: 'Failed to initiate login' }, { status: 500 })\n  }\n}\n```\n\n### 2. API client function: lib/api/auth.ts\nAdd `emailLogin(email: string)` that POSTs to /api/auth/email-login and redirects to the returned authUrl.\n\n### 3. Mutation hook: queries/mutations/use-email-login-mutation.ts\nSame pattern as existing useLoginMutation but calls emailLogin(email) instead.\n\n### 4. Login page: app/login/page.tsx\nDual-option layout:\n- **Primary (top)**: Email input + Continue button. Uses useEmailLoginMutation.\n- **Divider**: '— or —' separator\n- **Secondary (bottom)**: 'Already have a Bluesky account?' + handle input + Sign in button. Uses existing useLoginMutation.\n- Email section: larger, primary button styling\n- Handle section: smaller, outline/ghost button styling\n- Both disable during loading, show Spinner, show toast on error (sonner)\n\n### 5. Auth gate bypass\nModify SignedInProvider.tsx to NOT redirect /login to the LoginDialog. The /login page should be accessible without authentication.\n\n## Existing patterns to follow\n- Look at components/login-dialog.tsx for the handle login pattern\n- Look at queries/auth.ts for useLoginMutation\n- Use shadcn components: Card, Input, Button, Separator, Spinner\n- Use fonts: Syne for headings, Outfit for body text\n- Use sonner toast for errors\n\n## Don't\n- Modify the existing /api/auth/login route\n- Modify the existing /api/auth/callback route\n- Modify components/login-dialog.tsx\n- Add new npm dependencies\n- Hard-code the PDS URL (use config.pdsUrl)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-18T15:48:05.74398+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.985059+08:00","closed_at":"2026-02-18T15:54:58.98506+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-scaffold-y9g.1","depends_on_id":"hypercerts-scaffold-y9g","type":"parent-child","created_at":"2026-02-18T15:48:05.745957+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-tam","title":"Fix: login_hint appended with \u0026 but authorize URL may already lack query params (from hypercerts-2bf.3)","description":"Review of hypercerts-2bf.3 found: app/api/auth/email-login/route.ts line 25 appends login_hint with a bare '\u0026': `${baseAuthUrl}\u0026login_hint=...`. If sdk.authorize(pdsUrl) returns a URL that has no existing query parameters (e.g. 'https://pds.example.com/oauth/authorize'), the result would be 'https://pds.example.com/oauth/authorize\u0026login_hint=...' which is malformed. The correct approach is to use URL/URLSearchParams to append the parameter safely. Evidence: route.ts line 25: const authUrl = `${baseAuthUrl}\u0026login_hint=${encodeURIComponent(email)}`. Fix: parse baseAuthUrl as a URL object, use url.searchParams.set('login_hint', email), then return url.toString().","status":"closed","priority":2,"issue_type":"bug","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:53:17.066412+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.9052+08:00","closed_at":"2026-02-17T18:56:11.905203+08:00","dependencies":[{"issue_id":"hypercerts-tam","depends_on_id":"hypercerts-2bf.3","type":"discovered-from","created_at":"2026-02-17T18:53:17.242534+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-xi5","title":"Fix: magic-callback redirects to /oauth/authorize/redirect but this endpoint may not exist on stock PDS (from hypercerts-qc3.7)","description":"Review of hypercerts-qc3.7 found: magic-callback.ts lines 138-153 builds a redirect to `${issuer}/oauth/authorize/redirect` with code, redirect_uri, redirect_mode, state, and iss as query params. However, the stock @atproto/pds does not expose a public /oauth/authorize/redirect endpoint that accepts these parameters externally — the authorization code redirect is normally handled internally by the OAuthProvider after setAuthorized(). The correct flow after calling requestManager.setAuthorized() is to use the returned code and build the redirect to the client's redirect_uri directly (not via an intermediate PDS endpoint). This may cause a 404 or incorrect redirect in production. Evidence: magic-callback.ts lines 138-153; @atproto/pds OAuth flow internals. This needs verification against the actual @atproto/pds ^0.4.0 source to confirm whether /oauth/authorize/redirect is a real endpoint.","status":"closed","priority":1,"issue_type":"bug","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:53:44.449732+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:27.258457+08:00","closed_at":"2026-02-17T18:56:27.258464+08:00","dependencies":[{"issue_id":"hypercerts-xi5","depends_on_id":"hypercerts-qc3.7","type":"discovered-from","created_at":"2026-02-17T18:53:44.562288+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-xpo","title":"Epic: Organization Membership \u0026 RBAC Backend","description":"## Goal\nBuild the application-layer organization membership and role-based access control (RBAC) system. Users belong to organizations with roles (admin, contributor, viewer) that control who can write to org repos.\n\n## Context\nATProto has NO native org support — no multi-signature repos, no RBAC, no org identity, no delegation tokens. Every repo has exactly one signing key. All org logic must live in our application layer.\n\nThe architecture doc specifies:\n- Our backend maintains org membership (user_did → [org_ids])\n- Roles: admin, contributor, viewer\n- Org repos are DID-based accounts whose signing keys we hold server-side\n- The org/RBAC layer is completely independent of how users authenticate\n\nThis is a parallel workstream to the auth work. It does NOT depend on the OTP/sidecar being complete.\n\n### How Orgs Work in ATProto\nEach org is a regular ATProto account (has a DID, a handle, a repo). The difference:\n- The org's signing key is held by our backend (not by any individual user)\n- Our backend mediates all writes to the org's repo\n- Users don't directly interact with the org's PDS account — they go through our API\n\n### Data Model\n```\norganizations\n  id: UUID\n  did: TEXT (the org's ATProto DID)\n  handle: TEXT (e.g., maearth.certified.app)\n  name: TEXT\n  created_at: TIMESTAMP\n\norg_memberships\n  org_id: UUID (FK → organizations.id)\n  user_did: TEXT (the user's ATProto DID)\n  role: TEXT (admin | contributor | viewer)\n  invited_by: TEXT (DID of inviter)\n  created_at: TIMESTAMP\n  PRIMARY KEY (org_id, user_did)\n```\n\n## Hard Constraints\n- All org data lives in our application DB (SQLite for now, Postgres later)\n- Org repos are real ATProto accounts on the same PDS\n- Org signing keys are held server-side (encrypted, like user passwords)\n- No ATProto protocol changes — pure application layer\n- Must work with the existing PDS sidecar architecture\n\n## Success Looks Like\n- CRUD API for organizations\n- Membership management (invite, remove, change role)\n- Role-based permission checks on all org operations\n- Org accounts created on the PDS with server-held signing keys\n- Users can see all orgs they belong to after login","status":"closed","priority":2,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T14:07:37.261395+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.407706+08:00","closed_at":"2026-02-18T15:44:50.40771+08:00","labels":["scope:medium"]}
{"id":"hypercerts-xpo.1","title":"Create org and membership database schema and data access layer","description":"## Files\n- packages/pds-sidecar/packages/shared/src/org-store.ts (create)\n- packages/pds-sidecar/packages/shared/src/org-store.test.ts (create)\n- packages/pds-sidecar/packages/shared/src/db.ts (modify — add org tables)\n\n## What to do\nCreate the database schema and data access layer for organizations and memberships.\n\n### OrgStore class\n```typescript\nexport type OrgRole = 'admin' | 'contributor' | 'viewer'\n\nexport interface Organization {\n  id: string  // UUID\n  did: string\n  handle: string\n  name: string\n  createdAt: string\n}\n\nexport interface OrgMembership {\n  orgId: string\n  userDid: string\n  role: OrgRole\n  invitedBy: string\n  createdAt: string\n}\n\nexport class OrgStore {\n  constructor(db: BetterSqlite3.Database)\n\n  // Organization CRUD\n  createOrg(org: { did: string, handle: string, name: string }): Organization\n  getOrg(id: string): Organization | null\n  getOrgByDid(did: string): Organization | null\n  getOrgByHandle(handle: string): Organization | null\n  updateOrg(id: string, updates: { name?: string, handle?: string }): Organization\n  deleteOrg(id: string): void\n\n  // Membership management\n  addMember(orgId: string, userDid: string, role: OrgRole, invitedBy: string): OrgMembership\n  removeMember(orgId: string, userDid: string): void\n  updateRole(orgId: string, userDid: string, newRole: OrgRole): void\n  getMember(orgId: string, userDid: string): OrgMembership | null\n  getMembers(orgId: string): OrgMembership[]\n  getUserOrgs(userDid: string): (Organization \u0026 { role: OrgRole })[]\n\n  // Permission checks\n  hasRole(orgId: string, userDid: string, requiredRole: OrgRole): boolean\n  canWrite(orgId: string, userDid: string): boolean  // admin or contributor\n  canAdmin(orgId: string, userDid: string): boolean   // admin only\n}\n```\n\n### DB tables\n```sql\nCREATE TABLE IF NOT EXISTS organizations (\n  id TEXT PRIMARY KEY,\n  did TEXT UNIQUE NOT NULL,\n  handle TEXT UNIQUE NOT NULL,\n  name TEXT NOT NULL,\n  created_at TEXT DEFAULT (datetime('now'))\n);\n\nCREATE TABLE IF NOT EXISTS org_memberships (\n  org_id TEXT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,\n  user_did TEXT NOT NULL,\n  role TEXT NOT NULL CHECK(role IN ('admin', 'contributor', 'viewer')),\n  invited_by TEXT NOT NULL,\n  created_at TEXT DEFAULT (datetime('now')),\n  PRIMARY KEY (org_id, user_did)\n);\nCREATE INDEX IF NOT EXISTS idx_memberships_user ON org_memberships(user_did);\n```\n\n### Role hierarchy\n- admin: can manage members, change roles, delete org, write to org repo\n- contributor: can write to org repo\n- viewer: can read org repo (read is public in ATProto, so this is mainly for UI filtering)\n\n### UUID generation\nUse crypto.randomUUID() (Node.js built-in).\n\n## Don't\n- Add API routes (that's a separate task)\n- Add PDS account creation logic (that's the org repo management epic)\n- Use an external UUID library\n- Make role checks case-sensitive (normalize to lowercase)","acceptance_criteria":"1. OrgStore class exists with all methods. 2. DB tables created with correct schema. 3. CRUD operations work for orgs and memberships. 4. hasRole correctly checks role hierarchy. 5. canWrite returns true for admin and contributor, false for viewer. 6. getUserOrgs returns all orgs with roles for a given DID. 7. Tests cover all CRUD operations, role checks, and edge cases (non-existent org, duplicate member).","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:07:55.666996+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.519682+08:00","closed_at":"2026-02-18T15:44:50.519685+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-xpo.1","depends_on_id":"hypercerts-xpo","type":"parent-child","created_at":"2026-02-18T14:07:55.668333+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-xpo.2","title":"Create org management API routes (CRUD + membership)","description":"## Files\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/routes/orgs.test.ts (create)\n- packages/pds-sidecar/packages/auth-service/src/middleware/auth-middleware.ts (create)\n\n## What to do\nCreate Express API routes for organization management, protected by user authentication.\n\n### Auth Middleware\nCreate middleware that extracts the user's DID from the request. In the Certified architecture, the user is authenticated via ATProto OAuth — the scaffold backend has their session. For org API calls, the scaffold backend includes the user's DID in a signed header or JWT.\n\nFor now, use a simple approach:\n```typescript\n// Middleware that extracts user DID from Authorization header\n// Format: Bearer \u003cuser_did\u003e (simplified for internal service-to-service calls)\n// In production, this should verify a JWT signed by the scaffold backend\nexport function requireAuth(): RequestHandler\n```\n\n### API Routes\n```\nPOST   /api/orgs                    — Create org (requires auth, creator becomes admin)\nGET    /api/orgs                    — List user's orgs (requires auth, returns orgs for user's DID)\nGET    /api/orgs/:orgId             — Get org details (requires auth, must be member)\nPUT    /api/orgs/:orgId             — Update org (requires admin role)\nDELETE /api/orgs/:orgId             — Delete org (requires admin role)\n\nPOST   /api/orgs/:orgId/members     — Add member (requires admin role)\nGET    /api/orgs/:orgId/members     — List members (requires member)\nPUT    /api/orgs/:orgId/members/:did — Update member role (requires admin)\nDELETE /api/orgs/:orgId/members/:did — Remove member (requires admin, can't remove last admin)\n```\n\n### Request/Response formats\n```typescript\n// POST /api/orgs\nRequest:  { name: string }\nResponse: { id, did, handle, name, createdAt, role: 'admin' }\n\n// POST /api/orgs/:orgId/members\nRequest:  { userDid: string, role: 'admin' | 'contributor' | 'viewer' }\nResponse: { orgId, userDid, role, invitedBy, createdAt }\n```\n\n### Validation\n- name: required, 1-100 chars, trimmed\n- role: must be one of admin/contributor/viewer\n- orgId: must exist\n- userDid: must be a valid DID format (did:plc:... or did:web:...)\n\n## Don't\n- Create PDS accounts for orgs (that's a separate task)\n- Implement invitation emails (just add to membership directly)\n- Allow removing the last admin from an org\n- Skip input validation","acceptance_criteria":"1. All 9 API routes exist and return correct status codes. 2. Auth middleware extracts user DID. 3. Admin-only routes reject non-admin users with 403. 4. Member-only routes reject non-members with 403. 5. Cannot remove last admin. 6. Input validation rejects invalid data with 400. 7. Tests cover: CRUD operations, role-based access control, edge cases.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":60,"created_at":"2026-02-18T14:08:14.636488+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.615249+08:00","closed_at":"2026-02-18T15:44:50.615252+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-xpo.2","depends_on_id":"hypercerts-xpo","type":"parent-child","created_at":"2026-02-18T14:08:14.637483+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-xpo.2","depends_on_id":"hypercerts-xpo.1","type":"blocks","created_at":"2026-02-18T14:08:14.638864+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-xpo.3","title":"Add org listing UI to scaffold app after login","description":"## Files\n- app/orgs/page.tsx (create)\n- components/org-list.tsx (create)\n- components/org-card.tsx (create)\n- lib/api/orgs.ts (create)\n- queries/queries/use-user-orgs-query.ts (create)\n\n## What to do\nAfter a user logs in, they should see a list of organizations they belong to. Create the org listing page and components.\n\n### /orgs page\nServer component that shows the user's organizations. If the user has no orgs, show a 'Create Organization' CTA.\n\n### OrgList component\n```typescript\n// Client component that fetches and displays user's orgs\nexport function OrgList(): JSX.Element\n// Uses useUserOrgsQuery to fetch orgs from the sidecar API\n// Renders a grid of OrgCard components\n// Shows empty state with 'Create Organization' button if no orgs\n```\n\n### OrgCard component\n```typescript\ninterface OrgCardProps {\n  org: { id: string, name: string, handle: string, role: string, memberCount?: number }\n}\nexport function OrgCard({ org }: OrgCardProps): JSX.Element\n// Displays org name, handle, user's role badge, member count\n// Clicking navigates to /orgs/[orgId]\n// Uses shadcn Card component\n```\n\n### API client\n```typescript\n// lib/api/orgs.ts\nexport async function getUserOrgs(): Promise\u003cOrg[]\u003e\nexport async function getOrg(orgId: string): Promise\u003cOrg\u003e\nexport async function createOrg(name: string): Promise\u003cOrg\u003e\n```\n\n### Query hook\n```typescript\nexport function useUserOrgsQuery() {\n  return useQuery({ queryKey: ['orgs'], queryFn: getUserOrgs })\n}\n```\n\n### Styling\n- Use the existing design system (shadcn Card, Badge for roles, Syne headings, Outfit body)\n- Role badges: admin=red, contributor=blue, viewer=gray\n- Responsive grid: 1 col mobile, 2 cols tablet, 3 cols desktop\n\n## Don't\n- Implement org creation flow (just the listing)\n- Add org management (member add/remove) — that's a separate task\n- Fetch org data from the PDS directly — go through the sidecar API\n- Break existing pages or navigation","acceptance_criteria":"1. /orgs page exists and renders org list. 2. OrgCard shows name, handle, role badge. 3. Empty state shows when user has no orgs. 4. useUserOrgsQuery hook fetches from sidecar API. 5. Responsive grid layout works on mobile and desktop. 6. pnpm build succeeds.","status":"closed","priority":2,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T14:08:31.351755+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:44:50.701517+08:00","closed_at":"2026-02-18T15:44:50.701519+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-xpo.3","depends_on_id":"hypercerts-xpo","type":"parent-child","created_at":"2026-02-18T14:08:31.352705+08:00","created_by":"sharfy-test.climateai.org"},{"issue_id":"hypercerts-xpo.3","depends_on_id":"hypercerts-xpo.2","type":"blocks","created_at":"2026-02-18T14:08:31.354332+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-y8f","title":"Fix: CADDY_DNS_PROVIDER env var missing from docker-compose.yml caddy service (from hypercerts-0yp.1)","description":"Review of hypercerts-0yp.1 found: Caddyfile uses ${CADDY_DNS_PROVIDER} (line 11) and .env.example documents it (line 88), but docker-compose.yml only passes CADDY_DNS_API_KEY to the caddy service environment — CADDY_DNS_PROVIDER is not passed. The wildcard TLS DNS challenge will fail at runtime because the Caddy container won't have the DNS provider name. Evidence: docker-compose.yml caddy environment block only has CADDY_DNS_API_KEY; Caddyfile line 11 references both ${CADDY_DNS_PROVIDER} and ${CADDY_DNS_API_KEY}. Fix: add '- CADDY_DNS_PROVIDER=${CADDY_DNS_PROVIDER}' to the caddy service environment in docker-compose.yml.","status":"closed","priority":1,"issue_type":"bug","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-17T18:53:09.612553+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-17T18:56:11.830453+08:00","closed_at":"2026-02-17T18:56:11.830455+08:00","dependencies":[{"issue_id":"hypercerts-y8f","depends_on_id":"hypercerts-0yp.1","type":"discovered-from","created_at":"2026-02-17T18:53:09.731197+08:00","created_by":"sharfy-test.climateai.org"}]}
{"id":"hypercerts-y9g","title":"Epic: Scaffold Email-First Login UI","description":"## Goal\nAdd an email-first login page to the scaffold Next.js app. Users enter their email, get redirected to the sidecar for OTP, and come back authenticated. Also add a handle-based fallback for existing ATProto/Bluesky users.\n\n## Context\nThe scaffold currently has handle-based login only:\n- components/login-dialog.tsx: form with handle input, calls useLoginMutation\n- app/api/auth/login/route.ts: POST handler that calls sdk.authorize(handle)\n- app/api/auth/callback/route.ts: OAuth callback handler (works for both flows)\n- providers/SignedInProvider.tsx: auth gate that shows LoginDialog if not signed in\n\n## What Needs to Change\n1. New /login page with email input as primary option + handle fallback as secondary\n2. New /api/auth/email-login route that calls sdk.authorize(pdsUrl, { login_hint: email })\n3. New useEmailLoginMutation hook\n4. The existing handle-based flow stays untouched — both coexist\n\n## The Email Login Flow\n1. User visits /login, enters email, clicks Continue\n2. Scaffold POSTs to /api/auth/email-login with { email }\n3. Route calls sdk.authorize(NEXT_PUBLIC_PDS_URL) — this is the key shortcut: passing the PDS URL directly skips handle resolution\n4. The authorize URL includes login_hint=email as a query parameter\n5. Browser redirects to PDS → PDS metadata points to sidecar → sidecar shows OTP form\n6. After OTP verification, browser redirects back to /api/auth/callback (same as handle flow)\n7. User is logged in\n\n## Key Technical Detail\nsdk.authorize() accepts a handle, DID, or PDS URL. When given a PDS URL like 'https://certified.app', it skips handle→DID→PDS resolution and goes directly to that PDS. The login_hint parameter is passed through to the authorization URL so the sidecar can auto-send the OTP.\n\n## Existing Code to Reference\n- lib/config.ts: has config.pdsUrl (from NEXT_PUBLIC_PDS_URL env var)\n- lib/hypercerts-sdk.ts: SDK initialization with sdk.authorize()\n- queries/auth.ts: useLoginMutation hook\n- components/login-dialog.tsx: existing handle login UI\n\n## Hard Constraints\n- Don't break the existing handle-based login\n- Don't modify the OAuth callback route\n- Email-first must be the primary/default option on /login\n- Handle fallback must be secondary (smaller, below a divider)","status":"closed","priority":1,"issue_type":"epic","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","created_at":"2026-02-18T15:47:46.193644+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:59.058144+08:00","closed_at":"2026-02-18T15:54:59.058146+08:00","labels":["scope:small"]}
{"id":"hypercerts-y9g.1","title":"Add /login page, email-login API route, and useEmailLoginMutation hook","description":"## Files\n- app/login/page.tsx (create)\n- app/api/auth/email-login/route.ts (create)\n- queries/mutations/use-email-login-mutation.ts (create)\n- lib/api/auth.ts (modify — add emailLogin function)\n- providers/SignedInProvider.tsx (modify — allow /login to bypass auth gate)\n\n## What to do\n\n### 1. API route: app/api/auth/email-login/route.ts\n```typescript\nimport sdk from '@/lib/hypercerts-sdk'\nimport { config } from '@/lib/config'\nimport { NextResponse } from 'next/server'\n\nexport async function POST(request: Request) {\n  const { email } = await request.json()\n  if (!email || typeof email !== 'string') {\n    return Response.json({ error: 'Email is required' }, { status: 400 })\n  }\n  try {\n    // Pass PDS URL directly — skips handle resolution\n    // Append login_hint so sidecar auto-sends OTP\n    const authUrl = await sdk.authorize(config.pdsUrl)\n    // Append login_hint to the auth URL\n    const url = new URL(authUrl)\n    url.searchParams.set('login_hint', email)\n    return NextResponse.json({ authUrl: url.toString() })\n  } catch (e) {\n    console.error('Failed to initiate email login', e)\n    return Response.json({ error: 'Failed to initiate login' }, { status: 500 })\n  }\n}\n```\n\n### 2. API client function: lib/api/auth.ts\nAdd `emailLogin(email: string)` that POSTs to /api/auth/email-login and redirects to the returned authUrl.\n\n### 3. Mutation hook: queries/mutations/use-email-login-mutation.ts\nSame pattern as existing useLoginMutation but calls emailLogin(email) instead.\n\n### 4. Login page: app/login/page.tsx\nDual-option layout:\n- **Primary (top)**: Email input + Continue button. Uses useEmailLoginMutation.\n- **Divider**: '— or —' separator\n- **Secondary (bottom)**: 'Already have a Bluesky account?' + handle input + Sign in button. Uses existing useLoginMutation.\n- Email section: larger, primary button styling\n- Handle section: smaller, outline/ghost button styling\n- Both disable during loading, show Spinner, show toast on error (sonner)\n\n### 5. Auth gate bypass\nModify SignedInProvider.tsx to NOT redirect /login to the LoginDialog. The /login page should be accessible without authentication.\n\n## Existing patterns to follow\n- Look at components/login-dialog.tsx for the handle login pattern\n- Look at queries/auth.ts for useLoginMutation\n- Use shadcn components: Card, Input, Button, Separator, Spinner\n- Use fonts: Syne for headings, Outfit for body text\n- Use sonner toast for errors\n\n## Don't\n- Modify the existing /api/auth/login route\n- Modify the existing /api/auth/callback route\n- Modify components/login-dialog.tsx\n- Add new npm dependencies\n- Hard-code the PDS URL (use config.pdsUrl)","acceptance_criteria":"1. /login page renders with email input (primary) and handle input (secondary). 2. POST /api/auth/email-login returns authUrl with login_hint parameter. 3. useEmailLoginMutation hook works and redirects on success. 4. /login is accessible without authentication. 5. Existing handle login still works. 6. pnpm build succeeds. 7. pnpm lint passes.","status":"closed","priority":1,"issue_type":"task","assignee":"sharfy-test.climateai.org","owner":"sharfy-test.climateai.org","estimated_minutes":45,"created_at":"2026-02-18T15:48:05.74398+08:00","created_by":"sharfy-test.climateai.org","updated_at":"2026-02-18T15:54:58.985059+08:00","closed_at":"2026-02-18T15:54:58.98506+08:00","labels":["scope:small"],"dependencies":[{"issue_id":"hypercerts-y9g.1","depends_on_id":"hypercerts-y9g","type":"parent-child","created_at":"2026-02-18T15:48:05.745957+08:00","created_by":"sharfy-test.climateai.org"}]}
